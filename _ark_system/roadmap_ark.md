# ДОРОЖНАЯ КАРТА СИСТЕМЫ ARK v5.0

## НАЗНАЧЕНИЕ

Этот документ описывает план развития и улучшения **исключительно фреймворка ARK**.

---
### ЗАВЕРШЕННЫЕ ЭТАПЫ

*   **Этап 1-24:** Развитие до ARK v3.8.
*   **Этап 26:** Унификация Механизма Целостности.

---
### <<< СЛЕДУЮЩИЕ ЭТАПЫ >>>

### Этап 20: Восстановление Надежности Базового Инструментария (Приоритет №0, БЛОКЕР)
*   **Цель:** Устранить критические уязвимости в базовых инструментах, которые делают любую дальнейшую работу ненадежной и рискованной.
*   **Описание Проблемы:** Базовый инструмент `cli.py` искажает или обрезает вывод системных команд, что делает невозможным достоверный анализ файловой системы. ИИ-Исполнитель систематически генерирует неработоспособные команды (контекстная контаминация, EXP-0039).
*   **Ожидаемый Результат:** Полностью надежный базовый инструментарий и системные гарантии качества генерируемых артефактов.
*   [ ] **[ЗАДАЧА 20.1][CRITICAL-BLOCKER]** Провести диагностику инструмента `cli.py`.
*   [ ] **[ЗАДАЧА 20.2][CRITICAL-BLOCKER]** На основе результатов диагностики, произвести ремонт `cli.py`.
*   [ ] **[ЗАДАЧА 20.3][CRITICAL]** Разработать и внедрить обязательный программный модуль "стерилизации" вывода.

### Этап 34: Ремонт Механизма Копирования в Буфер Обмена (Приоритет №1, БАГ)
*   **Цель:** Восстановить критически важную функцию автоматического копирования "Транзакционной Квитанции".
*   **Описание Проблемы:** Инструмент `apply_modifications.py` не копирует квитанцию в буфер обмена.
*   **Ожидаемый Результат:** Функция автоматического копирования полностью восстановлена.
*   [ ] **[ЗАДАЧА 34.1][CRITICAL]** Провести диагностику функции `save_receipt_and_copy`.
*   [ ] **[ЗАДАЧА 34.2]** Реализовать исправление.

### Этап 35: Устранение Технического Долга (Приоритет №2)
*   **Цель:** Повысить качество и долговечность кода инструментария, устранив использование устаревших функций.
*   **Описание Проблемы:** В коде `apply_modifications.py` используются вызовы `datetime.utcnow()`.
*   **Ожидаемый Результат:** Все вызовы `utcnow()` заменены на `datetime.now(timezone.utc)`.
*   [ ] **[ЗАДАЧА 35.1]** Провести рефакторинг `apply_modifications.py`.

### Этап 32: Внедрение 'Хирургических' Команд в apply_modifications.py (СТРАТЕГИЧЕСКИЙ)
*   **Цель:** Устранить архитектурное ограничение, добавив команды для точной модификации кода.
*   **Описание Проблемы:** `MODIFY_FILE` является избыточной для небольших изменений.
*   **Ожидаемый Результат:** `apply_modifications.py` расширен новыми, более точными командами.
*   [ ] **[ЗАДАЧА 32.1]** Реализовать `INSERT_AFTER_PATTERN`.
*   [ ] **[ЗАДАЧА 32.2]** Реализовать `DELETE_BLOCK_BY_ANCHORS`.
*   [ ] **[ЗАДАЧА 32.3]** Внедрить стандарт для якорей в `ARK_CODEX.md`.

### Этап 36: Внедрение 'Умного Приемника' (СТРАТЕГИЧЕСКИЙ)
*   **Цель:** Сделать процесс взаимодействия с ИИ более отказоустойчивым к ошибкам форматирования.
*   **Описание Проблемы:** ИИ или платформа могут генерировать "зашумленный" JSON, который инструмент не может обработать.
*   **Ожидаемый Результат:** `apply_modifications.py` способен сам находить и извлекать "чистый" JSON из "зашумленного" текста.
*   [ ] **[ЗАДАЧА 36.1]** Реализовать в `apply_modifications.py` многоуровневый механизм поиска JSON.

### Этап 37: Обработка 'Застрявших' Lock-файлов (Надежность)
*   **Цель:** Повысить отказоустойчивость инструментария, внедрив механизм автоматической очистки устаревших lock-файлов.
*   **Описание Проблемы:** Если `apply_modifications.py` завершается аварийно, он может оставить `_staging/.apply.lock`, что заблокирует все последующие запуски.
*   **Ожидаемый Результат:** Инструмент способен сам определять и удалять "застрявшие" lock-файлы от завершившихся процессов.
*   [ ] **[ЗАДАЧА 37.1]** Интегрировать в `apply_modifications.py` проверку PID из lock-файла с помощью `psutil`.

### Этап 38: Гарантированная Запись на Диск (Надежность)
*   **Цель:** Защитить данные от потери при внезапном сбое системы в момент записи файла.
*   **Описание Проблемы:** Стандартная операция записи может не успеть сбросить данные из буфера на физический диск перед сбоем.
*   **Ожидаемый Результат:** Все критические файловые операции используют `os.fsync()` для принудительной синхронизации с диском.
*   [ ] **[ЗАДАЧА 38.1]** Внедрить вызовы `os.fsync()` в `apply_modifications.py` перед всеми операциями `os.replace()`.

<!-- [ARK_INTEGRITY_CHECKSUM::sha256:eac05102744f297994bcca771b5f7060a65e7f3011ae401180549005ff788a4b] -->