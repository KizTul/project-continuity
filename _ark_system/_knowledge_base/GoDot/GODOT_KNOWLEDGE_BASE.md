# ИСТОЧНИК ИСТИНЫ: GODOT ENGINE (v3.0)

Этот документ является структурированной базой знаний по Godot Engine, скомпилированной из верифицированных источников для обеспечения точной и безошибочной работы ИИ-помощника. Данная версия объединяет фундаментальные концепции с лучшими практиками, подробным описанием редактора и углубленным разбором 2D и 3D систем.

---

## **РАЗДЕЛ 1: ФУНДАМЕНТАЛЬНЫЕ КОНЦЕПЦИИ**

### **Глава 1.1: Узлы и Сцены**

#### **1. Сущность: Узел (Node)**
*   **Определение:** Фундаментальный строительный блок. Аналог "ингредиента в рецепте".
*   **Характеристики:**
    1.  Имеет **имя**.
    2.  Имеет **редактируемые свойства** (отображаются в Инспекторе).
    3.  Получает **обратные вызовы** (callbacks) для обновления в каждом кадре.
    4.  Может быть **расширен** новыми свойствами и функциями (через скрипты).
    5.  Может быть добавлен к другому узлу в качестве **дочернего**.

#### **2. Принцип: Древовидная структура (Tree Structure)**
*   **Определение:** Совокупность узлов, организованных в иерархию "родитель-потомок", формирует **дерево сцены (Scene Tree)**.
*   **Назначение:** Является мощным инструментом для организации проекта. Комбинирование узлов с разной функциональностью позволяет создавать сложное поведение.

#### **3. Сущность: Сцена (Scene)**
*   **Определение:** Дерево узлов, сохраненное как единое целое.
*   **Характеристики:**
    1.  Всегда имеет **один корневой узел**.
    2.  Может быть **сохранена** на диск (в формате `.tscn`) и загружена позже.
    3.  Может быть **инстанциирована** (создано множество копий одной сцены).
*   **Функциональность в редакторе:** Сохраненные сцены ведут себя как новые типы узлов, которые можно добавлять в другие сцены.

#### **4. Концепция: Главная Сцена (Main Scene)**
*   **Определение:** Сцена, которую движок загружает первой при запуске игры/приложения. Является точкой входа.

#### **5. Концепция: Путь `res://`**
*   **Определение:** Псевдоним для корневой директории проекта ("resource path"). Используется для доступа к файлам проекта.

---

### **Глава 1.2: Инстанциирование и Упакованные Сцены**

#### **1. Сущность: Упакованная Сцена (Packed Scene)**
*   **Определение:** Сцена, сохраненная в виде файла (`.tscn`). Является **шаблоном** или **чертежом**.

#### **2. Концепция: Инстанциирование (Instancing)**
*   **Определение:** Процесс создания "живого" объекта (экземпляра) на основе Упакованной Сцены.

#### **3. Принцип: Наследование и Переопределение**
*   **Наследование:** Экземпляры наследуют свойства и структуру от своего шаблона (`.tscn`). Изменение в шаблоне отразится на всех его экземплярах.
*   **Переопределение:** Каждый экземпляр является независимым объектом, и его свойства можно изменять индивидуально. Измененное свойство помечается иконкой "возврата".

#### **4. Сущность: Ресурс (Resource)**
*   **Определение:** Отдельные сущности (`PhysicsMaterial`, `Texture`, `Theme`), используемые узлами.
*   **Принцип совместного использования:** По умолчанию все экземпляры сцены **совместно используют один и тот же экземпляр ресурса**.
*   **Решение:** Чтобы изменить ресурс только для одного экземпляра, его необходимо сделать **"уникальным" (Make Unique)**.

---

### **Глава 1.3: Скрипты и языки программирования**

#### **1. Принцип: Расширение Узлов**
*   **Назначение:** Скрипты **присоединяются к узлу и расширяют его поведение**. Скрипт наследует все функции и свойства узла, к которому он прикреплен.

#### **2. Официальные языки**
*   **GDScript:** Рекомендуемый для начинающих. Объектно-ориентированный, императивный язык, созданный для Godot.
    *   **Преимущества:** Простой синтаксис, быстрая компиляция, тесная интеграция с редактором, отсутствие сборки мусора, постепенная типизация.
*   **C#:** Зрелый, производительный язык.
    *   **Особенности:** Требует внешний редактор, имеет сборщик мусора, есть ограничения по экспорту на web-платформу в Godot 4.
*   **C++ (через GDExtension):** Для максимальной производительности. Позволяет писать код на C++ без перекомпиляции движка.
*   **Возможность смешивания:** В одном проекте можно использовать несколько языков.

---

### **Глава 1.4: Основы GDScript и жизненный цикл узла**

#### **1. Ключевые слова и синтаксис**
*   `extends`: Определяет класс (тип узла), от которого скрипт наследуется. Если не указан, класс неявно наследуется от `RefCounted`.
*   `@export`: Аннотация, делающая переменную видимой и редактируемой в Инспекторе.
*   `var`: Объявление переменной.
*   `func`: Объявление функции.
*   `signal`: Объявление пользовательского сигнала.
*   `await`: Приостанавливает выполнение функции до получения сигнала.
*   `$NodeName`: Сокращение для `get_node("NodeName")`.

#### **2. Виртуальные функции и Уведомления (Lifecycle Callbacks & Notifications)**
*   **Соглашение:** Имена виртуальных функций, вызываемых движком, начинаются с `_`. Эти функции являются удобными обертками над внутренней системой **уведомлений**.
*   **Основные уведомления и их функции-обертки:**
    *   `NOTIFICATION_POSTINITIALIZE`: Срабатывает при инициализации объекта. Недоступно из скриптов.
    *   **`_init()`**: Конструктор класса. Вызывается один раз при создании объекта в памяти. Срабатывает до `_enter_tree()` и `_ready()`.
    *   `NOTIFICATION_ENTER_TREE`: Узел вошел в дерево сцены.
    *   **`_enter_tree()`**: Вызывается, когда узел добавлен в дерево сцены.
    *   `NOTIFICATION_READY`: Узел и все его потомки вошли в дерево сцены.
    *   **`_ready()`**: Вызывается один раз, когда узел и все его дочерние узлы полностью вошли в активную сцену. Рекомендуемое место для инициализации.
    *   `NOTIFICATION_PROCESS`: Кадровое обновление.
    *   **`_process(delta)`**: Вызывается в каждом кадре. `delta` — время, прошедшее с предыдущего кадра в секундах. Для логики, не связанной с физикой.
    *   `NOTIFICATION_PHYSICS_PROCESS`: Физическое обновление.
    *   **`_physics_process(delta)`**: Вызывается с фиксированным интервалом (по умолчанию 60/сек). Используется для кода, связанного с физикой (движение, столкновения).
    *   `NOTIFICATION_UNHANDLED_INPUT`: Необработанное событие ввода.
    *   **`_unhandled_input(event)`**: Вызывается при каждом событии ввода, которое не было перехвачено UI или `_input()`. Для дискретных действий (прыжок, выстрел).
    *   `NOTIFICATION_EXIT_TREE`: Узел выходит из дерева сцены.
    *   **`_exit_tree()`**: Вызывается, когда узел удаляется из дерева сцены.
    *   `NOTIFICATION_PREDELETE`: Срабатывает перед удалением объекта. Эквивалент деструктора.
*   **Порядок инициализации при инстанциировании сцены:**
    1.  **Присвоение начального значения:** `var test = "one"`
    2.  **Вызов `_init()`**: Здесь значение `test` может быть изменено.
    3.  **Присвоение экспортированного значения:** Значение из Инспектора перезаписывает текущее значение `test`.
*   **Другие полезные уведомления:**
    *   `NOTIFICATION_PARENTED`: Срабатывает, когда к узлу добавляют родителя.
    *   `NOTIFICATION_UNPARENTED`: Срабатывает, когда узел отсоединяют от родителя.

#### **3. Соглашения об именовании (GDScript)**
*   Классы (Узлы): `PascalCase`
*   Функции и переменные: `snake_case`
*   Константы: `ALL_CAPS_SNAKE_CASE`

---

### **Глава 1.5: Обработка пользовательского ввода**

#### **1. Карта ввода (Input Map)**
*   **Определение:** Механизм для создания абстрактных "действий" (`ui_up`, `attack`), к которым можно привязать физические клавиши, кнопки и оси геймпада.
*   **Расположение:** `Проект` -> `Настройки проекта...` -> `Input Map`.

#### **2. `Input` (синглтон)**
*   **Назначение:** Глобальный объект для проверки состояния ввода (обычно в `_process` или `_physics_process`). Используется для непрерывных действий (движение).
*   **Ключевые методы:** `Input.is_action_pressed()`, `Input.is_action_just_pressed()`, `Input.is_action_just_released()`, `Input.get_vector()`.

---

### **Глава 1.6: Межобъектное взаимодействие: Сигналы**

#### **1. Определение**
*   **Концепция:** Сообщения, которые узел "испускает" (emits), когда происходит событие. Другие узлы могут "подключаться" (connect) к этим сообщениям и реагировать на них.
*   **Архитектурная роль:** Реализация паттерна "Наблюдатель" (Observer) для создания слабой связанности (loose coupling).

#### **2. Способы подключения**
1.  **Через редактор:** Использование вкладки "Узел" ("Node") в Инспекторе.
2.  **Через код:** Использование метода `object.signal_name.connect(callable)`.

#### **3. Пользовательские сигналы**
*   **Объявление:** `signal health_depleted`
*   **Испускание:** `health_depleted.emit()`
*   **Передача данных:** `signal health_changed(value)` и `health_changed.emit(new_value)`.
*   **`bind()`**: Позволяет передать дополнительные аргументы в обработчик при подключении сигнала.

---

### **Глава 1.7: Физика и столкновения**

#### **1. Слои и Маски Столкновений (Layers & Masks)**
*   **Layer (Слой):** Определяет, *кем является* объект. Можно задавать имена в "Настройках проекта".
*   **Mask (Маска):** Определяет, с какими слоями объект *может взаимодействовать*.
*   **Принцип:** Столкновение регистрируется, если маска одного объекта пересекается со слоем другого.

#### **2. Ключевые узлы**
*   **`Area2D/3D`**: Для обнаружения пересечений (триггеров). Сигналы: `body_entered(body)`, `area_entered(area)`.
*   **`CharacterBody2D/3D`**: Для персонажей, управляемых кодом. Основной метод: `move_and_slide()`.
*   **`RigidBody2D/3D`**: Для объектов, управляемых физическим движком.
*   **`CollisionShape2D/3D`**: Задают физическую форму для родительского узла.

---

### **Глава 1.8: Пользовательский интерфейс (UI)**

#### **1. Ключевые узлы (наследуются от `Control`)**
*   **`CanvasLayer`**: Отрисовывает дочерние UI-элементы на отдельном слое поверх игрового мира, независимо от камеры.
*   **`Label`**: Для отображения текста.
*   **`Button`**: Кнопка, испускает сигнал `pressed`.

#### **2. Якоря (Anchors)**
*   **Назначение:** Механизм, который определяет, как `Control`-узел будет позиционироваться и изменять размер относительно родительского контейнера.

#### **3. Темы (Themes)**
*   **Назначение:** Ресурс `Theme` или секция `Theme Overrides` в Инспекторе позволяют централизованно управлять визуальным стилем UI (шрифты, цвета, стили).

---

### **Глава 1.9: Группы и массовые операции**

#### **1. Определение**
*   **Концепция:** Механизм для добавления тегов (имен групп) к узлам. Позволяет обращаться к группе узлов и выполнять над ними действия коллективно.
*   **API:** `get_tree().call_group("group_name", "function_name")`, `node.is_in_group("group_name")`.

---

### **Глава 1.10: Глобальный доступ и менеджеры (Autoload)**

*   **Назначение:** Автоматически загружает скрипт или сцену при старте игры и делает их глобально доступными из любого места кода.
*   **Применение:** Идеально подходит для систем, которые должны существовать независимо от сцен (фоновая музыка, управление состоянием игры, менеджер звуков).
*   **Предостережение:** Глобальный доступ может нарушать инкапсуляцию и усложнять отладку. Autoload'ы следует использовать для действительно глобальных систем, а не для обмена данными между локальными сценами.
*   **Настройка:** `Проект` -> `Настройки проекта...` -> `Autoload`.

---

### **Глава 1.11: Анимация**

#### **1. `AnimatedSprite2D` (Кадровая анимация)**
*   **Назначение:** Для простой 2D-анимации, основанной на смене кадров.
*   **Ресурс:** `SpriteFrames`, хранит именованные наборы анимаций.

#### **2. `AnimationPlayer` (Анимация по ключевым кадрам)**
*   **Назначение:** Мощный узел для создания сложных, основанных на временной шкале (timeline) анимаций. Может анимировать практически любое свойство любого узла.
*   **Концепции:**
    *   **Дорожка (Track):** Представляет одно анимируемое свойство.
    *   **Ключевой кадр (Keyframe):** "Снимок" значения свойства в определенный момент времени.
---

## **РАЗДЕЛ 2: ЛУЧШИЕ ПРАКТИКИ И АРХИТЕКТУРНЫЕ ПАТТЕРНЫ**

### **Глава 2.1: Принципы ООП в Godot**
*   **"Классы" в Godot:** Эту роль выполняют две сущности — **Скрипты** и **Сцены**.
    *   **Скрипты:** Являются ресурсами, расширяющими поведение встроенных классов (узлов). Скрипт без `extends` неявно наследуется от `RefCounted`.
    *   **Сцены:** Функционируют как классы. Они переиспользуемы, инстанциируемы и могут наследоваться. Сцена по сути является **расширением скрипта, прикрепленного к ее корневому узлу**.

### **Глава 2.2: Организация Сцен и Слабая Связанность**
*   **Основной Принцип:** Сцены должны быть самодостаточными, без зависимостей от внешнего окружения.
*   **Внедрение зависимостей (Dependency Injection):** Родительский узел должен предоставлять зависимости дочернему, а не наоборот. Способы:
    1.  **Сигналы:** Потомок испускает сигнал, родитель реагирует (предпочтительно).
    2.  **Вызов метода:** Родитель вызывает метод потомка.
*   **Взаимодействие "соседей":** Узлы одного уровня иерархии не должны знать друг о друге. Их взаимодействие координируется общим родителем.
*   **Предупреждения о зависимостях:** Рекомендуется использовать `_get_configuration_warnings()` для вывода предупреждений в редакторе, если необходимые для сцены зависимости не установлены.

### **Глава 2.3: Структура дерева узлов**
*   **Рекомендуемая структура:** `Main` (корневой узел) -> `World` (игровой мир) + `GUI` (интерфейс). Смена уровней происходит заменой дочерних узлов в `World`.
*   **"Проблема Игрока":** Не рекомендуется делать узел игрока дочерним элементом уровня. Лучше держать его в отдельной ветке дерева (например, потомок `Main`), чтобы он сохранялся при смене уровней.
*   **Разрыв наследования трансформации:**
    1.  **Декларативно:** Вставить узел `Node` между родителем и потомком.
    2.  **Императивно:** Использовать свойство `top_level` у `CanvasItem` или `Node3D`.

### **Глава 2.4: Сцены vs. Скрипты**
*   **Когда использовать Сцену:** Для сущностей, которые являются частью игрового мира (`Player`, `Enemy`, `Item`). Сцены проще для редактирования и безопаснее.
*   **Когда использовать Скрипт:** Для создания базового инструмента, который будет переиспользоваться в разных проектах, или для чистой логики/данных, не имеющих представления в мире.
*   **Производительность:** `PackedScene.instantiate()` значительно быстрее, чем создание узлов и их настройка через код, так как движок выполняет эти операции пакетами на стороне C++.

### **Глава 2.5: Оптимизация: Альтернативы Узлам**
*   **Проблема:** Использование узлов для всего может быть избыточным и влиять на производительность.
*   **Альтернативы для хранения данных:**
    *   **`Object`:** Самый легковесный класс, требует ручного управления памятью.
    *   **`RefCounted`:** Считает ссылки на себя, автоматически освобождает память, когда ссылок не остается. Базовый класс для скриптов.
    *   **`Resource`:** Наследуется от `RefCounted`, имеет возможность сериализации (сохранение/загрузка) и отображения свойств в Инспекторе. Идеально для данных.

### **Глава 2.6: Предпочтения в логике**
*   **Инициализация:** Всегда сначала настраивайте свойства узла, и только потом добавляйте его в дерево сцены (`add_child()`).
*   **`preload` vs. `load`:**
    *   **`preload`**: Загружает ресурс при загрузке скрипта (во время компиляции). Требует статического пути. Быстрее в рантайме, но увеличивает время загрузки.
    *   **`load`**: Загружает ресурс в момент выполнения строки кода. Путь может быть динамическим. Вызывает короткую задержку при выполнении.
*   **Статические vs. Динамические уровни:**
    *   **Статические:** Проще, для небольших игр. Весь уровень загружается сразу.
    *   **Динамические:** Сложнее в реализации, но экономят память. Уровень подгружается и выгружается частями. Необходимы для больших игр.

### **Глава 2.7: Организация Проекта и Стиль**
*   **Структура папок:** Группируйте ассеты по сценам/сущностям, а не по типам. Например: `player/player.tscn`, `player/player.gd`, `player/player_sprite.png`.
*   **Стиль именования:**
    *   Файлы и папки: `snake_case` (например, `player_character.gd`). Исключение: C# скрипты.
    *   Имена узлов: `PascalCase` (например, `PlayerCharacter`).
*   **Игнорирование файлов в VCS:** Всегда добавляйте в `.gitignore` папку `.godot/`.
---

## **РАЗДЕЛ 3: РЕДАКТОР GODOT ENGINE**

### **Глава 3.1: Обзор Интерфейса**
*   **Менеджер Проектов (Project Manager):** Первое окно при запуске. Позволяет создавать, импортировать, сканировать и запускать проекты. Поддерживает теги для организации. Имеет "Режим восстановления" (Recovery Mode) для безопасного открытия поврежденных проектов.
*   **Инспектор (Inspector):** Основная панель для просмотра и редактирования свойств выбранного узла или ресурса.
*   **Редактор Скриптов (Script Editor):** Встроенный текстовый редактор с подсветкой синтаксиса, автодополнением, отладчиком (точки останова), поиском по файлам и другими функциями.
*   **Файловая система (FileSystem):** Панель для навигации по файлам проекта (`res://`).

### **Глава 3.2: Настройки Проекта (Project Settings)**
*   **Доступ:** `Проект -> Настройки проекта...`.
*   **Сущность:** Окно для настройки глобальных параметров проекта, которые сохраняются в файл `project.godot`.
*   **Основные разделы:** `General` (Общие), `Input Map` (Карта ввода), `Localization` (Локализация), `Plugins` (Плагины).
*   **Изменение из кода:**
    *   `ProjectSettings.get_setting(path)`: Чтение настройки.
    *   `ProjectSettings.set_setting(path, value)`: Запись настройки.
    *   **Важно:** Большинство настроек читаются только при старте. Для изменения параметров в рантайме используйте соответствующие серверы (например, `DisplayServer`, `Engine`).

### **Глава 3.3: Настройки Редактора (Editor Settings)**
*   **Доступ:** `Редактор -> Настройки редактора...`.
*   **Сущность:** Глобальные настройки, применяемые ко всем проектам и не сохраняемые в `project.godot`. Хранятся в конфигурационных файлах пользователя.
*   **Кастомизация интерфейса:**
    *   **Расположение панелей:** Панели можно перемещать, изменять их размер и делать "плавающими" (для многомониторных конфигураций).
    *   **Сохранение раскладки:** `Редактор -> Раскладки редактора -> Сохранить раскладку`.
    *   **Тема:** Можно выбрать светлую, темную или кастомную тему.
    *   **Язык и масштаб.**

### **Глава 3.4: Горячие клавиши (Shortcuts)**
*   Godot имеет обширный список горячих клавиш для ускорения работы. Полный список можно найти и настроить в `Редактор -> Настройки редактора... -> Shortcuts`.
*   **Ключевые примеры:**
    *   **F5**: Запустить игру.
    *   **F6**: Запустить текущую сцену.
    *   **Ctrl+S**: Сохранить сцену.
    *   **Q, W, E, R**: Инструменты выделения, перемещения, вращения, масштабирования.
    *   **F**: Сфокусировать камеру на выделенном объекте.
    *   **Ctrl+Shift+F**: Поиск по всем файлам проекта.

### **Глава 3.5: Продвинутые возможности**
*   **Командная строка (Command Line):** Godot можно запускать с флагами для автоматизации задач (экспорт, запуск скриптов, отладка).
*   **Внешние редакторы (External Editors):** Godot можно интегрировать с VS Code, Emacs, JetBrains Rider и др. через настройки редактора и LSP/DAP протоколы.
*   **Профили функций (Feature Profiles):** Позволяют отключать части интерфейса редактора для упрощения, например, для обучения или для чисто 2D/3D проектов.

### **Глава 3.6: Специализированные редакторы**
*   **XR Editor:** Версия редактора, работающая нативно на VR/AR устройствах (Meta Quest).
*   **Android Editor:** Порт редактора для запуска на Android-устройствах.
*   **Web Editor:** HTML5 версия редактора, работающая в браузере. Имеет ряд ограничений (нет C#, экспорта, отладки).

### **Глава 3.7: Решение проблем (Troubleshooting)**
*   **Низкая производительность редактора:** Попробуйте включить `Low Processor Mode Sleep`, отключить `Update Continuously` или снизить разрешение 3D-вьюпорта (`Half Resolution`).
*   **Проект не загружается после экспорта:** Убедитесь, что все не-ресурсные файлы (например, `.json`, `.txt`) добавлены в фильтр экспорта.
*   **Проблемы с графикой (резкость, размытость):** Проверьте настройки драйвера видеокарты (отключите Image Sharpening, FXAA).
---

## **РАЗДЕЛ 4: РАБОТА В 2D**

### **Глава 4.1: Рабочее пространство 2D**
*   **Координатная система:** Ось `X` направлена вправо, ось `Y` — **вниз**.
*   **Viewport Toolbar:** Содержит инструменты для манипуляции узлами: выделение, перемещение, вращение, масштабирование, линейка, привязка.
*   **Привязка (Snapping):** Позволяет выравнивать узлы по сетке, пикселям, другим узлам, направляющим.

### **Глава 4.2: Координаты и Трансформации**
*   **`CanvasLayer`**: Отдельный слой рендеринга, который не зависит от трансформации основной камеры. Используется для UI, параллакса. Порядок отрисовки определяется свойством `layer`.
*   **Системы координат:**
    *   **Локальные (Local):** Относительно родительского узла.
    *   **Глобальные (Global/Canvas):** Относительно `CanvasLayer`.
    *   **Экранные (Screen):** Относительно окна игры.
*   **Функции трансформации:** `get_global_transform()`, `get_screen_transform()`, `make_input_local()` и др. для преобразования координат.

### **Глава 4.3: Рендеринг в 2D**
*   **2D Свет и Тени:**
    *   **`PointLight2D`**: Всенаправленный или конусообразный источник света.
    *   **`DirectionalLight2D`**: Имитирует удаленный источник (солнце, луна).
    *   **`LightOccluder2D`**: Узел, отбрасывающий тень. Может быть сгенерирован из `Sprite2D`.
    *   **`CanvasModulate`**: Задает "окружающий" цвет для всей сцены.
*   **Карты нормалей и отражений (Normal/Specular maps):** Позволяют создавать псевдо-объем на 2D-спрайтах, заставляя их по-разному реагировать на свет.
*   **Аддитивные спрайты:** Использование `Sprite2D` с `Blend Mode = Add` как быстрая альтернатива источникам света для эффектов (взрывы, выстрелы).

### **Глава 4.4: 2D Меши (Meshes)**
*   **Назначение:** Оптимизация рендеринга спрайтов с большим количеством прозрачных областей (например, деревья).
*   **Принцип:** `Sprite2D` преобразуется в `MeshInstance2D`, который рисует только полигоны с непрозрачными пикселями, пропуская отрисовку пустых областей.

### **Глава 4.5: 2D Анимация**
*   **`AnimatedSprite2D`**: Для простой покадровой анимации. Использует ресурс `SpriteFrames`. Легок в настройке.
*   **`AnimationPlayer` + `Sprite2D`**: Более мощный подход. `Sprite2D` используется для отображения спрайт-листа, а `AnimationPlayer` анимирует его свойство `frame`, переключая кадры. Позволяет синхронизировать анимацию с другими событиями (звуки, эффекты).

### **Глава 4.6: Физика и Движение (`CharacterBody2D`)**
*   **8-стороннее движение:** Используется `Input.get_vector()` для получения направления и `move_and_slide()` для перемещения.
*   **Вращение + движение ("Asteroids-style"):** Вращение управляется через свойство `rotation`, а движение — через `velocity`, рассчитанное на основе `transform.x`.
*   **Поворот к мыши:** Используется метод `look_at(get_global_mouse_position())`.
*   **Click-and-move:** В `_input` запоминается целевая позиция, а в `_physics_process` тело движется к ней, пока `position.distance_to(target)` больше порогового значения.

### **Глава 4.7: Инструменты 2D: TileMaps**
*   **`TileMap` и `TileSet`:**
    *   **`TileSet`**: Ресурс, который является "палитрой" тайлов. Хранит текстуры (атласы), информацию о столкновениях, навигации, террейнах и кастомных данных.
    *   **`TileMap`**: Узел, который использует `TileSet` для "рисования" уровня.
*   **Слои `TileMap`:** Позволяют рисовать на разных уровнях в одном узле (например, фон, земля, декорации).
*   **Слои `TileSet`:** Внутри `TileSet` можно определять слои для физики, навигации, окклюдеров, кастомных данных.
*   **Террейны (Terrains / Autotiling):** Мощный инструмент для автоматического соединения тайлов по заданным правилам (битовым маскам), что значительно ускоряет создание уровней.
*   **Паттерны (Patterns):** Позволяют сохранять и переиспользовать готовые комбинации тайлов.
---

## **РАЗДЕЛ 5: РАБОТА В 3D**

### **Глава 5.1: Рабочее пространство 3D**
*   **Координатная система:** Правая (Right-handed), `Y-Up`. Ось `X` — вправо, `Y` — вверх, `Z` — **назад** (от камеры).
*   **Единицы измерения:** 1 юнит = 1 метр.
*   **Навигация:** Схема по умолчанию схожа с Blender. Можно переключить на Maya-подобную.
*   **Гизмо (Gizmos):** Визуальные манипуляторы для перемещения (стрелки), вращения (кольца) и масштабирования (кубы).

### **Глава 5.2: 3D Трансформации**
*   **Проблема Эйлеровых углов (`rotation`):** Следует **избегать** прямого использования свойства `rotation` для 3D-объектов. Оно страдает от проблемы "складывания рамок" (Gimbal Lock) и некорректной интерполяции.
*   **`Transform3D` и `Basis`:**
    *   **`Transform3D`**: Основной тип данных для представления положения, вращения и масштаба в 3D. Состоит из `Basis` и `origin`.
    *   **`Basis`**: Матрица 3x3, хранящая информацию о вращении и масштабе в виде трех векторов (`x`, `y`, `z`), указывающих локальные оси объекта.
    *   **`origin`**: `Vector3`, хранящий позицию.
*   **Манипуляции:** Вращение выполняется методами `rotate_object_local()` или `rotated()`, которые напрямую оперируют `Basis`.
*   **Кватернионы (`Quaternion`):** Используются для математически корректной и плавной **интерполяции** между двумя ориентациями (вращениями). Для этого `Basis` преобразуется в `Quaternion`, интерполируется (`slerp`), и преобразуется обратно.

### **Глава 5.3: Геометрия и Модели**
*   **Процедурная геометрия (`ArrayMesh`):** Позволяет создавать 3D-меши программно "на лету" из массивов вершин, нормалей, UV и т.д., используя метод `add_surface_from_arrays()`.
*   **Текст в 3D:**
    *   **`Label3D`:** Быстрый, рендерит текст на плоском кваде.
    *   **`TextMesh`:** Создает настоящую 3D-геометрию из текста. Медленнее, но позволяет задать глубину, использовать кастомные шейдеры и корректно отбрасывает тени.
    *   **Проецируемые `Control`-узлы:** Самый гибкий, но сложный метод, позволяющий отобразить любой 2D-интерфейс в 3D-пространстве.

### **Глава 5.4: Рендеринг в 3D**
*   **Ограничения рендеринга:**
    *   **Z-Fighting:** Мерцание близко расположенных поверхностей. Решается настройкой `Near` и `Far` у камеры.
    *   **Сортировка прозрачности:** Прозрачные объекты могут рендериться в неверном порядке. Решается использованием режимов `Alpha Scissor`, `Alpha Hash` или `Depth Pre-Pass` вместо `Alpha Blend`.
*   **Материалы (`StandardMaterial3D`):**
    *   **PBR-свойства:** Albedo (цвет), Metallic (металличность), Roughness (шероховатость), Emission (свечение), Normal Map (рельеф) и др.
    *   **Прозрачность:** Несколько режимов для разных нужд (`Alpha`, `Alpha Scissor`, `Alpha Hash`).
    *   **Cull Mode:** Определяет, какая сторона полигонов не будет отрисовываться (`Back`, `Front`, `Disabled`).
    *   **Billboard Mode:** Заставляет объект всегда быть повернутым к камере.
*   **3D Свет и Тени:**
    *   **Типы света:** `DirectionalLight3D` (солнце), `OmniLight3D` (лампа), `SpotLight3D` (фонарь).
    *   **Карты теней (Shadow Mapping):** Настройки `Bias` помогают избежать артефактов самозатенения. `PSSM` для `DirectionalLight3D` улучшает качество теней на расстоянии.
*   **Декали (`Decal`):** Проецируют текстуру на существующую геометрию (следы пуль, грязь). Не меняют саму геометрию и работают только в рендерерах Forward+ и Mobile.
*   **Физические единицы света и камеры:**
    *   **Назначение:** Использование реальных физических величин (люмены, люксы, кельвины, f-stop) для настройки света и камеры для достижения фотореализма.
    *   **Требования:** Включается в настройках проекта, требует наличия узла `WorldEnvironment` и ресурса `CameraAttributes` у камеры.
---

## **РАЗДЕЛ 6: СИСТЕМЫ ЧАСТИЦ (3D)**

### **Глава 6.1: Основы Систем Частиц**

#### **1. Концепция**
*   **Частицы (Particles):** Визуальные элементы (точки, спрайты), которые излучаются эмиттером и живут определенное время, следуя заданным правилам поведения.
*   **Эмиттер (Emitter):** Невидимая форма, которая определяет, где и как рождаются частицы.
*   **Назначение:** Создание динамических и органических эффектов: огонь, дым, магия, искры, водопады.

#### **2. Типы Систем Частиц**
*   **`GPUParticles3D` (GPU-частицы):**
    *   **Принцип:** Все вычисления производятся на видеокарте (GPU).
    *   **Преимущества:** Высочайшая производительность, могут рендерить сотни тысяч частиц. Поддерживают кастомные шейдеры.
    *   **Недостатки:** Меньше контроля над отдельными частицами, не все функции CPU-частиц доступны. Не могут напрямую взаимодействовать с физическим миром игры.
*   **`CPUParticles3D` (CPU-частицы):**
    *   **Принцип:** Все вычисления производятся на центральном процессоре (CPU).
    *   **Преимущества:** Более гибкие, лучше поддержка на старом оборудовании и мобильных устройствах.
    *   **Недостатки:** Значительно ниже производительность. Не рекомендуется использовать для большого количества частиц.

#### **3. Ключевые компоненты**
*   **`ParticleProcessMaterial`:** Ресурс, который определяет **всё поведение** частиц: как они рождаются, движутся, меняют цвет, размер и исчезают.
*   **Draw Pass (Проход отрисовки):** Определяет **внешний вид** каждой частицы. Частица рендерится с помощью меша (`QuadMesh`, `SphereMesh` и т.д.). Одна система частиц может иметь до 4 проходов отрисовки для создания сложных эффектов.
*   **Collision (Коллайдеры):** Специальные узлы (`GPUParticlesCollisionBox3D`, `Sphere3D`, `SDF3D`, `HeightField3D`), которые позволяют GPU-частицам сталкиваться с окружением.
*   **Attractors (Аттракторы):** Специальные узлы (`GPUParticlesAttractorBox3D`, `Sphere3D`, `VectorField3D`), которые создают силовые поля, притягивающие или отталкивающие частицы.
*   **Sub-emitter (Суб-эмиттер):** Система частиц, которая порождает другую систему частиц (например, фейерверк взрывается и порождает искры).
*   **Trails (Шлейфы):** Позволяют частицам оставлять за собой след в виде ленты (`RibbonTrailMesh`) или трубы (`TubeTrailMesh`).

### **Глава 6.2: Свойства и Настройка**

#### **1. Свойства Эмиттера (`GPUParticles3D`)**
*   **`Emitting`:** Включает/выключает систему.
*   **`Amount`:** Максимальное количество видимых частиц.
*   **`Lifetime`:** Время жизни каждой частицы в секундах.
*   **`One Shot`:** Система испускает все частицы один раз и отключается.
*   **`Preprocess`:** Симуляция работы системы в течение указанного времени перед первым показом. Позволяет избежать "разогрева" эффекта на старте.
*   **`Speed Scale`:** Множитель скорости симуляции.
*   **`Explosiveness`:** Насколько одновременно испускаются частицы в одном "залпе".
*   **`Fixed FPS`:** Ограничение частоты обновления симуляции для стабильности. Включение `Interpolate` сглаживает движение при низком FPS.
*   **`Local Coords`:** Если включено, частицы движутся в локальной системе координат узла. Если выключено — в мировой.

#### **2. Свойства Материала (`ParticleProcessMaterial`)**
*   **Общий принцип:** Большинство свойств имеют `Min` и `Max` значение (для случайного разброса при рождении) и `Curve` (для изменения свойства в течение жизни частицы).
*   **`Spawn` (Рождение):**
    *   **`Emission Shape`:** Форма эмиттера (`Point`, `Sphere`, `Box`, `Ring`). Можно использовать меш для создания сложной формы.
    *   **`Direction` / `Spread`:** Основное направление и угол разброса.
    *   **`Initial Velocity`:** Начальная скорость.
*   **`Accelerations` (Ускорения):**
    *   **`Gravity`:** Симулирует гравитацию.
    *   **`Linear Accel`:** Линейное ускорение.
    *   **`Radial Accel`:** Ускорение к центру или от центра системы.
    *   **`Tangential Accel`:** Ускорение по касательной, закручивает частицы.
*   **`Display` (Отображение):**
    *   **`Scale`:** Размер частиц.
    *   **`Color`:** Цвет частиц. Можно использовать `Color Ramp` (градиент) для изменения цвета в течение жизни.
    *   **`Hue Variation`:** Добавляет случайное смещение оттенка цвета.
*   **`Animation`:**
    *   Управляет покадровой анимацией, если в качестве меша для отрисовки используется спрайт-лист.
*   **`Collision`:**
    *   **`Mode`:** Включает/выключает столкновения.
    *   **`Friction` / `Bounce`:** Трение и отскок при столкновении.
*   **`Turbulence`:**
    *   **`Enabled`:** Включает сложный, псевдослучайный шум для движения частиц.
    *   **Внимание:** Турбулентность очень требовательна к ресурсам GPU.
---

## **РАЗДЕЛ 7: ГЛОБАЛЬНОЕ ОСВЕЩЕНИЕ И HDR**

### **Глава 7.1: Введение в Глобальное Освещение (GI)**

#### **1. Концепция**
*   **Глобальное освещение (Global Illumination, GI):** Это совокупность техник, симулирующих **непрямое освещение** — свет, который отражается от поверхностей (рефлексы) и рассеивается в окружении. Прямое освещение — это свет, идущий непосредственно от источника к объекту. GI делает сцены значительно более реалистичными.

#### **2. Компоненты GI**
*   **Непрямое рассеянное освещение (Indirect Diffuse Lighting):** Свет, отраженный от матовых поверхностей. Именно он "подсвечивает" области в тени, окрашивая их в цвет отражающей поверхности.
*   **Непрямое бликовое освещение (Indirect Specular Lighting):** Отражения на глянцевых и металлических поверхностях.

#### **3. Сравнение техник GI в Godot**
| Техника | Тип | Производительность | Качество | Сильные стороны | Недостатки |
| :--- | :--- | :--- | :--- | :--- | :--- |
| **SDFGI** | Real-time (полу) | Очень высокая нагрузка | Хорошее | Масштабируемость, процедурные миры | Утечки света, артефакты при движении, только Forward+ |
| **VoxelGI** | Real-time (запекание) | Высокая нагрузка | Среднее | Полностью динамическое, работает с эмиссией | Утечки света, неточность, только Forward+ |
| **LightmapGI** | Baked (запекание) | Очень низкая нагрузка | Наивысшее | Фотореалистичность, работает везде | Только для статических объектов |
| **SSIL** | Real-time (Screen-Space) | Средняя нагрузка | Низкое | Динамичность, простота | Работает только в пределах экрана |
| **ReflectionProbe** | Baked / Real-time | Низкая/Средняя | Среднее (для отражений) | Основной способ создания отражений | Неточное непрямое освещение |

*   **Рекомендация для десктопа:** Начинайте с **SDFGI**. Если производительность низкая, переходите на **VoxelGI**. Если сцена в основном статическая и требуется максимальное качество, используйте **LightmapGI**. **SSIL** можно использовать как дополнение.
*   **Рекомендация для мобильных устройств:** Используйте только **LightmapGI** и **ReflectionProbe**.

### **Глава 7.2: VoxelGI (Воксельное Глобальное Освещение)**
*   **Принцип:** Сцена вокселизируется (превращается в 3D-сетку из вокселей), и в этой сетке "запекается" информация о непрямом свете. Динамические объекты могут получать и излучать свет в реальном времени.
*   **Настройка:**
    1.  Добавить узел `VoxelGIData`.
    2.  Настроить его размеры, чтобы он охватывал нужную часть сцены.
    3.  Нажать "Bake" на панели инструментов.
    4.  Для статических `MeshInstance3D` установить `Global Illumination Mode` в `Static`.
*   **Ключевые свойства:** `Subdiv` (детализация), `Extents` (размер), `Propagation` (сила отскока света).
*   **Ограничения:** Требовательно к GPU, работает только в рендерере **Forward+**.

### **Глава 7.3: SDFGI (Signed Distance Field Global Illumination)**
*   **Принцип:** Техника, работающая в реальном времени, которая использует каскады знаковых дистанционных полей (SDF) для расчета непрямого освещения. Не требует "запекания".
*   **Настройка:**
    1.  Добавить узел `WorldEnvironment`.
    2.  В его ресурсе `Environment` включить `SDFGI -> Enabled`.
*   **Ключевые свойства:** `Cascades` (количество каскадов), `Min Cell Size` (детализация), `Bounce Feedback` (сила отскока света).
*   **Ограничения:** Очень требовательно к GPU, работает только в рендерере **Forward+**. Может вызывать визуальные артефакты ("сплотчи") и каскадные сдвиги при движении камеры.

### **Глава 7.4: LightmapGI (Карты Света)**
*   **Принцип:** Самый старый и самый производительный метод. Непрямое освещение полностью "запекается" в специальную текстуру (лайтмап), которая накладывается на статическую геометрию.
*   **Настройка:**
    1.  Для всех статических мешей убедиться, что у них есть корректная **вторая UV-развертка (UV2)**. Это можно сделать при импорте модели или внутри Godot.
    2.  Добавить узел `LightmapGI`.
    3.  Для статических мешей установить `Global Illumination Mode` в `Static`.
    4.  Для источников света, которые должны быть запечены, установить `Bake Mode` в `Static`.
    5.  Нажать "Bake Lightmaps" на панели инструментов.
*   **Динамические объекты:** Могут получать запеченный свет через `LightmapProbe` или через `LightmapGI Mode = Dynamic` у меша, но это менее точно.
*   **Ограничения:** Процесс запекания может быть долгим. Работает только для статической геометрии.

### **Глава 7.5: Освещение с Расширенным Динамическим Диапазоном (HDR)**
*   **Концепция:** В реальном мире яркость света (от свечи до солнца) имеет огромный диапазон. Компьютерные мониторы имеют низкий динамический диапазон (LDR). HDR-рендеринг позволяет движку работать с реалистичными значениями яркости, а затем специальный процесс (Tonemapping) преобразует это изображение для корректного отображения на LDR-экране.
*   **sRGB -> Линейное пространство:** Текстуры обычно хранятся в нелинейном sRGB пространстве. Для корректных расчетов освещения движок должен преобразовывать их в линейное цветовое пространство. Этот процесс должен быть согласованным на всех этапах (импорт, рендеринг, вывод на экран).
*   **Настройка:** Основные параметры HDR и тональной компрессии находятся в ресурсе `Environment`.
---

## **РАЗДЕЛ 6: СИСТЕМЫ ЧАСТИЦ (3D)**

### **Глава 6.1: Основы Систем Частиц**

#### **1. Концепция**
*   **Частицы (Particles):** Визуальные элементы (точки, спрайты), которые излучаются эмиттером и живут определенное время, следуя заданным правилам поведения.
*   **Эмиттер (Emitter):** Невидимая форма, которая определяет, где и как рождаются частицы.
*   **Назначение:** Создание динамических и органических эффектов: огонь, дым, магия, искры, водопады.

#### **2. Типы Систем Частиц**
*   **`GPUParticles3D` (GPU-частицы):**
    *   **Принцип:** Все вычисления производятся на видеокарте (GPU).
    *   **Преимущества:** Высочайшая производительность, могут рендерить сотни тысяч частиц. Поддерживают кастомные шейдеры.
    *   **Недостатки:** Меньше контроля над отдельными частицами, не все функции CPU-частиц доступны. Не могут напрямую взаимодействовать с физическим миром игры.
*   **`CPUParticles3D` (CPU-частицы):**
    *   **Принцип:** Все вычисления производятся на центральном процессоре (CPU).
    *   **Преимущества:** Более гибкие, лучше поддержка на старом оборудовании и мобильных устройствах.
    *   **Недостатки:** Значительно ниже производительность. Не рекомендуется использовать для большого количества частиц.
*   **Конвертация:** Частицы можно конвертировать между GPU и CPU версиями через меню узла в 3D-вьюпорте, но при конвертации из GPU в CPU теряются некоторые продвинутые функции (Sub-emitters, Turbulence, Trails и др.).

#### **3. Ключевые компоненты**
*   **`ParticleProcessMaterial`:** Ресурс, который определяет **всё поведение** частиц: как они рождаются, движутся, меняют цвет, размер и исчезают.
*   **Draw Pass (Проход отрисовки):** Определяет **внешний вид** каждой частицы. Частица рендерится с помощью меша (`QuadMesh`, `SphereMesh` и т.д.). Одна система частиц может иметь до 4 проходов отрисовки для создания сложных эффектов.
*   **Collision (Коллайдеры):** Специальные узлы (`GPUParticlesCollisionBox3D`, `Sphere3D`, `SDF3D`, `HeightField3D`), которые позволяют GPU-частицам сталкиваться с окружением.
*   **Attractors (Аттракторы):** Специальные узлы (`GPUParticlesAttractorBox3D`, `Sphere3D`, `VectorField3D`), которые создают силовые поля, притягивающие или отталкивающие частицы.
*   **Sub-emitter (Суб-эмиттер):** Система частиц, которая порождает другую систему частиц (например, фейерверк взрывается и порождает искры).
*   **Trails (Шлейфы):** Позволяют частицам оставлять за собой след в виде ленты (`RibbonTrailMesh`) или трубы (`TubeTrailMesh`).

### **Глава 6.2: Свойства Эмиттера (`GPUParticles3D`)**
*   **`Emitting`:** Включает/выключает систему.
*   **`Amount`:** Максимальное количество видимых частиц.
*   **`Lifetime`:** Время жизни каждой частицы в секундах.
*   **`One Shot`:** Система испускает все частицы один раз и отключается.
*   **`Preprocess`:** Симуляция работы системы в течение указанного времени перед первым показом. Позволяет избежать "разогрева" эффекта на старте.
*   **`Speed Scale`:** Множитель скорости симуляции.
*   **`Explosiveness`:** Насколько одновременно испускаются частицы в одном "залпе".
*   **`Fixed FPS`:** Ограничение частоты обновления симуляции для стабильности. Включение `Interpolate` сглаживает движение при низком FPS.
*   **`Local Coords`:** Если включено, частицы движутся в локальной системе координат узла. Если выключено — в мировой.
*   **`Visibility AABB`:** Ограничивающий параллелепипед. Частицы за его пределами не будут рендериться. Необходим для корректной работы столкновений.

### **Глава 6.3: Свойства Материала (`ParticleProcessMaterial`)**

*   **Общий принцип:** Большинство свойств имеют `Min` и `Max` значение (для случайного разброса при рождении) и `Curve` (для изменения свойства в течение жизни частицы).

#### **1. Spawn (Рождение)**
*   **`Emission Shape`:** Форма эмиттера (`Point`, `Sphere`, `Box`, `Ring`). Можно использовать меш для создания сложной формы (`Directed Points`).
*   **`Direction` / `Spread`:** Основное направление и угол разброса.
*   **`Initial Velocity`:** Начальная скорость.

#### **2. Accelerations (Ускорения)**
*   **`Gravity`:** Симулирует гравитацию.
*   **`Linear Accel`:** Линейное ускорение.
*   **`Radial Accel`:** Ускорение к центру или от центра системы.
*   **`Tangential Accel`:** Ускорение по касательной, закручивает частицы.
*   **`Damping`:** Постепенно замедляет частицы (трение).

#### **3. Display (Отображение)**
*   **`Scale`:** Размер частиц.
*   **`Color`:** Цвет частиц. Можно использовать `Color Ramp` (градиент) для изменения цвета в течение жизни.
*   **`Hue Variation`:** Добавляет случайное смещение оттенка цвета.

#### **4. Animation**
*   Управляет покадровой анимацией, если в качестве меша для отрисовки используется спрайт-лист. Анимируются свойства `H Frames` и `V Frames` материала. Формула для плавной анимации: `Animation FPS = Number of images / Lifetime`.

#### **5. Collision**
*   **`Mode`:** Включает/выключает столкновения (`Disabled` / `Rigid` / `Hide On Contact`).
*   **`Friction` / `Bounce`:** Трение и отскок при столкновении.

#### **6. Turbulence**
*   **`Enabled`:** Включает сложный, псевдослучайный шум для движения частиц, используя 3D-текстуру шума.
*   **Внимание:** Турбулентность очень требовательна к ресурсам GPU.

### **Глава 6.4: Продвинутые Функции**

#### **1. Sub-emitters (Суб-эмиттеры)**
*   **Настройка:** В свойствах родительской системы частиц (`GPUParticles3D`) в поле `Sub Emitter` указывается узел другой системы частиц.
*   **Режим срабатывания:** В `ParticleProcessMaterial` родителя, в секции `Sub Emitter`, устанавливается режим (`Disabled`, `Constant`, `At End`, `At Collision`).
*   **Ограничения:** Рекурсивные суб-эмиттеры не работают. Общее число частиц ограничено свойством `Amount` суб-эмиттера.

#### **2. Trails (Шлейфы)**
*   **Настройка:** Включается в `GPUParticles3D` -> `Trails`. Требуется настройка `Process Material` и `Draw Pass` для шлейфа.
*   **Типы мешей для отрисовки:**
    *   `RibbonTrailMesh`: Создает след в виде ленты.
    *   `TubeTrailMesh`: Создает след в виде трубы/цилиндра.
*   **Ключевые свойства:** `Sections` (гладкость), `Section Length` (длина сегмента), `Curve` (форма).

#### **3. Attractors (Аттракторы)**
*   **Назначение:** Узлы, создающие силовые поля для влияния на частицы.
*   **Типы:**
    *   `GPUParticlesAttractorBox3D`: Зона влияния в виде параллелепипеда.
    *   `GPUParticlesAttractorSphere3D`: Сферическая зона влияния.
    *   `GPUParticlesAttractorVectorField3D`: Использует текстуру для определения направления силы в каждой точке поля.
*   **Настройка:** В `ParticleProcessMaterial` необходимо включить `Attractor Interaction -> Enabled`.

#### **4. Collisions (Столкновения)**
*   **Назначение:** Узлы, определяющие геометрию, с которой могут сталкиваться GPU-частицы.
*   **Типы:**
    *   `GPUParticlesCollisionBox3D`: Простой параллелепипед.
    *   `GPUParticlesCollisionSphere3D`: Сфера.
    *   `GPUParticlesCollisionHeightField3D`: Динамически создает карту высот из геометрии сцены. Идеально для ландшафтов.
    *   `GPUParticlesCollisionSDF3D`: Запекает геометрию в знаковое дистанционное поле (SDF). Наиболее точный и производительный, но статичный. Позволяет создавать туннели и навесы.
---

## **РАЗДЕЛ 7: ОКРУЖЕНИЕ И ПОСТОБРАБОТКА**

### **Глава 7.1: Ресурс Environment и CameraAttributes**

#### **1. Сущность**
*   **`Environment`**: Ресурс, который хранит всю информацию для управления рендерингом 2D и 3D сцен: фон (скайбокс), окружающий свет, туман, эффекты постобработки (Glow, SSAO) и тональную компрессию (Tonemap).
*   **`CameraAttributes`**: Ресурс, который хранит информацию, специфичную для камеры: экспозиция и глубина резкости (Depth of Field). В Godot 4 был выделен из `Environment` для большей гибкости.

#### **2. Приоритеты применения**
Настройки окружения применяются в следующем порядке приоритета (от высшего к низшему):
1.  **`Camera3D`**: `Environment`, назначенный напрямую камере, имеет наивысший приоритет.
2.  **`WorldEnvironment` узел**: Рекомендуемый способ. В сцене может быть только один активный `WorldEnvironment`. Его `Environment` становится окружением по умолчанию.
3.  **Preview Environment**: Встроенное в редактор окружение для предпросмотра, если в сцене нет `WorldEnvironment`. Не работает в запущенной игре.

### **Глава 7.2: Настройки Окружения (Environment)**

#### **1. Background (Фон)**
*   **`Mode`:** Определяет тип фона.
    *   **`Clear Color`:** Сплошной цвет.
    *   **`Custom Color`:** Сплошной цвет, но с возможностью настройки.
    *   **`Sky`:** Использует под-ресурс `SkyMaterial` для генерации неба.
*   **`SkyMaterial` (Материалы неба):**
    *   **`PanoramaSkyMaterial`:** Использует панорамную HDRI-текстуру.
    *   **`ProceduralSkyMaterial`:** Процедурно генерируемое небо с настраиваемым солнцем и горизонтом.
    *   **`PhysicalSkyMaterial`:** Физически корректное процедурное небо с более реалистичным рассеиванием света.

#### **2. Ambient Light (Окружающий свет)**
*   Добавляет базовый, равномерный свет ко всей сцене.
*   **`Mode`:**
    *   **`Background`:** Цвет окружающего света берется из фона (неба). Самый реалистичный вариант.
    *   **`Disabled` / `Color`:** Отключен или использует заданный сплошной цвет. Полезно для закрытых помещений или стилизации.

#### **3. Fog (Туман)**
*   **`Depth Fog` (Туман по глубине):** Плотность тумана зависит от расстояния до камеры.
*   **`Height Fog` (Туман по высоте):** Плотность зависит от высоты объекта в мире.
*   **`Transmit Enabled`:** Позволяет свету от `DirectionalLight3D` (солнца) проходить сквозь туман, окрашивая его.

#### **4. Tonemap (Тональная компрессия)**
*   Алгоритм, который преобразует HDR-цвета рендеринга в LDR-диапазон для отображения на мониторе.
*   **`Mode`:**
    *   **`Linear`:** Без преобразования, яркие цвета будут "выгорать".
    *   **`Reinhard`:** Простой и быстрый алгоритм.
    *   **`Filmic`:** Имитирует пленочную кривую, дает более кинематографичное изображение.
    *   **`ACES`:** Стандарт индустрии, дает высококонтрастное и реалистичное изображение.

### **Глава 7.3: Эффекты Постобработки (Post-Processing)**
*Все эффекты настраиваются в ресурсе `Environment`.*

*   **Screen-Space Reflections (SSR):** Создает отражения в реальном времени для объектов, которые находятся в поле зрения камеры. Работает только в **Forward+**.
*   **Screen-Space Ambient Occlusion (SSAO):** Добавляет мягкие тени в углах и на стыках геометрии, увеличивая глубину и реализм. Работает только в **Forward+**.
*   **Glow / Bloom:** Создает эффект свечения вокруг ярких областей изображения.
*   **Adjustments (Коррекция цвета):** Позволяет настраивать яркость, контраст, насыщенность и применять сложную цветокоррекцию через градиент или 3D LUT-текстуру.
*   **Depth of Field (DoF / Глубина резкости):** Размывает объекты, которые находятся не в фокусе камеры. Настраивается в ресурсе `CameraAttributes`.
*   **Auto Exposure:** Автоматически подстраивает яркость сцены, имитируя адаптацию человеческого глаза к свету. Настраивается в `CameraAttributes`, работает только в **Forward+**.

### **Глава 7.4: Объемный Туман (Volumetric Fog)**
*   **Принцип:** В отличие от стандартного тумана, объемный туман является полноценным 3D-эффектом. Он может взаимодействовать с источниками света, которые будут создавать видимые лучи ("god rays").
*   **Global Volumetric Fog (Глобальный):** Включается и настраивается в ресурсе `Environment`. Имеет глобальную плотность, цвет (альбедо) и эмиссию.
*   **`FogVolume` (Локальный):** Узел, позволяющий создавать локальные зоны с другой плотностью тумана. Может как добавлять плотность (положительное значение), так и вычитать ее из глобального тумана (отрицательное значение).
*   **Ограничения:** Очень требователен к ресурсам GPU, работает только в рендерере **Forward+**.

### **Глава 7.5: High Dynamic Range (HDR)**
*   **Концепция:** Рендеринг в расширенном динамическом диапазоне (HDR) позволяет движку оперировать значениями яркости, которые значительно превышают возможности стандартного монитора. Это необходимо для корректной работы свечения (Glow/Bloom) и физически корректного освещения.
*   **Процесс:**
    1.  Рендеринг сцены происходит в линейном цветовом пространстве с неограниченной яркостью (HDR).
    2.  Эффекты постобработки применяются к HDR-изображению.
    3.  `Tonemap` преобразует HDR-изображение в LDR-диапазон (0-1) для вывода на экран.
---

## **РАЗДЕЛ 8: ОПТИМИЗАЦИЯ 3D-РЕНДЕРИНГА**

### **Глава 8.1: Сглаживание (Antialiasing)**

#### **1. Концепция**
*   **Aliasing ("лесенка"):** Визуальный артефакт, проявляющийся в виде ступенчатых, зубчатых краев на границах полигонов, а также мерцания на тонких деталях и бликах.
*   **Antialiasing (Сглаживание):** Совокупность техник для борьбы с этим артефактом.

#### **2. Сравнение техник сглаживания**
| Техника | Качество | Производительность | Решает Specular Aliasing | Примечания |
| :--- | :--- | :--- | :--- | :--- |
| **MSAA** | Высокое | Высокая нагрузка | Нет | "Классический" метод, хорошо работает с краями геометрии. |
| **TAA** | Высокое | Средняя нагрузка | Да | Эффективен против всех видов aliasing, но может вызывать "гостинг" и размытие в движении. Только Forward+. |
| **FSR2** | Высокое | Средняя/Высокая нагрузка | Да | Апскейлинг + сглаживание. Может улучшить производительность или качество. Только Forward+. |
| **FXAA** | Среднее | Низкая нагрузка | Частично | Быстрый пост-эффект, размывает изображение. Хорош для слабых систем. |
| **SSAA** | Наивысшее | Экстремальная нагрузка | Да | Рендеринг в сверхвысоком разрешении с последующим уменьшением. Очень требователен. |

*   **Рекомендации:**
    *   **Фотореализм:** Начинайте с TAA. Если есть запас производительности, используйте FSR2 в режиме "Native" для лучшего качества.
    *   **Стилизованная графика/Соревновательные игры:** MSAA — хороший выбор, так как не размывает изображение.
    *   **Мобильные/Слабые ПК:** FXAA — практически единственный доступный вариант.

### **Глава 8.2: Оптимизация количества вызовов отрисовки**

#### **1. MultiMeshInstance3D**
*   **Назначение:** Отрисовка огромного количества одинаковых мешей (деревья, трава, камни) за один вызов отрисовки.
*   **Принцип:** Вместо тысяч отдельных узлов `MeshInstance3D` используется один узел `MultiMeshInstance3D`, который хранит только трансформации (позиция, вращение, масштаб) для каждого экземпляра и отправляет их на GPU одним пакетом.
*   **Настройка:** Требуется узел-цель (поверхность для размещения) и узел-источник (меш для копирования). Заполнение происходит через меню "MultiMesh" на панели инструментов.

#### **2. Visibility Ranges (HLOD - Hierarchical Level of Detail)**
*   **Назначение:** Ручная настройка уровней детализации, где один объект или группа объектов заменяются на более простую версию на расстоянии.
*   **Принцип:** Используется для замены не только мешей, но и любых узлов. Например, группа `MeshInstance3D` (детальный дом) на расстоянии заменяется одним `MeshInstance3D` (простой куб) или даже `Sprite3D` (импостор).
*   **Настройка:** Производится в Инспекторе, в секции `Visibility Range`.
    *   **`Begin` / `End`:** Дистанции, на которых объект становится видимым/невидимым.
    *   **`Begin Margin` / `End Margin`:** Дистанции для плавного перехода (фейда).
    *   **`Fade Mode`:** Режим перехода (`Disabled` - резкий, `Self` - плавное исчезновение, `Dependencies` - плавное исчезновение с учетом родителя).

#### **3. Occlusion Culling (Отсечение по преградам)**
*   **Назначение:** Предотвращение рендеринга объектов, которые полностью перекрыты другими непрозрачными объектами (например, в другой комнате за стеной).
*   **Принцип:** Движок "запекает" упрощенную геометрию сцены (`OccluderInstance3D`) и использует ее на CPU для быстрого определения, какие объекты видимы из текущей точки обзора.
*   **Настройка:**
    1.  Включить в `Настройках проекта -> Rendering -> Occlusion Culling`.
    2.  Добавить в сцену узел `OccluderInstance3D`.
    3.  На панели инструментов 3D-вьюпорта нажать "Bake Occluders".
*   **Ограничения:** Наиболее эффективен в сценах с четким разделением на зоны (комнаты, коридоры). Не работает с `MultiMeshInstance3D`, частицами и CSG (без предварительной конвертации в меш).

### **Глава 8.3: Оптимизация геометрии и шейдинга**

#### **1. Mesh Level of Detail (LOD)**
*   **Назначение:** Автоматическое снижение детализации меша по мере его удаления от камеры.
*   **Принцип:** Godot автоматически генерирует несколько версий меша с разным количеством полигонов при импорте модели. Движок сам выбирает, какую версию рендерить в зависимости от расстояния.
*   **Настройка:** Включается в настройках импорта для файлов glTF, Blend, FBX. Для OBJ нужно импортировать как сцену.
*   **Отличие от HLOD:** LOD работает только с одним мешем и автоматически. HLOD - ручной процесс, но позволяет заменять группы объектов и менять тип узла.

#### **2. Resolution Scaling (Масштабирование разрешения)**
*   Позволяет рендерить 3D-сцену в более низком разрешении, а затем масштабировать до разрешения окна. Значительно повышает производительность. Настраивается в `Настройках проекта -> Rendering -> Scaling 3D`.

#### **3. Variable Rate Shading (VRS)**
*   Технология, позволяющая снизить качество шейдинга для менее важных частей экрана (например, периферийное зрение, однотонные поверхности), сохраняя высокое качество в центре. Требует поддержки со стороны GPU. Настраивается в `Настройках проекта -> Rendering -> VRS`.
---

## **РАЗДЕЛ 8: ОПТИМИЗАЦИЯ 3D-РЕНДЕРИНГА (ПРОДОЛЖЕНИЕ)**

### **Глава 8.4: Масштабирование Рендеринга (Resolution Scaling)**

#### **1. Концепция**
*   **Масштабирование разрешения (Resolution Scaling):** Это техника, при которой 3D-сцена рендерится в разрешении, отличном от разрешения окна вывода, а затем масштабируется до нужного размера.
*   **Назначение:** Основная цель — повышение производительности за счет рендеринга в более низком разрешении (`Scale < 1.0`). Может также использоваться для повышения качества (Supersampling, `Scale > 1.0`).

#### **2. Режимы масштабирования**
*   **`Bilinear`:** Стандартная билинейная фильтрация. Самый быстрый, но дает размытое изображение при увеличении.
*   **`FSR 1.0`:** AMD FidelityFX Super Resolution 1.0. Алгоритм пространственного апскейлинга, который дает более четкое изображение, чем Bilinear, ценой небольшой дополнительной нагрузки на GPU.
*   **`FSR 2.2`:** AMD FidelityFX Super Resolution 2.2. Продвинутый алгоритм темпорального (временного) апскейлинга. Обеспечивает значительно более высокое качество изображения, приближенное к нативному, но требует больше ресурсов GPU. FSR 2.2 имеет собственное встроенное сглаживание, поэтому TAA отключается при его использовании.

#### **3. Настройка**
*   **`Rendering > Scaling 3D > Scale`:** Основной параметр в настройках проекта, от `0.0` до `2.0`.
*   **`Rendering > Scaling 3D > FSR Sharpness`:** Регулирует резкость для режимов FSR. Низкие значения делают изображение резче.
*   **Mipmap Bias:** При масштабе < 1.0 движок автоматически применяет отрицательное смещение для mipmap-уровней текстур, чтобы сохранить детализацию. Этим можно управлять вручную.

### **Глава 8.5: Variable Rate Shading (VRS)**

#### **1. Концепция**
*   **Variable Rate Shading (VRS):** Технология, позволяющая снизить частоту выполнения фрагментного шейдера для разных частей экрана. Это уменьшает стоимость рендеринга за счет снижения качества шейдинга в областях, где это менее заметно (например, на периферии для VR), при этом сохраняя геометрию четкой.

#### **2. Требования к оборудованию**
*   **Поддержка:** Требуется современный GPU (NVIDIA Turing+, AMD RDNA2+, Intel Arc+). Интегрированная графика Intel и мобильные GPU Apple/Raspberry Pi не поддерживают VRS.

#### **3. Настройка и использование**
*   **Включение:** `Настройки проекта -> Rendering -> VRS`.
*   **Режимы:**
    *   **`Disabled`:** Отключено.
    *   **`Texture`:** Плотность шейдинга управляется специальной текстурой (VRS Density Map). Полезно для foveated rendering в VR.
    *   **`XR`:** Плотность генерируется автоматически для VR-устройств.
*   **VRS Density Map:** Текстура, где цвет пикселя определяет качество шейдинга (от `rgb(0, 0, 0)` для максимального качества 1x1 до `rgb(255, 170, 0)` для минимального 8x8).

### **Глава 8.6: Инструменты для создания уровней в 3D**

#### **1. Prototyping with CSG (Конструктивная сплошная геометрия)**
*   **Назначение:** Быстрое прототипирование уровней ("грейбоксинг") прямо в редакторе Godot без использования внешнего 3D-моделировщика. **Не предназначено для финальной геометрии.**
*   **Принцип:** Основан на булевых операциях с примитивами.
*   **Ключевые узлы:**
    *   **Примитивы:** `CSGBox3D`, `CSGCylinder3D`, `CSGSphere3D`, и т.д.
    *   **`CSGCombiner3D`:** Узел-контейнер для организации и выполнения операций.
    *   **Операции:**
        *   **`Union` (Объединение):** Сливает геометрию дочерних узлов.
        *   **`Intersection` (Пересечение):** Оставляет только пересекающуюся геометрию.
        *   **`Subtraction` (Вычитание):** "Вырезает" геометрию одного узла из другого.
*   **Конвертация:** Готовую CSG-сцену можно (и нужно для производительности) конвертировать в `MeshInstance3D` через меню "CSG" в тулбаре 3D-вьюпорта.

#### **2. Using GridMaps (Сеточные карты)**
*   **Назначение:** Создание 3D-уровней из повторяющихся модульных мешей, аналогично `TileMap` в 2D.
*   **Принцип:** `GridMap` использует ресурс `MeshLibrary` для "рисования" мешами по 3D-сетке.
*   **`MeshLibrary`:** Ресурс-коллекция мешей. Создается из сцены, где каждый меш (`MeshInstance3D`) является корневым узлом отдельного "тайла". Мешам можно заранее назначить физические тела (`StaticBody3D`) и навигационные регионы (`NavigationRegion3D`).
*   **Использование:** После создания `MeshLibrary` узел `GridMap` предоставляет панель для выбора и размещения мешей по сетке.

#### **3. Third-person camera with SpringArm3D**
*   **Проблема:** Обычная камера, являющаяся дочерним узлом игрока, будет проходить сквозь стены.
*   **Решение:** Узел `SpringArm3D`.
*   **Принцип:** `SpringArm3D` действует как невидимая "палка для селфи". Камера (`Camera3D`) является дочерним узлом `SpringArm3D`. `SpringArm3D` постоянно проверяет (кастомным шейпом или рэйкастом) наличие препятствий между своей позицией и позицией камеры. Если препятствие найдено, он плавно придвигает камеру к точке столкновения, предотвращая проход сквозь геометрию.
---

## **РАЗДЕЛ 9: АНИМАЦИЯ (ANIMATIONPLAYER)**

### **Глава 9.1: Основы AnimationPlayer**

#### **1. Концепция**
*   **`AnimationPlayer`:** Мощный узел для создания сложных, основанных на временной шкале (timeline) анимаций. Может анимировать **любое свойство** любого узла, которое доступно в Инспекторе, а также вызывать методы.
*   **Ключевые кадры (Keyframes):** Анимация строится на ключевых кадрах. Ключевой кадр — это "снимок" значения свойства в определенный момент времени. Движок автоматически интерполирует (плавно изменяет) значение свойства между ключами.

#### **2. Панель Анимации**
*   **Timeline (Временная шкала):** Отображает время и расположение ключевых кадров.
*   **Tracks (Дорожки):** Список анимируемых свойств. Каждое свойство имеет свою дорожку.
*   **Animation Controls:** Кнопки для управления (воспроизведение, стоп, зацикливание) и настройки анимации (длительность, шаг привязки).
*   **Создание ключа:** Выберите узел, измените свойство в Инспекторе и нажмите на иконку ключа рядом со свойством.

### **Глава 9.2: Продвинутые Функции**

#### **1. Редактирование и Настройка**
*   **RESET-анимация:** Специальная анимация с именем "RESET" (регистрозависимо), которая хранит "позу по умолчанию" для объекта. Она автоматически применяется при старте игры (если включено `Reset On Save`), чтобы гарантировать, что объект находится в правильном состоянии перед началом других анимаций.
*   **Onion Skinning ("Калька"):** Позволяет видеть полупрозрачные "призраки" объекта из предыдущих и последующих кадров, что упрощает создание плавной анимации.
*   **Animation Markers (Маркеры):** Позволяют именовать определенные участки временной шкалы и воспроизводить только их с помощью `play_section()`.

#### **2. Настройки Дорожек (Track Settings)**
*   **Update Mode (Режим обновления):**
    *   **`Continuous`:** Свойство обновляется на каждом кадре (стандартно).
    *   **`Discrete`:** Свойство меняется скачком только в момент ключевого кадра.
    *   **`Capture`:** Захватывает текущее значение свойства и плавно переходит от него к первому ключу. Полезно для динамических переходов.
*   **Interpolation (Интерполяция):**
    *   **`Nearest`:** Без интерполяции.
    *   **`Linear`:** Линейная интерполяция (постоянная скорость).
    *   **`Cubic`:** Кубическая интерполяция (с ускорением и замедлением).
*   **Loop Mode (Режим зацикливания):**
    *   **`None`:** Анимация останавливается в конце.
    *   **`Linear`:** Анимация повторяется с начала.
    *   **`Ping-Pong`:** Анимация проигрывается вперед, а затем назад.

### **Глава 9.3: Типы Дорожек (Track Types)**
`AnimationPlayer` поддерживает различные типы дорожек для специальных задач:

*   **`Property Track`:** Стандартная дорожка для анимации любого свойства.
*   **`3D Position/Rotation/Scale Track`:** Оптимизированные дорожки для анимации трансформаций 3D-объектов. Могут сжимать данные, что полезно для анимаций, импортированных извне.
*   **`Blend Shape Track`:** Для анимации морфинга (blend shapes) у `MeshInstance3D`.
*   **`Call Method Track`:** Позволяет вызвать метод любого узла в определенный момент времени. Ключевой кадр на этой дорожке хранит имя метода и его аргументы. Используется для синхронизации событий с анимацией (например, звук шага в момент касания ногой земли, вызов `queue_free()` в конце анимации смерти).
*   **`Bezier Curve Track`:** Позволяет анимировать float-свойство с помощью кривой Безье, давая полный контроль над кривой изменения значения.
*   **`Audio Playback Track`:** Для проигрывания звука из узла `AudioStreamPlayer`. Ключевой кадр на дорожке запускает воспроизведение.
*   **`Animation Playback Track`:** Позволяет управлять другим `AnimationPlayer` из текущей анимации. Используется для создания сложных последовательностей и кат-сцен.
---

## **РАЗДЕЛ 9: АНИМАЦИЯ (ANIMATIONPLAYER) (ПРОДОЛЖЕНИЕ)**

### **Глава 9.4: 2D Скелетная Анимация**

#### **1. Cutout Animation (Перекладная анимация)**
*   **Концепция:** Техника, при которой персонаж составляется из отдельных спрайтов (частей тела), которые затем анимируются путем изменения их трансформаций (вращение, перемещение). Это имитирует традиционную бумажную перекладную анимацию.
*   **Создание рига (Rig):**
    1.  **Иерархия:** Части тела выстраиваются в иерархию "родитель-потомок" (например, `Кисть` -> `Предплечье` -> `Плечо`). Корнем скелета обычно является таз (`hip`).
    2.  **Точка вращения (Pivot):** Для каждого спрайта (`Sprite2D`) необходимо правильно выставить точку вращения, смещая свойство `Offset`. Это критически важно для корректных сгибов в "суставах".
    3.  **Порядок отрисовки:** Для управления тем, какая часть тела находится "спереди", а какая "сзади", используется либо `z_index`, либо свойство `Show Behind Parent`, либо узел `RemoteTransform2D` для разрыва иерархии отрисовки при сохранении иерархии трансформаций.
*   **Скелеты (`Skeleton2D`):**
    *   **Назначение:** Для упрощения анимации сложных ригов и использования инверсной кинематики (IK).
    *   **Процесс:** Поверх иерархии спрайтов создается иерархия узлов `Bone2D` (костей). Затем через меню `Skeleton` кости "привязываются" к узлам спрайтов.
*   **Инверсная кинематика (IK Chain):**
    *   **Назначение:** Позволяет анимировать конечности, двигая только конечную точку (например, кисть или стопу), в то время как остальные части цепи (предплечье, плечо) подстраиваются автоматически.
    *   **Ограничение:** В Godot IK-цепи работают **только в редакторе** для упрощения расстановки ключевых кадров и **не работают в рантайме** для процедурной анимации.

#### **2. Skeletal Deform (Скелетная деформация)**
*   **Концепция:** Вместо набора отдельных спрайтов используется одно цельное изображение персонажа, которое деформируется с помощью скелета (`Skeleton2D` и `Bone2D`).
*   **Процесс:**
    1.  **Создание полигона:** С помощью `Polygon2D` создается полигон, повторяющий контур персонажа на текстуре.
    2.  **Создание скелета:** Создается иерархия узлов `Bone2D`.
    3.  **Привязка:** `Polygon2D` привязывается к `Skeleton2D`.
    4.  **Раскраска весов (Weight Painting):** В UV-редакторе для `Polygon2D` каждая вершина полигона "раскрашивается", чтобы определить, какая кость и с какой силой на нее влияет.
    5.  **Внутренние вершины:** Для более качественных и естественных сгибов в полигон добавляются внутренние вершины в местах предполагаемых деформаций.
*   **Преимущества:** Позволяет создавать плавные, органичные деформации, которые невозможны в перекладной анимации.

### **Глава 9.5: AnimationTree (Дерево Анимаций)**

*   **Назначение:** `AnimationTree` — это узел для продвинутого управления анимациями из `AnimationPlayer`. Он позволяет смешивать (blending) несколько анимаций, создавать сложные переходы и управлять ими через конечный автомат (State Machine).
*   **Принцип:** `AnimationTree` не содержит анимаций. Он подключается к `AnimationPlayer` и использует его анимации как "сырье". Внутри `AnimationTree` строится граф (дерево) из специальных нод, которые обрабатывают и смешивают эти анимации.

#### **1. Ключевые ноды AnimationTree:**
*   **`AnimationNodeAnimation`:** Просто проигрывает одну анимацию из `AnimationPlayer`.
*   **`AnimationNodeBlend2` / `Blend3`:** Смешивает 2 или 3 анимации на основе одного float-параметра.
*   **`AnimationNodeBlendSpace1D` / `BlendSpace2D`:** Продвинутое смешивание на 1D или 2D-пространстве. Позволяет создать плавные переходы между множеством анимаций (например, `idle` -> `walk` -> `run` на 1D-пространстве, или смешивание ходьбы в 8 направлениях на 2D).
*   **`AnimationNodeStateMachine` (Конечный автомат):** Позволяет создавать состояния (например, "Idle", "Walk", "Jump") и настраивать правила перехода между ними (`Immediate`, `Sync`, `At End`). Это стандартный подход для управления анимациями персонажа.
*   **`AnimationNodeOneShot`:** Проигрывает одну анимацию (например, выстрел, уворот) поверх текущего состояния и затем возвращается к нему.
*   **`AnimationNodeTransition`:** Простой переключатель между анимациями.

#### **2. Управление из кода**
*   Управление `AnimationTree` происходит через установку его параметров:
    ```gdscript
    # Установить значение для Blend2
    animation_tree["parameters/my_blend_node/blend_amount"] = 0.5
    # Переключить состояние в StateMachine
    var state_machine = animation_tree["parameters/playback"]
    state_machine.travel("jump_state")
    ```

#### **3. Root Motion (Движение корня)**
*   **Концепция:** Техника, при которой движение персонажа в мире (`CharacterBody3D`) управляется не кодом, а смещением корневой кости в самой анимации.
*   **Настройка:** В `AnimationTree` указывается путь к корневой кости (`Root Motion Track`).
*   **Применение:** В коде из `AnimationTree` извлекается дельта трансформации корневой кости (`get_root_motion_...()`) и применяется к `CharacterBody3D` через `move_and_slide()`.

---

## **РАЗДЕЛ 10: ВОСПРОИЗВЕДЕНИЕ ВИДЕО**

### **Глава 10.1: Основы VideoStreamPlayer**

*   **Узел:** Для воспроизведения видео используется `VideoStreamPlayer`.
*   **Поддерживаемый формат:** Встроенная поддержка в Godot есть только для формата **Ogg Theora** (`.ogv`). Другие форматы (H.264, H.265, AV1) требуют расширений (GDExtensions). WebM был удален в Godot 4.
*   **Воспроизведение:** Запускается либо галочкой `Autoplay` в инспекторе, либо вызовом метода `play()` из скрипта.
*   **Ограничения:**
    *   Декодирование происходит на CPU. Высокое разрешение (1440p+) может тормозить на слабых процессорах.
    *   Перемотка на конкретный момент времени не поддерживается.
    *   Скорость воспроизведения изменить нельзя.
    *   Поддерживается только моно или стерео аудио.

### **Глава 10.2: Практические Аспекты**

*   **Адаптация под размер окна:** Чтобы видео сохраняло пропорции, `VideoStreamPlayer` следует поместить внутрь контейнера `AspectRatioContainer`.
*   **Отображение на 3D-поверхности:**
    1.  Создается `SubViewport`.
    2.  `VideoStreamPlayer` добавляется как дочерний к `SubViewport`.
    3.  На `MeshInstance3D` создается `StandardMaterial3D`.
    4.  В свойство `Albedo > Texture` материала назначается `New ViewportTexture`, которому указывается путь к `SubViewport`.
*   **Chroma Key (Зеленый экран):** Удаление фона определенного цвета из видео реализуется с помощью кастомного шейдера, примененного к `VideoStreamPlayer`.
*   **Кодирование:** Рекомендуется использовать внешний кодировщик (например, **FFmpeg**) для конвертации видео в формат Ogg Theora, так как встроенные в другие программы экспортеры могут быть некачественными.
---

## **РАЗДЕЛ 11: КОНВЕЙЕР АССЕТОВ (ASSETS PIPELINE)**

### **Глава 11.1: Процесс Импорта**

#### **1. Основы**
*   **Процесс:** Когда вы добавляете внешний ассет (например, `.png`, `.fbx`, `.wav`) в папку проекта, Godot автоматически **импортирует** его. Это означает, что он создает внутреннюю, оптимизированную для движка версию этого ассета в скрытой папке `.godot/imported/`. Оригинальный файл при этом не изменяется.
*   **Файлы `.import`:** Рядом с каждым импортированным ассетом создается текстовый файл с тем же именем и расширением `.import`. В нем хранятся все настройки импорта для данного ассета. **Эти файлы необходимо добавлять в систему контроля версий (Git).**
*   **Доступ в коде:** Используйте `ResourceLoader` (или `load`/`preload`), чтобы обращаться к ассетам по их пути в `res://`. Движок автоматически подменит путь на внутренний импортированный файл. Прямой доступ через `FileAccess` к `res://` путям сломает экспорт.

#### **2. Настройка импорта**
*   **Панель "Import":** Когда вы выбираете внешний ассет в доке "FileSystem", в левой верхней панели появляется вкладка "Import", где можно изменить все параметры импорта. После изменения параметров необходимо нажать кнопку **"Reimport"**.
*   **Множественный реимпорт:** Можно выделить несколько ассетов одного типа, чтобы изменить общие для них параметры импорта и переимпортировать их все разом.
*   **Предустановки (Presets):** Можно сохранить набор настроек импорта как пресет и применять его к другим ассетам.
*   **Настройки по умолчанию:** В `Проект -> Настройки проекта... -> Import Defaults` можно задать параметры импорта по умолчанию для каждого типа ресурсов.

### **Глава 11.2: Импорт Изображений**

*   **Поддерживаемые форматы:** PNG, JPG, SVG (растеризуется при импорте), WebP, BMP, TGA, EXR, HDR, DDS, KTX.
*   **Режимы импорта (`Import As`):**
    *   **`Texture2D`:** Стандартный режим для 2D и 3D текстур.
    *   **`Image`:** Импортирует как ресурс `Image`, позволяя прямой доступ к пиксельным данным, но без оптимизаций для GPU.
    *   **`Cubemap` / `CubemapArray`:** Для скайбоксов и карт отражений.
    *   **`Texture2DArray`:** Массив 2D-текстур.
    *   **`TextureAtlas`:** Для 2D-анимации (`AnimatedSprite2D`).

#### **1. Сжатие (Compress Mode)**
| Режим | Описание | VRAM | Диск | Качество | Производительность |
| :--- | :--- | :--- | :--- | :--- | :--- |
| **Lossless** | Сжатие без потерь (WebP). | Большой | Маленький | Отличное | Нормальная |
| **Lossy** | Сжатие с потерями (WebP). | Большой | Очень мал. | Хорошее | Нормальная |
| **VRAM Compressed** | **(Рекомендуется для 3D)**. Формат, оптимизированный для GPU (S3TC/ETC2). | **Маленький** | Маленький | Среднее | **Высокая** |
| **VRAM Uncompressed** | Без сжатия VRAM. | Огромный | Большой | Отличное | Нормальная |
| **Basis Universal** | Универсальный формат сжатия для GPU. | **Маленький** | Очень мал. | Среднее | **Высокая** |

#### **2. Ключевые опции**
*   **`Mipmaps -> Generate`:** Создает уменьшенные копии текстуры для отображения на расстоянии. **Обязательно для 3D**, чтобы избежать зернистости. Увеличивает использование памяти на ~33%.
*   **`Roughness -> Mode`:** Позволяет использовать один из каналов (R, G, B, A, Gray) текстуры как карту шероховатости для PBR-материалов.
*   **`Process -> Normal Map Invert Y`:** Необходимо включать для карт нормалей, созданных в DirectX-совместимых программах (в Godot используется OpenGL-стандарт).
*   **`Compress -> Normal Map (RGTC)`:** Специальный режим сжатия для карт нормалей, который дает значительно лучшее качество, чем стандартный VRAM.

### **Глава 11.3: Импорт Аудио**

*   **Поддерживаемые форматы:**
    *   **WAV:** Без сжатия или с легким сжатием (IMA-ADPCM). Низкая нагрузка на CPU. **Рекомендуется для коротких звуковых эффектов (SFX).**
    *   **Ogg Vorbis:** Сжатие с потерями. Меньший размер файла, но выше нагрузка на CPU. **Рекомендуется для музыки и речи.**
    *   **MP3:** Сжатие с потерями. Менее эффективен, чем Ogg Vorbis (больше размер файла при том же качестве), но требует меньше ресурсов CPU для воспроизведения.
*   **Ключевые опции (WAV):**
    *   **`Edit -> Trim`:** Автоматически обрезает тишину в начале и конце файла.
    *   **`Edit -> Normalize`:** Увеличивает громкость до 0 dB.
    *   **`Loop Mode`:** Устанавливает режим зацикливания (`Disabled`, `Forward`, `Ping-Pong`, `Backward`).
    *   **`Compress -> Mode`:** Позволяет сжать WAV в формат IMA-ADPCM для уменьшения размера в памяти.
*   **Ключевые опции (Ogg/MP3):**
    *   **`Loop`:** Включает зацикливание.
    *   **`BPM`, `Beat Count`, `Bar Beats`:** Параметры для интерактивной музыки (например, в ритм-играх).
*   **Лучшие практики:**
    *   Импортируйте звуковые эффекты "сухими" (без реверберации) и добавляйте эффекты в реальном времени через шины `Audio Bus` в Godot. Это значительно экономит место.
---

## **РАЗДЕЛ 12: ФАЙЛЫ, СОХРАНЕНИЯ И ЭКСПОРТ**

### **Глава 12.1: Работа с Файловой Системой**

#### **1. Пути в Godot**
*   **Разделители:** Godot всегда использует **прямой слеш (`/`)** в качестве разделителя путей на всех платформах для единообразия.
*   **`res://`:** Путь к **папке проекта**. Доступен для чтения. В экспортированной игре эта папка становится частью виртуальной файловой системы (внутри PCK-файла).
*   **`user://`:** Путь к **папке данных пользователя**. Гарантированно доступен для записи. Используется для сохранения настроек, сохранений игр и т.д. Расположение зависит от ОС (например, `%APPDATA%\Godot\app_userdata\[project_name]` на Windows).
*   **Преобразование путей:**
    *   `ProjectSettings.globalize_path("res://...")` преобразует локальный путь в абсолютный системный.
    *   `ProjectSettings.localize_path("C:/...")` преобразует абсолютный системный путь в локальный.

#### **2. Загрузка и Сохранение в Рантайме**
*   **Назначение:** Для загрузки пользовательского контента (моды, кастомные текстуры, уровни) или файлов, не являющихся частью проекта. **Не используйте этот метод для загрузки ресурсов, которые являются частью проекта**, так как это менее эффективно и не использует преимущества системы импорта.
*   **Классы:**
    *   **`FileAccess`:** Для чтения и записи текстовых и бинарных файлов.
    *   **`Image.load_from_file(path)`:** Для загрузки изображений.
    *   **`AudioStreamOggVorbis.load_from_file(path)`:** Для загрузки аудио.
    *   **`GLTFDocument`:** Для загрузки/сохранения 3D-сцен в формате `.gltf` или `.glb`.
    *   **`ZIPReader` / `ZIPPacker`:** Для работы с ZIP-архивами.

#### **3. Фоновая загрузка (Background Loading)**
*   **Проблема:** Обычный `load()` блокирует основной поток, что приводит к "зависанию" игры во время загрузки.
*   **Решение:** `ResourceLoader`.
*   **Процесс:**
    1.  Запросить загрузку ресурса в фоновом потоке: `ResourceLoader.load_threaded_request(path)`.
    2.  (Опционально) Проверять статус загрузки: `ResourceLoader.load_threaded_get_status(path, progress_array)`.
    3.  Получить загруженный ресурс, когда он будет готов: `var resource = ResourceLoader.load_threaded_get(path)`.

### **Глава 12.2: Сохранение Игр**

#### **1. JSON vs. Бинарная Сериализация**
*   **JSON:**
    *   **Преимущества:** Человеко-читаемый формат, легко отлаживать.
    *   **Недостатки:** Больший размер файла, не поддерживает все типы данных Godot (например, `Vector2`), требует ручного кодирования/декодирования.
*   **Бинарная сериализация:**
    *   **Преимущества:** Компактный размер, поддерживает большинство типов данных Godot, не требует ручного кодирования.
    *   **Недостатки:** Не читаем человеком.
    *   **API:** `FileAccess.store_var()` и `FileAccess.get_var()`, или глобальные `var_to_bytes()` и `bytes_to_var()`.

#### **2. Паттерн сохранения**
1.  **Идентификация:** Объекты, которые нужно сохранить, добавляются в группу (например, "Persist").
2.  **Сериализация:** Каждый объект в группе имеет метод `save()`, который возвращает словарь с его состоянием.
3.  **Сохранение на диск:** Главный скрипт сохранения собирает словари со всех объектов, сериализует их (например, в JSON-строку) и записывает в файл в `user://` с помощью `FileAccess`.
4.  **Загрузка:** Скрипт читает файл, парсит данные, удаляет старые объекты из группы "Persist", создает новые (`load(path).instantiate()`) и восстанавливает их состояние из загруженных данных.

### **Глава 12.3: Экспорт Проектов**

#### **1. Процесс Экспорта**
*   **Экспортные шаблоны:** Для каждой платформы (Windows, Linux, Web и т.д.) требуются свои **экспортные шаблоны**. Их можно скачать через меню `Редактор -> Управление экспортными шаблонами`.
*   **Пресеты экспорта:** В меню `Проект -> Экспорт...` создается пресет для каждой целевой платформы. В нем настраиваются иконки, версия, права, ресурсы для включения и т.д.
*   **Форматы пакетов:**
    *   **PCK (рекомендуется):** Несжатый. Больший размер, но быстрее чтение/запись.
    *   **ZIP:** Сжатый. Меньший размер, но медленнее чтение/запись.

#### **2. DLC, Патчи и Моды (PCK-файлы)**
*   **Концепция:** Godot позволяет упаковывать ресурсы в отдельные `.pck` файлы и загружать их в рантайме. Это основной механизм для создания DLC, патчей и поддержки модов.
*   **Загрузка PCK:**
    ```gdscript
    ProjectSettings.load_resource_pack("res://mods/my_mod.pck")
    ```
    После этого все ресурсы из `my_mod.pck` становятся доступны, как если бы они были частью игры.

#### **3. Feature Tags (Теги Функций)**
*   **Назначение:** Механизм для адаптации проекта под разные платформы и конфигурации сборки. Тег — это строка, определяющая наличие какой-либо функции (например, `windows`, `mobile`, `release`, `etc2`).
*   **Использование:**
    *   **В коде:** `OS.has_feature("feature_name")` позволяет выполнять разный код для разных платформ.
    *   **Переопределение настроек проекта:** В `Настройках проекта` можно переопределить любой параметр для конкретного тега (например, установить разное сжатие текстур по умолчанию для `mobile`).
    *   **В пресетах экспорта:** Можно задать кастомные теги для создания разных версий сборки (например, `demo_build`).
---

## **РАЗДЕЛ 13: ПРОДВИНУТАЯ ОБРАБОТКА ВВОДА И МАТЕМАТИКА**

### **Глава 13.1: Поток Событий Ввода**

*   **События vs. Опрос:**
    *   **События (Events):** `_input()`, `_unhandled_input()`. Реагируют на дискретные действия (нажатие кнопки, клик мыши).
    *   **Опрос (Polling):** `Input.is_action_pressed()`. Проверяет состояние в каждом кадре. Используется для непрерывных действий (движение).
*   **Жизненный цикл `InputEvent`:** Событие от ОС проходит через длинную цепочку обработки, прежде чем достигнет игровых скриптов:
    1.  **`DisplayServer`** получает событие от ОС.
    2.  **`Viewport`** обрабатывает его.
    3.  **`_input()`:** Первым вызывается у узлов. Если какой-либо узел "потребляет" событие (`get_viewport().set_input_as_handled()`), цепочка прерывается.
    4.  **`_gui_input()`:** События мыши и касаний передаются `Control`-узлам.
    5.  **`_unhandled_input()`:** Вызывается для событий, которые не были обработаны ни в `_input()`, ни в GUI. Идеальное место для общей игровой логики.
    6.  **`_unhandled_key_input()`:** То же самое, но только для событий клавиатуры.
*   **Распространение:** События "всплывают" по дереву сцены от низших узлов к высшим (обратный порядок отрисовки).

### **Глава 13.2: Контроллеры и Геймпады**

*   **Абстракция:** Благодаря `InputMap`, действия (`move_left`, `jump`) можно назначать как на клавиатуру, так и на геймпад, используя один и тот же код `Input.is_action_pressed()`.
*   **Аналоговый ввод:**
    *   **`Input.get_vector()`:** Лучший способ для получения направления с двух осей (джойстик, WASD), так как он корректно обрабатывает мертвую зону (deadzone).
    *   **`Input.get_axis()`:** Для одной оси (например, газ/тормоз на триггерах).
*   **Вибрация (Haptic Feedback):**
    *   `Input.start_joy_vibration(device_id, weak_magnitude, strong_magnitude, duration)`
    *   `Input.stop_joy_vibration(device_id)`
*   **Особенности:**
    *   **"Эхо" событий:** Удержание кнопки геймпада не генерирует повторяющиеся события, в отличие от клавиатуры.
    *   **Фокус окна:** Геймпад может посылать события, даже если окно игры не в фокусе. Это можно контролировать, проверяя уведомления `NOTIFICATION_APPLICATION_FOCUS_IN` и `NOTIFICATION_APPLICATION_FOCUS_OUT`.

### **Глава 13.3: Координаты Мыши и Курсор**
*   **Системы координат:** `event.position` в `_input()` возвращает координаты мыши в системе координат **вьюпорта**, а не окна.
*   **Захват мыши (`Input.MOUSE_MODE_CAPTURED`):** В этом режиме курсор скрыт и заблокирован в центре окна. Для получения смещения мыши следует использовать `event.relative`.
*   **Кастомизация курсора:**
    *   **Простой способ:** `Настройки проекта -> Display -> Mouse Cursor`.
    *   **Через код:** `Input.set_custom_mouse_cursor(image, hotspot)`. Позволяет менять курсор динамически.

### **Глава 13.4: Обработка Запросов на Закрытие**
*   **Уведомление:** Когда пользователь пытается закрыть окно (нажатием на "крестик"), всем узлам в дереве сцены отправляется уведомление `NOTIFICATION_WM_CLOSE_REQUEST`.
*   **Перехват:** По умолчанию игра закрывается. Чтобы перехватить это событие (например, для показа диалога "Вы уверены?"), нужно:
    1.  Отключить автоматическое закрытие: `get_tree().auto_accept_quit = false`.
    2.  Обработать уведомление в скрипте:
        ```gdscript
        func _notification(what):
            if what == NOTIFICATION_WM_CLOSE_REQUEST:
                # Показать диалог подтверждения
                # Если пользователь подтвердил, вызвать get_tree().quit()
        ```

### **Глава 13.5: Векторная Математика**

*   **Вектор:** Представляет направление и величину (длину). Не имеет позиции.
*   **Операции:** Сложение, вычитание, умножение/деление на скаляр (число).
*   **Применение:**
    *   **Движение:** `new_position = old_position + velocity * delta`.
    *   **Направление:** `vector_to_target = target_position - current_position`.
*   **Единичный вектор (Unit Vector):** Вектор с длиной `1`. Используется для представления чистого направления. Получается **нормализацией** (`vector.normalized()`).
*   **Скалярное произведение (Dot Product): `dot_product = a.dot(b)`**
    *   **Результат:** Скаляр (число).
    *   **Интерпретация:** Показывает, насколько векторы "смотрят" в одном направлении.
        *   `> 0`: Угол < 90°.
        *   `= 0`: Угол = 90° (перпендикулярны).
        *   `< 0`: Угол > 90°.
    *   **Применение:** Проверка, находится ли враг в поле зрения.
*   **Векторное произведение (Cross Product): `cross_product = a.cross(b)` (только в 3D)**
    *   **Результат:** Вектор, перпендикулярный обоим исходным векторам.
    *   **Применение:** Вычисление нормали поверхности по трем точкам.

### **Глава 13.6: Продвинутая Векторная Математика (Плоскости)**
*   **Плоскость (Plane):** Бесконечная поверхность, которая делит 3D-пространство на два полупространства (положительное и отрицательное).
*   **Определение:** Задается нормалью (единичным вектором `N`) и расстоянием от начала координат (`D`).
*   **Применение:**
    *   **Определение расстояния до точки:** `distance = plane.distance_to(point)`. Знак результата показывает, с какой стороны от плоскости находится точка.
    *   **Проверка принадлежности к объему:** Если точка имеет отрицательное расстояние до всех плоскостей, образующих выпуклый многогранник, значит, она находится внутри него.
    *   **Обнаружение столкновений (SAT):** Теорема о разделяющей оси, используемая в физических движках, основана на поиске плоскости, разделяющей два выпуклых объекта.
---

## **РАЗДЕЛ 14: АУДИО И ЛОКАЛИЗАЦИЯ**

### **Глава 14.1: Продвинутые Аудио-функции**

*   **Синхронизация с геймплеем:**
    *   **Проблема:** Существует задержка между вызовом `play()` и реальным началом воспроизведения звука.
    *   **Решение:** Для точной синхронизации (например, в ритм-играх) необходимо учитывать эту задержку, получая ее от аудио-сервера: `AudioServer.get_time_to_next_mix() + AudioServer.get_output_latency()`.
    *   Для получения точной текущей позиции воспроизведения используйте: `player.get_playback_position() + AudioServer.get_time_since_last_mix() - AudioServer.get_output_latency()`.
*   **Text to Speech (TTS):**
    *   **Назначение:** Преобразование текста в речь с помощью системных библиотек ОС.
    *   **Включение:** `Настройки проекта -> Audio -> General -> Enable Text to Speech`.
    *   **Использование:** `DisplayServer.tts_speak("Hello, world!")`. Вызов асинхронный.

### **Глава 14.2: Интернационализация (i18n)**

*   **Концепция:** Процесс адаптации игры для разных языков и культурных особенностей.
*   **Форматы переводов:**
    *   **CSV:** Простой формат. Каждая строка: `ключ, перевод_en, перевод_es, ...`.
    *   **gettext (`.po`, `.mo`):** Стандарт индустрии. Более мощный, поддерживает контексты и формы множественного числа.
*   **Процесс:**
    1.  **Настройка:** В `Настройках проекта -> Localization` добавляются файлы с переводами (например, `.csv` или `.po`).
    2.  **Использование в коде:** Текст оборачивается в функцию `tr("KEY_TO_TRANSLATE")`.
    3.  **Автоматический перевод:** Для `Control`-узлов (Label, Button) можно просто вписать ключ в поле `text`, и он будет переведен автоматически.
    4.  **Плюрализация (Множественное число):** `tr("FOUND_%d_APPLES", "FOUND_%d_APPLE", number) % number`.
    5.  **Контекст:** `trc("As in 'close the door'", "Close")`.
*   **Локализация ресурсов:** В `Настройках проекта -> Localization -> Remaps` можно настроить замену одних ресурсов другими в зависимости от текущего языка (например, заменять текстуры с английским текстом на текстуры с испанским).
*   **Тестирование:** В `Настройках проекта -> Internationalization -> Locale` можно задать язык для тестового запуска игры. **Псевдолокализация** (`pseudolocalization`) заменяет текст на похожие, но измененные символы, чтобы быстро найти непереведенные строки и проверить верстку.
*   **Поддержка RTL:** Godot автоматически обрабатывает языки с письмом справа налево (арабский, иврит), "отзеркаливая" элементы UI.

## **РАЗДЕЛ 15: СПЕЦИФИКАЦИИ**

### **Глава 15.1: Бинарная Сериализация (API)**

*   **Назначение:** Низкоуровневый формат, который Godot использует для сетевой передачи данных и в функциях `store_var`/`get_var`. Основан на преобразовании `Variant` в массив байтов.
*   **Спецификация пакета:** Каждый пакет данных имеет 4-байтовый заголовок, который содержит тип данных и флаги (например, `ENCODE_FLAG_64` для 64-битной точности). Далее следуют сами данные, выровненные по 4 байта.
*   **Сериализация объектов:**
    *   **`full_objects = false` (по умолчанию):** Сериализуется только `ObjectID`.
    *   **`full_objects = true`:** Сериализуется рекурсивно весь объект с его свойствами (только те, что имеют флаг `PROPERTY_USAGE_STORAGE`).
---

## **РАЗДЕЛ 11: КОНВЕЙЕР АССЕТОВ, ФАЙЛЫ И СОХРАНЕНИЯ**

### **Глава 11.1: Процесс Импорта**

#### **1. Основы**
*   **Процесс:** Когда вы добавляете внешний ассет (например, `.png`, `.fbx`, `.wav`) в папку проекта, Godot автоматически **импортирует** его. Это означает, что он создает внутреннюю, оптимизированную для движка версию этого ассета в скрытой папке `.godot/imported/`. Оригинальный файл при этом не изменяется.
*   **Файлы `.import`:** Рядом с каждым импортированным ассетом создается текстовый файл с тем же именем и расширением `.import`. В нем хранятся все настройки импорта для данного ассета. **Эти файлы необходимо добавлять в систему контроля версий (Git).**
*   **Доступ в коде:** Используйте `ResourceLoader` (или `load`/`preload`), чтобы обращаться к ассетам по их пути в `res://`. Движок автоматически подменит путь на внутренний импортированный файл. Прямой доступ через `FileAccess` к `res://` путям сломает экспорт.

#### **2. Настройка импорта**
*   **Панель "Import":** Когда вы выбираете внешний ассет в доке "FileSystem", в левой верхней панели появляется вкладка "Import", где можно изменить все параметры импорта. После изменения параметров необходимо нажать кнопку **"Reimport"**.
*   **Множественный реимпорт:** Можно выделить несколько ассетов одного типа, чтобы изменить общие для них параметры импорта и переимпортировать их все разом.
*   **Предустановки (Presets):** Можно сохранить набор настроек импорта как пресет и применять его к другим ассетам.
*   **Настройки по умолчанию:** В `Проект -> Настройки проекта... -> Import Defaults` можно задать параметры импорта по умолчанию для каждого типа ресурсов.

### **Глава 11.2: Импорт Изображений**

*   **Поддерживаемые форматы:** PNG, JPG, SVG (растеризуется при импорте), WebP, BMP, TGA, EXR, HDR, DDS, KTX.
*   **Режимы импорта (`Import As`):**
    *   **`Texture2D`:** Стандартный режим для 2D и 3D текстур.
    *   **`Image`:** Импортирует как ресурс `Image`, позволяя прямой доступ к пиксельным данным, но без оптимизаций для GPU.
    *   **`Cubemap` / `CubemapArray`:** Для скайбоксов и карт отражений.
    *   **`Texture2DArray`:** Массив 2D-текстур.
    *   **`TextureAtlas`:** Для 2D-анимации (`AnimatedSprite2D`).

#### **1. Сжатие (Compress Mode)**
| Режим | Описание | VRAM | Диск | Качество | Производительность |
| :--- | :--- | :--- | :--- | :--- | :--- |
| **Lossless** | Сжатие без потерь (WebP). | Большой | Маленький | Отличное | Нормальная |
| **Lossy** | Сжатие с потерями (WebP). | Большой | Очень мал. | Хорошее | Нормальная |
| **VRAM Compressed** | **(Рекомендуется для 3D)**. Формат, оптимизированный для GPU (S3TC/ETC2). | **Маленький** | Маленький | Среднее | **Высокая** |
| **VRAM Uncompressed** | Без сжатия VRAM. | Огромный | Большой | Отличное | Нормальная |
| **Basis Universal** | Универсальный формат сжатия для GPU. | **Маленький** | Очень мал. | Среднее | **Высокая** |

#### **2. Ключевые опции**
*   **`Mipmaps -> Generate`:** Создает уменьшенные копии текстуры для отображения на расстоянии. **Обязательно для 3D**, чтобы избежать зернистости. Увеличивает использование памяти на ~33%.
*   **`Roughness -> Mode`:** Позволяет использовать один из каналов (R, G, B, A, Gray) текстуры как карту шероховатости для PBR-материалов.
*   **`Process -> Normal Map Invert Y`:** Необходимо включать для карт нормалей, созданных в DirectX-совместимых программах (в Godot используется OpenGL-стандарт).
*   **`Compress -> Normal Map (RGTC)`:** Специальный режим сжатия для карт нормалей, который дает значительно лучшее качество, чем стандартный VRAM.

### **Глава 11.3: Импорт Аудио**

*   **Поддерживаемые форматы:**
    *   **WAV:** Без сжатия или с легким сжатием (IMA-ADPCM). Низкая нагрузка на CPU. **Рекомендуется для коротких звуковых эффектов (SFX).**
    *   **Ogg Vorbis:** Сжатие с потерями. Меньший размер файла, но выше нагрузка на CPU. **Рекомендуется для музыки и речи.**
    *   **MP3:** Сжатие с потерями. Менее эффективен, чем Ogg Vorbis (больше размер файла при том же качестве), но требует меньше ресурсов CPU для воспроизведения.
*   **Ключевые опции (WAV):**
    *   **`Edit -> Trim`:** Автоматически обрезает тишину в начале и конце файла.
    *   **`Edit -> Normalize`:** Увеличивает громкость до 0 dB.
    *   **`Loop Mode`:** Устанавливает режим зацикливания (`Disabled`, `Forward`, `Ping-Pong`, `Backward`).
    *   **`Compress -> Mode`:** Позволяет сжать WAV в формат IMA-ADPCM для уменьшения размера в памяти.
*   **Ключевые опции (Ogg/MP3):**
    *   **`Loop`:** Включает зацикливание.
    *   **`BPM`, `Beat Count`, `Bar Beats`:** Параметры для интерактивной музыки (например, в ритм-играх).
*   **Лучшие практики:**
    *   Импортируйте звуковые эффекты "сухими" (без реверберации) и добавляйте эффекты в реальном времени через шины `Audio Bus` в Godot. Это значительно экономит место.

### **Глава 11.4: Экспорт и Пакеты**

*   **Процесс Экспорта:**
    *   **Экспортные шаблоны:** Для каждой платформы (Windows, Linux, Web и т.д.) требуются свои **экспортные шаблоны**. Их можно скачать через меню `Редактор -> Управление экспортными шаблонами`.
    *   **Пресеты экспорта:** В меню `Проект -> Экспорт...` создается пресет для каждой целевой платформы. В нем настраиваются иконки, версия, права, ресурсы для включения и т.д.
*   **Форматы пакетов:**
    *   **PCK (рекомендуется):** Несжатый. Больший размер, но быстрее чтение/запись.
    *   **ZIP:** Сжатый. Меньший размер, но медленнее чтение/запись.

#### **1. DLC, Патчи и Моды (PCK-файлы)**
*   **Концепция:** Godot позволяет упаковывать ресурсы в отдельные `.pck` файлы и загружать их в рантайме. Это основной механизм для создания DLC, патчей и поддержки модов.
*   **Загрузка PCK:**
    ```gdscript
    ProjectSettings.load_resource_pack("res://mods/my_mod.pck")
    ```
    После этого все ресурсы из `my_mod.pck` становятся доступны, как если бы они были частью игры.

#### **2. Feature Tags (Теги Функций)**
*   **Назначение:** Механизм для адаптации проекта под разные платформы и конфигурации сборки. Тег — это строка, определяющая наличие какой-либо функции (например, `windows`, `mobile`, `release`, `etc2`).
*   **Использование:**
    *   **В коде:** `OS.has_feature("feature_name")` позволяет выполнять разный код для разных платформ.
    *   **Переопределение настроек проекта:** В `Настройках проекта` можно переопределить любой параметр для конкретного тега (например, установить разное сжатие текстур по умолчанию для `mobile`).
    *   **В пресетах экспорта:** Можно задать кастомные теги для создания разных версий сборки (например, `demo_build`).

### **Глава 11.5: Файловая Система и Сохранения**

#### **1. Пути в Godot**
*   **Разделители:** Godot всегда использует **прямой слеш (`/`)** в качестве разделителя путей на всех платформах для единообразия.
*   **`res://`:** Путь к **папке проекта**. Доступен для чтения. В экспортированной игре эта папка становится частью виртуальной файловой системы (внутри PCK-файла).
*   **`user://`:** Путь к **папке данных пользователя**. Гарантированно доступен для записи. Используется для сохранения настроек, сохранений игр и т.д. Расположение зависит от ОС (например, `%APPDATA%\Godot\app_userdata\[project_name]` на Windows).

#### **2. Загрузка и Сохранение в Рантайме**
*   **Назначение:** Для загрузки пользовательского контента (моды, кастомные текстуры). **Не используйте** для загрузки ресурсов, которые являются частью проекта.
*   **Классы:** `FileAccess`, `Image.load_from_file(path)`, `AudioStreamOggVorbis.load_from_file(path)`, `GLTFDocument`, `ZIPReader` / `ZIPPacker`.

#### **3. Фоновая загрузка (Background Loading)**
*   **Проблема:** Обычный `load()` блокирует основной поток, что приводит к "зависанию" игры во время загрузки.
*   **Решение:** `ResourceLoader`.
*   **Процесс:**
    1.  Запросить загрузку: `ResourceLoader.load_threaded_request(path)`.
    2.  Проверять статус: `ResourceLoader.load_threaded_get_status(path, progress_array)`.
    3.  Получить ресурс: `var resource = ResourceLoader.load_threaded_get(path)`.

#### **4. Сохранение Игр**
*   **JSON vs. Бинарная Сериализация:**
    *   **JSON:** Человеко-читаемый, но больше по размеру и не поддерживает все типы данных.
    *   **Бинарная:** Компактный, быстрый, поддерживает почти все типы, но не читаем. API: `FileAccess.store_var()` и `FileAccess.get_var()`.
*   **Паттерн сохранения:**
    1.  Объекты для сохранения добавляются в группу "Persist".
    2.  Каждый объект имеет метод `save()`, возвращающий словарь с его состоянием.
    3.  Главный скрипт собирает словари, сериализует их и записывает в файл в `user://`.
---

## **РАЗДЕЛ 12: ЛОКАЛИЗАЦИЯ И АУДИО**

### **Глава 12.1: Интернационализация (i18n)**

*   **Концепция:** Процесс адаптации игры для разных языков и культурных особенностей.
*   **Форматы переводов:**
    *   **CSV:** Простой формат. Каждая строка: `ключ,перевод_en,перевод_es,...`.
    *   **gettext (`.po`, `.mo`):** Стандарт индустрии. Более мощный, поддерживает контексты и формы множественного числа.
*   **Процесс:**
    1.  **Настройка:** В `Проект -> Настройки проекта... -> Localization` добавляются файлы с переводами.
    2.  **Использование в коде:** Текст оборачивается в функцию `tr("KEY_TO_TRANSLATE")`.
    3.  **Автоматический перевод:** Для `Control`-узлов (Label, Button) можно просто вписать ключ в поле `text`, и он будет переведен автоматически.
    4.  **Плюрализация (Множественное число):** `tr("FOUND_%d_APPLES", "FOUND_%d_APPLE", number) % number`.
    5.  **Контекст:** `trc("As in 'close the door'", "Close")`.
*   **Локализация ресурсов:** В `Настройках проекта -> Localization -> Remaps` можно настроить замену одних ресурсов другими в зависимости от текущего языка (например, заменять текстуры с английским текстом на текстуры с испанским).
*   **Тестирование:**
    *   В `Настройках проекта -> Internationalization -> Locale` можно задать язык для тестового запуска игры.
    *   **Псевдолокализация** (`pseudolocalization`) заменяет текст на похожие, но измененные символы, чтобы быстро найти непереведенные строки и проверить верстку.
*   **Поддержка RTL:** Godot автоматически обрабатывает языки с письмом справа налево (арабский, иврит), "отзеркаливая" элементы UI.

### **Глава 12.2: Продвинутые Аудио-функции**

*   **Синхронизация с геймплеем:**
    *   **Проблема:** Существует задержка между вызовом `play()` и реальным началом воспроизведения звука.
    *   **Решение:** Для точной синхронизации (например, в ритм-играх) необходимо учитывать эту задержку, получая ее от аудио-сервера: `AudioServer.get_time_to_next_mix() + AudioServer.get_output_latency()`.
    *   Для получения точной текущей позиции воспроизведения используйте: `player.get_playback_position() + AudioServer.get_time_since_last_mix() - AudioServer.get_output_latency()`.
*   **Text to Speech (TTS):**
    *   **Назначение:** Преобразование текста в речь с помощью системных библиотек ОС.
    *   **Включение:** `Настройки проекта -> Audio -> General -> Enable Text to Speech`.
    *   **Использование:** `DisplayServer.tts_speak("Hello, world!")`. Вызов асинхронный.

### **Глава 12.3: Воспроизведение Видео**

*   **Узел:** Для воспроизведения видео используется `VideoStreamPlayer`.
*   **Поддерживаемый формат:** Встроенная поддержка в Godot есть только для формата **Ogg Theora** (`.ogv`). Другие форматы (H.264, H.265, AV1) требуют расширений (GDExtensions). WebM был удален в Godot 4.
*   **Воспроизведение:** Запускается либо галочкой `Autoplay` в инспекторе, либо вызовом метода `play()` из скрипта.
*   **Ограничения:**
    *   Декодирование происходит на CPU. Высокое разрешение (1440p+) может тормозить на слабых процессорах.
    *   Перемотка на конкретный момент времени не поддерживается.
    *   Скорость воспроизведения изменить нельзя.
    *   Поддерживается только моно или стерео аудио.
*   **Практические Аспекты:**
    *   **Адаптация под размер окна:** Чтобы видео сохраняло пропорции, `VideoStreamPlayer` следует поместить внутрь контейнера `AspectRatioContainer`.
    *   **Отображение на 3D-поверхности:** `VideoStreamPlayer` помещается в `SubViewport`, а `MeshInstance3D` использует `ViewportTexture`, ссылающуюся на этот `SubViewport`.
    *   **Chroma Key (Зеленый экран):** Реализуется с помощью кастомного шейдера, примененного к `VideoStreamPlayer`.
    *   **Кодирование:** Рекомендуется использовать внешний кодировщик (например, **FFmpeg**) для конвертации видео в формат Ogg Theora.
---

## **РАЗДЕЛ 13: ВВОД И МАТЕМАТИЧЕСКИЕ ОСНОВЫ**

### **Глава 13.1: Поток Событий Ввода**

*   **События vs. Опрос:**
    *   **События (Events):** `_input()`, `_unhandled_input()`. Реагируют на дискретные действия (нажатие кнопки, клик мыши).
    *   **Опрос (Polling):** `Input.is_action_pressed()`. Проверяет состояние в каждом кадре. Используется для непрерывных действий (движение).
*   **Жизненный цикл `InputEvent`:** Событие от ОС проходит через длинную цепочку обработки, прежде чем достигнет игровых скриптов:
    1.  **`DisplayServer`** получает событие от ОС.
    2.  **`Viewport`** обрабатывает его.
    3.  **`_input()`:** Первым вызывается у узлов. Если какой-либо узел "потребляет" событие (`get_viewport().set_input_as_handled()`), цепочка прерывается.
    4.  **`_gui_input()`:** События мыши и касаний передаются `Control`-узлам.
    5.  **`_unhandled_input()`:** Вызывается для событий, которые не были обработаны ни в `_input()`, ни в GUI. Идеальное место для общей игровой логики.
*   **Распространение:** События "всплывают" по дереву сцены от низших узлов к высшим (обратный порядок отрисовки).

### **Глава 13.2: Контроллеры и Геймпады**

*   **Абстракция:** Благодаря `InputMap`, действия (`move_left`, `jump`) можно назначать как на клавиатуру, так и на геймпад, используя один и тот же код `Input.is_action_pressed()`.
*   **Аналоговый ввод:**
    *   **`Input.get_vector()`:** Лучший способ для получения направления с двух осей (джойстик, WASD), так как он корректно обрабатывает мертвую зону (deadzone).
    *   **`Input.get_axis()`:** Для одной оси (например, газ/тормоз на триггерах).
*   **Вибрация (Haptic Feedback):**
    *   `Input.start_joy_vibration(device_id, weak_magnitude, strong_magnitude, duration)`
    *   `Input.stop_joy_vibration(device_id)`
*   **Особенности:**
    *   **"Эхо" событий:** Удержание кнопки геймпада не генерирует повторяющиеся события, в отличие от клавиатуры.
    *   **Фокус окна:** Геймпад может посылать события, даже если окно игры не в фокусе. Это можно контролировать, проверяя уведомления `NOTIFICATION_APPLICATION_FOCUS_IN` и `NOTIFICATION_APPLICATION_FOCUS_OUT`.

### **Глава 13.3: Координаты Мыши и Курсор**
*   **Системы координат:** `event.position` в `_input()` возвращает координаты мыши в системе координат **вьюпорта**, а не окна.
*   **Захват мыши (`Input.MOUSE_MODE_CAPTURED`):** В этом режиме курсор скрыт и заблокирован в центре окна. Для получения смещения мыши следует использовать `event.relative`.
*   **Кастомизация курсора:**
    *   **Простой способ:** `Настройки проекта -> Display -> Mouse Cursor`.
    *   **Через код:** `Input.set_custom_mouse_cursor(image, hotspot)`. Позволяет менять курсор динамически.

### **Глава 13.4: Обработка Запросов на Закрытие**
*   **Уведомление:** Когда пользователь пытается закрыть окно (нажатием на "крестик"), всем узлам в дереве сцены отправляется уведомление `NOTIFICATION_WM_CLOSE_REQUEST`.
*   **Перехват:** По умолчанию игра закрывается. Чтобы перехватить это событие (например, для показа диалога "Вы уверены?"), нужно:
    1.  Отключить автоматическое закрытие: `get_tree().auto_accept_quit = false`.
    2.  Обработать уведомление в скрипте и при подтверждении вызвать `get_tree().quit()`.

### **Глава 13.5: Векторная Математика**

*   **Вектор:** Представляет направление и величину (длину). Не имеет позиции.
*   **Операции:** Сложение, вычитание, умножение/деление на скаляр (число).
*   **Применение:**
    *   **Движение:** `new_position = old_position + velocity * delta`.
    *   **Направление:** `vector_to_target = target_position - current_position`.
*   **Единичный вектор (Unit Vector):** Вектор с длиной `1`. Используется для представления чистого направления. Получается **нормализацией** (`vector.normalized()`).
*   **Скалярное произведение (Dot Product): `dot_product = a.dot(b)`**
    *   **Результат:** Скаляр (число).
    *   **Интерпретация:** Показывает, насколько векторы "смотрят" в одном направлении.
        *   `> 0`: Угол < 90°.
        *   `= 0`: Угол = 90° (перпендикулярны).
        *   `< 0`: Угол > 90°.
    *   **Применение:** Проверка, находится ли враг в поле зрения.
*   **Векторное произведение (Cross Product): `cross_product = a.cross(b)` (только в 3D)**
    *   **Результат:** Вектор, перпендикулярный обоим исходным векторам.
    *   **Применение:** Вычисление нормали поверхности по трем точкам.

### **Глава 13.6: Матрицы и Трансформации**

*   **Матрица:** В Godot матрицы используются для представления трансформаций (вращение, масштабирование).
*   **`Transform2D`:** Состоит из двух векторов (`x`, `y`), представляющих базисные векторы, и `origin` для позиции.
*   **`Transform3D`:** Состоит из `Basis` (три вектора `x`, `y`, `z`) и `origin`.
*   **Применение трансформаций:** Трансформации применяются к дочерним узлам путем умножения: `global_transform = parent.global_transform * child.transform`. Порядок важен.
*   **Инверсия:** `transform.affine_inverse()` возвращает обратную трансформацию, которая "отменяет" действие исходной.

### **Глава 13.7: Интерполяция и Кривые**

*   **Интерполяция:** Нахождение промежуточных значений между двумя точками.
*   **`lerp(from, to, weight)`:** Линейная интерполяция. `weight` от 0.0 до 1.0.
*   **Сглаженное движение:** `position = position.lerp(target_position, weight)`. Если `weight` — это константа, умноженная на `delta`, объект будет плавно замедляться по мере приближения к цели.
*   **Кривые Безье:** Математические кривые, определяемые набором точек. В Godot представлены ресурсами `Curve2D`, `Curve3D` и узлами `Path2D`, `Path3D`.
*   **Движение по кривой:** `Curve3D.sample_baked(offset)` позволяет получить точку на кривой на определенном расстоянии от начала, обеспечивая движение с постоянной скоростью.

### **Глава 13.8: Генерация Случайных Чисел**

*   **Глобальные функции:**
    *   `randi()`: Случайное целое.
    *   `randf()`: Случайное float от 0.0 до 1.0.
    *   `randi_range(from, to)`: Случайное целое в диапазоне.
    *   `randf_range(from, to)`: Случайное float в диапазоне.
*   **`RandomNumberGenerator` класс:** Предоставляет больше контроля, позволяет создавать несколько независимых генераторов с собственным `seed`.
*   **Инициализация (`randomize()`):** В Godot 4+ вызывается автоматически при старте. Ручной вызов нужен только для сброса `seed`.
*   **Шум (Noise):** `FastNoiseLite` используется для генерации процедурного "естественного" шума, полезного для генерации ландшафтов, текстур и т.д.
*   **Криптографическая случайность:** `Crypto` класс используется, когда требуется высокий уровень непредсказуемости (не для геймплея).
---

## **РАЗДЕЛ 14: НАВИГАЦИЯ**

### **Глава 14.1: Основы Навигации**

*   **Назначение:** Системы навигации позволяют объектам (агентам) находить путь из одной точки в другую, обходя препятствия.
*   **Два основных подхода:**
    *   **На основе сетки (Grid-based):** `AStar2D`, `AStarGrid2D`. Агент может двигаться только между предопределенными точками или ячейками сетки. Быстро и просто, идеально для пошаговых игр или игр с движением по тайлам.
    *   **На основе меша (Mesh-based):** `NavigationServer`. Агент может свободно перемещаться в пределах полигональной области (навигационного меша). Более гибкий и мощный подход, подходит для игр в реальном времени.

### **Глава 14.2: Навигация на основе Меша (`NavigationServer`)**

#### **1. Ключевые компоненты**
*   **`NavigationServer2D/3D`:** Низкоуровневый сервер, который управляет всеми навигационными данными и расчетами. Обычно с ним взаимодействуют через узлы-хелперы.
*   **`NavigationRegion2D/3D`:** Узел, который определяет область для навигации. Содержит ресурс навигационного меша.
*   **`NavigationMesh` / `NavigationPolygon`:** Ресурс, хранящий геометрию проходимой области. Может быть "запечен" (Bake) из геометрии дочерних узлов или нарисован вручную.
*   **`NavigationAgent2D/3D`:** Узел-компонент, который добавляется к движущемуся объекту (`CharacterBody2D/3D`). Он запрашивает путь у `NavigationServer` и предоставляет следующую точку для движения. **Агент не двигает объект сам**, он лишь предоставляет информацию. Движение реализуется в скрипте родительского узла.
*   **`NavigationObstacle2D/3D`:** Узел для динамических препятствий. Агенты будут пытаться его обойти.
*   **`NavigationLink2D/3D`:** Позволяет вручную соединять две точки на разных навигационных мешах (например, для прыжка через пропасть или использования телепорта).

#### **2. Процесс поиска пути с `NavigationAgent`**
1.  **Настройка сцены:**
    *   Создается `NavigationRegion` с `NavigationMesh`/`Polygon`.
    *   Геометрия "запекается" в навигационный меш.
    *   К `CharacterBody` добавляется `NavigationAgent`.
2.  **Работа в скрипте:**
    *   В `_ready()` дожидаемся синхронизации сервера (`await get_tree().physics_frame`).
    *   Задаем цель для агента: `navigation_agent.target_position = target_global_position`.
    *   В `_physics_process()`:
        *   Проверяем, не достигнут ли конец пути: `if navigation_agent.is_navigation_finished(): return`.
        *   Получаем следующую точку пути: `var next_path_position = navigation_agent.get_next_path_position()`.
        *   Вычисляем вектор скорости: `var new_velocity = global_position.direction_to(next_path_position) * speed`.
        *   Двигаем персонажа: `velocity = new_velocity; move_and_slide()`.

#### **3. Избегание столкновений (Avoidance)**
*   `NavigationAgent` также управляет избеганием столкновений с другими агентами и препятствиями.
*   **Процесс:**
    1.  Включается `navigation_agent.avoidance_enabled = true`.
    2.  Подписываемся на сигнал `velocity_computed(safe_velocity)`.
    3.  В `_physics_process()` **не устанавливаем** `velocity` напрямую, а вызываем `navigation_agent.set_velocity(desired_velocity)`.
    4.  `NavigationServer` вычислит безопасную скорость с учетом других агентов и испустит сигнал `velocity_computed`.
    5.  В обработчике сигнала мы применяем эту `safe_velocity` для движения через `move_and_slide()`.

#### **4. Синхронизация и Потоки**
*   `NavigationServer` является потокобезопасным, но все изменения (добавление регионов, агентов) применяются только в конце физического кадра.
*   При запросе пути сразу после изменения навигационной карты, путь может быть неверным. Необходимо дождаться следующего физического кадра (`await get_tree().physics_frame`).
---

## **РАЗДЕЛ 15: АНИМАЦИЯ (ПРОДОЛЖЕНИЕ)**

### **Глава 15.1: AnimationPlayer: Продвинутые Функции**

#### **1. Редактирование и Настройка**
*   **RESET-анимация:** Специальная анимация с именем "RESET" (регистрозависимо), которая хранит "позу по умолчанию" для объекта. Она автоматически применяется при старте игры (если включено `Reset On Save`), чтобы гарантировать, что объект находится в правильном состоянии перед началом других анимаций.
*   **Onion Skinning ("Калька"):** Позволяет видеть полупрозрачные "призраки" объекта из предыдущих и последующих кадров, что упрощает создание плавной анимации.
*   **Animation Markers (Маркеры):** Позволяют именовать определенные участки временной шкалы и воспроизводить только их с помощью `play_section()`.

#### **2. Настройки Дорожек (Track Settings)**
*   **Update Mode (Режим обновления):**
    *   **`Continuous`:** Свойство обновляется на каждом кадре (стандартно).
    *   **`Discrete`:** Свойство меняется скачком только в момент ключевого кадра.
    *   **`Capture`:** Захватывает текущее значение свойства и плавно переходит от него к первому ключу. Полезно для динамических переходов.
*   **Interpolation (Интерполяция):**
    *   **`Nearest`:** Без интерполяции.
    *   **`Linear`:** Линейная интерполяция (постоянная скорость).
    *   **`Cubic`:** Кубическая интерполяция (с ускорением и замедлением).
*   **Loop Mode (Режим зацикливания):**
    *   **`None`:** Анимация останавливается в конце.
    *   **`Linear`:** Анимация повторяется с начала.
    *   **`Ping-Pong`:** Анимация проигрывается вперед, а затем назад.

### **Глава 15.2: Типы Дорожек (Track Types)**
`AnimationPlayer` поддерживает различные типы дорожек для специальных задач:

*   **`Property Track`:** Стандартная дорожка для анимации любого свойства.
*   **`3D Position/Rotation/Scale Track`:** Оптимизированные дорожки для анимации трансформаций 3D-объектов.
*   **`Blend Shape Track`:** Для анимации морфинга (blend shapes) у `MeshInstance3D`.
*   **`Call Method Track`:** Позволяет вызвать метод любого узла в определенный момент времени. Ключевой кадр на этой дорожке хранит имя метода и его аргументы. Используется для синхронизации событий с анимацией (например, звук шага в момент касания ногой земли, вызов `queue_free()` в конце анимации смерти).
*   **`Bezier Curve Track`:** Позволяет анимировать float-свойство с помощью кривой Безье, давая полный контроль над кривой изменения значения.
*   **`Audio Playback Track`:** Для проигрывания звука из узла `AudioStreamPlayer`. Ключевой кадр на дорожке запускает воспроизведение.
*   **`Animation Playback Track`:** Позволяет управлять другим `AnimationPlayer` из текущей анимации. Используется для создания сложных последовательностей и кат-сцен.

### **Глава 15.3: 2D Скелетная Анимация**

#### **1. Cutout Animation (Перекладная анимация)**
*   **Концепция:** Техника, при которой персонаж составляется из отдельных спрайтов (частей тела), которые затем анимируются путем изменения их трансформаций (вращение, перемещение).
*   **Создание рига (Rig):**
    1.  **Иерархия:** Части тела выстраиваются в иерархию "родитель-потомок". Корнем скелета обычно является таз (`hip`).
    2.  **Точка вращения (Pivot):** Для каждого спрайта (`Sprite2D`) необходимо правильно выставить точку вращения, смещая свойство `Offset`.
    3.  **Порядок отрисовки:** Для управления тем, какая часть тела находится "спереди", а какая "сзади", используется либо `z_index`, либо свойство `Show Behind Parent`, либо узел `RemoteTransform2D`.
*   **Скелеты (`Skeleton2D`):** Упрощают анимацию ригов и позволяют использовать инверсную кинематику (IK).
*   **Инверсная кинематика (IK Chain):**
    *   **Назначение:** Позволяет анимировать конечности, двигая только конечную точку (например, кисть или стопу).
    *   **Ограничение:** В Godot IK-цепи работают **только в редакторе** для упрощения расстановки ключевых кадров и **не работают в рантайме**.

#### **2. Skeletal Deform (Скелетная деформация)**
*   **Концепция:** Вместо набора отдельных спрайтов используется одно цельное изображение персонажа, которое деформируется с помощью скелета (`Skeleton2D` и `Bone2D`).
*   **Процесс:**
    1.  **Создание полигона:** С помощью `Polygon2D` создается полигон, повторяющий контур персонажа на текстуре.
    2.  **Создание скелета:** Создается иерархия узлов `Bone2D`.
    3.  **Привязка:** `Polygon2D` привязывается к `Skeleton2D`.
    4.  **Раскраска весов (Weight Painting):** В UV-редакторе для `Polygon2D` каждая вершина полигона "раскрашивается", чтобы определить, какая кость и с какой силой на нее влияет.
    5.  **Внутренние вершины:** Для более качественных и естественных сгибов в полигон добавляются внутренние вершины.

### **Глава 15.4: AnimationTree (Дерево Анимаций)**

*   **Назначение:** Узел для продвинутого управления анимациями из `AnimationPlayer`. Позволяет смешивать (blending) анимации, создавать сложные переходы и управлять ими через конечный автомат (State Machine).
*   **Принцип:** `AnimationTree` не содержит анимаций. Он подключается к `AnimationPlayer` и использует его анимации как "сырье".

#### **1. Ключевые ноды AnimationTree:**
*   **`AnimationNodeAnimation`:** Просто проигрывает одну анимацию.
*   **`AnimationNodeBlend2` / `Blend3`:** Смешивает 2 или 3 анимации на основе одного float-параметра.
*   **`AnimationNodeBlendSpace1D` / `BlendSpace2D`:** Продвинутое смешивание на 1D или 2D-пространстве (например, для смешивания ходьбы в 8 направлениях).
*   **`AnimationNodeStateMachine` (Конечный автомат):** Позволяет создавать состояния ("Idle", "Walk") и настраивать правила перехода между ними. Стандартный подход для анимаций персонажа.
*   **`AnimationNodeOneShot`:** Проигрывает одну анимацию (выстрел, уворот) поверх текущего состояния.
*   **`AnimationNodeTransition`:** Простой переключатель между анимациями.

#### **2. Управление из кода**
*   Управление `AnimationTree` происходит через установку его параметров:
    ```gdscript
    # Установить значение для Blend2
    animation_tree["parameters/my_blend_node/blend_amount"] = 0.5
    # Переключить состояние в StateMachine
    var state_machine = animation_tree["parameters/playback"]
    state_machine.travel("jump_state")
    ```

#### **3. Root Motion (Движение корня)**
*   **Концепция:** Техника, при которой движение персонажа в мире (`CharacterBody3D`) управляется смещением корневой кости в самой анимации.
*   **Применение:** В коде из `AnimationTree` извлекается дельта трансформации корневой кости (`get_root_motion_...()`) и применяется к `CharacterBody3D` через `move_and_slide()`.
---

## **РАЗДЕЛ 16: СВОДКА ДОПОЛНИТЕЛЬНЫХ ТЕМ**

### **Глава 16.1: Бинарная Сериализация (API)**

*   **Назначение:** Низкоуровневый формат, который Godot использует для сетевой передачи данных и в функциях `store_var`/`get_var`. Основан на преобразовании `Variant` в массив байтов.
*   **Спецификация пакета:** Каждый пакет данных имеет 4-байтовый заголовок, который содержит тип данных и флаги (например, `ENCODE_FLAG_64` для 64-битной точности). Далее следуют сами данные, выровненные по 4 байта.
*   **Сериализация объектов:**
    *   **`full_objects = false` (по умолчанию):** Сериализуется только `ObjectID`.
    *   **`full_objects = true`:** Сериализуется рекурсивно весь объект с его свойствами (только те, что имеют флаг `PROPERTY_USAGE_STORAGE`).

### **Глава 16.2: Паттерны Проектирования (Сводка)**

*   **Декомпозиция:** Создание независимых, самодостаточных сцен для ключевых сущностей (`Player`, `Enemy`, `HUD`), которые затем объединяются в главную сцену (`Main`) путем инстанциирования.
*   **Делегирование событий:** Дочерние узлы (`Player`, `Enemy`) не управляют напрямую главным циклом. Вместо этого они испускают сигналы (`hit`, `squashed`). Главная сцена (`Main`) подписывается на эти сигналы и централизованно управляет состоянием игры (счет, Game Over).
*   **Паттерн "Pivot" для 3D-персонажа:**
    *   **Структура:** `CharacterBody3D` -> `Pivot (Node3D)` -> `Визуал (MeshInstance3D)`.
    *   **Назначение:** Позволяет коду двигать `CharacterBody3D`, а `AnimationPlayer` или код могут независимо вращать `Pivot` для анимации и направления взгляда, избегая конфликтов.
*   **Паттерн "Хитбокс":**
    *   **Структура:** Основное тело (`CharacterBody`) для столкновений с миром + дочерний узел `Area` для обнаружения урона.
    *   **Назначение:** Разделяет физику движения от логики получения урона.

### **Глава 16.3: Игровой Цикл (Сводка)**

*   **Динамический спавн:** Экспортировать `PackedScene`, создавать экземпляр через `.instantiate()`, настраивать и добавлять в сцену через `add_child()`.
*   **Перезапуск уровня:** `get_tree().reload_current_scene()`.
*   **Задержки в коде:** Использовать `await get_tree().create_timer(time_sec).timeout` для создания одноразовой асинхронной задержки.
---

## **РАЗДЕЛ 11: КОНВЕЙЕР АССЕТОВ, ФАЙЛЫ И СОХРАНЕНИЯ**

### **Глава 11.1: Процесс Импорта**

#### **1. Основы**
*   **Процесс:** Когда вы добавляете внешний ассет (например, `.png`, `.fbx`, `.wav`) в папку проекта, Godot автоматически **импортирует** его. Это означает, что он создает внутреннюю, оптимизированную для движка версию этого ассета в скрытой папке `.godot/imported/`. Оригинальный файл при этом не изменяется.
*   **Файлы `.import`:** Рядом с каждым импортированным ассетом создается текстовый файл с тем же именем и расширением `.import`. В нем хранятся все настройки импорта для данного ассета. **Эти файлы необходимо добавлять в систему контроля версий (Git).**
*   **Доступ в коде:** Используйте `ResourceLoader` (или `load`/`preload`), чтобы обращаться к ассетам по их пути в `res://`. Движок автоматически подменит путь на внутренний импортированный файл. Прямой доступ через `FileAccess` к `res://` путям сломает экспорт.

#### **2. Настройка импорта**
*   **Панель "Import":** Когда вы выбираете внешний ассет в доке "FileSystem", в левой верхней панели появляется вкладка "Import", где можно изменить все параметры импорта. После изменения параметров необходимо нажать кнопку **"Reimport"**.
*   **Множественный реимпорт:** Можно выделить несколько ассетов одного типа, чтобы изменить общие для них параметры импорта и переимпортировать их все разом.
*   **Предустановки (Presets):** Можно сохранить набор настроек импорта как пресет и применять его к другим ассетам.
*   **Настройки по умолчанию:** В `Проект -> Настройки проекта... -> Import Defaults` можно задать параметры импорта по умолчанию для каждого типа ресурсов.

### **Глава 11.2: Импорт Изображений**

*   **Поддерживаемые форматы:** PNG, JPG, SVG (растеризуется при импорте), WebP, BMP, TGA, EXR, HDR, DDS, KTX.
*   **Режимы импорта (`Import As`):**
    *   **`Texture2D`:** Стандартный режим для 2D и 3D текстур.
    *   **`Image`:** Импортирует как ресурс `Image`, позволяя прямой доступ к пиксельным данным, но без оптимизаций для GPU.
    *   **`Cubemap` / `CubemapArray`:** Для скайбоксов и карт отражений.
    *   **`Texture2DArray`:** Массив 2D-текстур.
    *   **`TextureAtlas`:** Для 2D-анимации (`AnimatedSprite2D`).

#### **1. Сжатие (Compress Mode)**
| Режим | Описание | VRAM | Диск | Качество | Производительность |
| :--- | :--- | :--- | :--- | :--- | :--- |
| **Lossless** | Сжатие без потерь (WebP). | Большой | Маленький | Отличное | Нормальная |
| **Lossy** | Сжатие с потерями (WebP). | Большой | Очень мал. | Хорошее | Нормальная |
| **VRAM Compressed** | **(Рекомендуется для 3D)**. Формат, оптимизированный для GPU (S3TC/ETC2). | **Маленький** | Маленький | Среднее | **Высокая** |
| **VRAM Uncompressed** | Без сжатия VRAM. | Огромный | Большой | Отличное | Нормальная |
| **Basis Universal** | Универсальный формат сжатия для GPU. | **Маленький** | Очень мал. | Среднее | **Высокая** |

#### **2. Ключевые опции**
*   **`Mipmaps -> Generate`:** Создает уменьшенные копии текстуры для отображения на расстоянии. **Обязательно для 3D**, чтобы избежать зернистости. Увеличивает использование памяти на ~33%.
*   **`Roughness -> Mode`:** Позволяет использовать один из каналов (R, G, B, A, Gray) текстуры как карту шероховатости для PBR-материалов.
*   **`Process -> Normal Map Invert Y`:** Необходимо включать для карт нормалей, созданных в DirectX-совместимых программах (в Godot используется OpenGL-стандарт).
*   **`Compress -> Normal Map (RGTC)`:** Специальный режим сжатия для карт нормалей, который дает значительно лучшее качество, чем стандартный VRAM.

### **Глава 11.3: Импорт Аудио**

*   **Поддерживаемые форматы:**
    *   **WAV:** Без сжатия или с легким сжатием (IMA-ADPCM). Низкая нагрузка на CPU. **Рекомендуется для коротких звуковых эффектов (SFX).**
    *   **Ogg Vorbis:** Сжатие с потерями. Меньший размер файла, но выше нагрузка на CPU. **Рекомендуется для музыки и речи.**
    *   **MP3:** Сжатие с потерями. Менее эффективен, чем Ogg Vorbis (больше размер файла при том же качестве), но требует меньше ресурсов CPU для воспроизведения.
*   **Ключевые опции (WAV):**
    *   **`Edit -> Trim`:** Автоматически обрезает тишину в начале и конце файла.
    *   **`Edit -> Normalize`:** Увеличивает громкость до 0 dB.
    *   **`Loop Mode`:** Устанавливает режим зацикливания (`Disabled`, `Forward`, `Ping-Pong`, `Backward`).
    *   **`Compress -> Mode`:** Позволяет сжать WAV в формат IMA-ADPCM для уменьшения размера в памяти.
*   **Ключевые опции (Ogg/MP3):**
    *   **`Loop`:** Включает зацикливание.
    *   **`BPM`, `Beat Count`, `Bar Beats`:** Параметры для интерактивной музыки (например, в ритм-играх).
*   **Лучшие практики:**
    *   Импортируйте звуковые эффекты "сухими" (без реверберации) и добавляйте эффекты в реальном времени через шины `Audio Bus` в Godot. Это значительно экономит место.

### **Глава 11.4: Файловая Система и Сохранения**

#### **1. Пути в Godot**
*   **Разделители:** Godot всегда использует **прямой слеш (`/`)** в качестве разделителя путей на всех платформах для единообразия.
*   **`res://`:** Путь к **папке проекта**. Доступен для чтения. В экспортированной игре эта папка становится частью виртуальной файловой системы (внутри PCK-файла).
*   **`user://`:** Путь к **папке данных пользователя**. Гарантированно доступен для записи. Используется для сохранения настроек, сохранений игр и т.д. Расположение зависит от ОС (например, `%APPDATA%\Godot\app_userdata\[project_name]` на Windows).

#### **2. Загрузка и Сохранение в Рантайме**
*   **Назначение:** Для загрузки пользовательского контента (моды, кастомные текстуры). **Не используйте** для загрузки ресурсов, которые являются частью проекта.
*   **Классы:** `FileAccess`, `Image.load_from_file(path)`, `AudioStreamOggVorbis.load_from_file(path)`, `GLTFDocument`, `ZIPReader` / `ZIPPacker`.

#### **3. Фоновая загрузка (Background Loading)**
*   **Проблема:** Обычный `load()` блокирует основной поток, что приводит к "зависанию" игры во время загрузки.
*   **Решение:** `ResourceLoader`.
*   **Процесс:**
    1.  Запросить загрузку: `ResourceLoader.load_threaded_request(path)`.
    2.  Проверять статус: `ResourceLoader.load_threaded_get_status(path, progress_array)`.
    3.  Получить ресурс: `var resource = ResourceLoader.load_threaded_get(path)`.

#### **4. Сохранение Игр**
*   **JSON vs. Бинарная Сериализация:**
    *   **JSON:** Человеко-читаемый, но больше по размеру и не поддерживает все типы данных.
    *   **Бинарная:** Компактный, быстрый, поддерживает почти все типы, но не читаем. API: `FileAccess.store_var()` и `FileAccess.get_var()`.
*   **Паттерн сохранения:**
    1.  Объекты для сохранения добавляются в группу "Persist".
    2.  Каждый объект имеет метод `save()`, возвращающий словарь с его состоянием.
    3.  Главный скрипт собирает словари, сериализует их и записывает в файл в `user://`.
---

## **РАЗДЕЛ 12: ЭКСПОРТ И СЕТЕВОЕ ВЗАИМОДЕЙСТВИЕ**

### **Глава 12.1: Экспорт Проектов**

#### **1. Процесс Экспорта**
*   **Экспортные шаблоны:** Для каждой платформы (Windows, Linux, Web и т.д.) требуются свои **экспортные шаблоны**. Их можно скачать через меню `Редактор -> Управление экспортными шаблонами`.
*   **Пресеты экспорта:** В меню `Проект -> Экспорт...` создается пресет для каждой целевой платформы. В нем настраиваются иконки, версия, права, ресурсы для включения и т.д.
*   **Форматы пакетов:**
    *   **PCK (рекомендуется):** Несжатый. Больший размер, но быстрее чтение/запись.
    *   **ZIP:** Сжатый. Меньший размер, но медленнее чтение/запись.

#### **2. DLC, Патчи и Моды (PCK-файлы)**
*   **Концепция:** Godot позволяет упаковывать ресурсы в отдельные `.pck` файлы и загружать их в рантайме. Это основной механизм для создания DLC, патчей и поддержки модов.
*   **Загрузка PCK:**
    ```gdscript
    ProjectSettings.load_resource_pack("res://mods/my_mod.pck")
    ```
    После этого все ресурсы из `my_mod.pck` становятся доступны, как если бы они были частью игры.

#### **3. Feature Tags (Теги Функций)**
*   **Назначение:** Механизм для адаптации проекта под разные платформы и конфигурации сборки. Тег — это строка, определяющая наличие какой-либо функции (например, `windows`, `mobile`, `release`, `etc2`).
*   **Использование:**
    *   **В коде:** `OS.has_feature("feature_name")` позволяет выполнять разный код для разных платформ.
    *   **Переопределение настроек проекта:** В `Настройках проекта` можно переопределить любой параметр для конкретного тега (например, установить разное сжатие текстур по умолчанию для `mobile`).
    *   **В пресетах экспорта:** Можно задать кастомные теги для создания разных версий сборки (например, `demo_build`).

### **Глава 12.2: Высокоуровневый мультиплеер**

*   **API:** Основано на объекте `MultiplayerAPI` и `MultiplayerPeer`.
*   **Инициализация:**
    1.  Создается пир: `var peer = ENetMultiplayerPeer.new()`.
    2.  Пир настраивается как сервер (`peer.create_server(PORT)`) или клиент (`peer.create_client(IP, PORT)`).
    3.  Пир назначается дереву сцен: `multiplayer.multiplayer_peer = peer`.
*   **RPC (Remote Procedure Calls - Удаленный вызов процедур):**
    *   **Назначение:** Основной способ вызова функций на других компьютерах в сети.
    *   **Объявление:** Функция помечается аннотацией `@rpc`.
    *   **Вызов:** `my_node.rpc("function_name", arg1, arg2)`.
    *   **Ключевые параметры `@rpc`:**
        *   **`authority` / `any_peer`:** Кто может вызывать эту функцию.
        *   **`call_local`:** Будет ли функция вызвана и на локальном клиенте.
        *   **`reliable` / `unreliable`:** Гарантируется ли доставка пакета. `reliable` медленнее, но надежнее. `unreliable` быстрее, но пакеты могут теряться (подходит для часто обновляемых данных, вроде позиции игрока).
        *   **`channel`:** Позволяет отправлять пакеты по разным каналам для предотвращения задержек (например, чат не должен замедлять движение).

### **Глава 12.3: Низкоуровневое сетевое взаимодействие**

#### **1. HTTP-запросы**
*   **Назначение:** Для взаимодействия с веб-серверами (авторизация, таблицы лидеров, загрузка ассетов). Не подходит для игрового процесса в реальном времени.
*   **Узел:** `HTTPRequest`.
*   **Процесс:**
    1.  Подключиться к сигналу `request_completed`.
    2.  Вызвать `http_request.request("http://my-api.com/data")`.
    3.  Обработать результат в функции, подключенной к сигналу. Данные приходят в виде `PackedByteArray`, который нужно преобразовать в строку (`body.get_string_from_utf8()`).

#### **2. WebSocket**
*   **Назначение:** Протокол для постоянного двунаправленного соединения. Хорошо подходит для чатов, пошаговых игр. Недостаточно быстр для игр в реальном времени.
*   **Классы:** `WebSocketPeer` (клиент), `WebSocketServer` (сервер).
*   **Процесс:**
    1.  Клиент создает `WebSocketPeer` и вызывает `socket.connect_to_url(url)`.
    2.  Сервер создает `WebSocketServer` и вызывает `server.listen(port)`.
    3.  В `_process()` обе стороны вызывают `poll()` для обработки событий.
    4.  Данные отправляются через `put_packet()` и принимаются через `get_packet()`.

#### **3. WebRTC**
*   **Назначение:** Технология для прямого peer-to-peer (P2P) соединения между клиентами с низкой задержкой. Идеально для быстрых мультиплеерных игр.
*   **Принцип:** Клиенты сначала подключаются к **сигнальному серверу** (Signaling Server), обмениваются через него информацией о соединении (SDP, ICE candidates), а затем устанавливают прямое соединение друг с другом.
*   **Классы:** `WebRTCPeerConnection`, `WebRTCDataChannel`.
---

## **РАЗДЕЛ 13: МАТЕМАТИКА И ЛОКАЛИЗАЦИЯ**

### **Глава 13.1: Векторная Математика**

*   **Вектор:** Представляет направление и величину (длину). Не имеет позиции.
*   **Операции:** Сложение, вычитание, умножение/деление на скаляр (число).
*   **Применение:**
    *   **Движение:** `new_position = old_position + velocity * delta`.
    *   **Направление:** `vector_to_target = target_position - current_position`.
*   **Единичный вектор (Unit Vector):** Вектор с длиной `1`. Используется для представления чистого направления. Получается **нормализацией** (`vector.normalized()`).
*   **Скалярное произведение (Dot Product): `dot_product = a.dot(b)`**
    *   **Результат:** Скаляр (число).
    *   **Интерпретация:** Показывает, насколько векторы "смотрят" в одном направлении.
        *   `> 0`: Угол < 90°.
        *   `= 0`: Угол = 90° (перпендикулярны).
        *   `< 0`: Угол > 90°.
    *   **Применение:** Проверка, находится ли враг в поле зрения.
*   **Векторное произведение (Cross Product): `cross_product = a.cross(b)` (только в 3D)**
    *   **Результат:** Вектор, перпендикулярный обоим исходным векторам.
    *   **Применение:** Вычисление нормали поверхности по трем точкам.

### **Глава 13.2: Продвинутая Векторная Математика (Плоскости)**
*   **Плоскость (Plane):** Бесконечная поверхность, которая делит 3D-пространство на два полупространства (положительное и отрицательное).
*   **Определение:** Задается нормалью (единичным вектором `N`) и расстоянием от начала координат (`D`).
*   **Применение:**
    *   **Определение расстояния до точки:** `distance = plane.distance_to(point)`. Знак результата показывает, с какой стороны от плоскости находится точка.
    *   **Проверка принадлежности к объему:** Если точка имеет отрицательное расстояние до всех плоскостей, образующих выпуклый многогранник, значит, она находится внутри него.
    *   **Обнаружение столкновений (SAT):** Теорема о разделяющей оси, используемая в физических движках, основана на поиске плоскости, разделяющей два выпуклых объекта.

### **Глава 13.3: Матрицы и Трансформации**

*   **Матрица:** В Godot матрицы используются для представления трансформаций (вращение, масштабирование).
*   **`Transform2D`:** Состоит из двух векторов (`x`, `y`), представляющих базисные векторы, и `origin` для позиции.
*   **`Transform3D`:** Состоит из `Basis` (три вектора `x`, `y`, `z`) и `origin`.
*   **Применение трансформаций:** Трансформации применяются к дочерним узлам путем умножения: `global_transform = parent.global_transform * child.transform`. Порядок важен.
*   **Инверсия:** `transform.affine_inverse()` возвращает обратную трансформацию, которая "отменяет" действие исходной.

### **Глава 13.4: Интерполяция и Кривые**

*   **Интерполяция:** Нахождение промежуточных значений между двумя точками.
*   **`lerp(from, to, weight)`:** Линейная интерполяция. `weight` от 0.0 до 1.0.
*   **Сглаженное движение:** `position = position.lerp(target_position, weight)`. Если `weight` — это константа, умноженная на `delta`, объект будет плавно замедляться по мере приближения к цели.
*   **Кривые Безье:** Математические кривые, определяемые набором точек. В Godot представлены ресурсами `Curve2D`, `Curve3D` и узлами `Path2D`, `Path3D`.
*   **Движение по кривой:** `Curve3D.sample_baked(offset)` позволяет получить точку на кривой на определенном расстоянии от начала, обеспечивая движение с постоянной скоростью.

### **Глава 13.5: Генерация Случайных Чисел**

*   **Глобальные функции:**
    *   `randi()`: Случайное целое.
    *   `randf()`: Случайное float от 0.0 до 1.0.
    *   `randi_range(from, to)`: Случайное целое в диапазоне.
    *   `randf_range(from, to)`: Случайное float в диапазоне.
*   **`RandomNumberGenerator` класс:** Предоставляет больше контроля, позволяет создавать несколько независимых генераторов с собственным `seed`.
*   **Инициализация (`randomize()`):** В Godot 4+ вызывается автоматически при старте. Ручной вызов нужен только для сброса `seed`.
*   **Шум (Noise):** `FastNoiseLite` используется для генерации процедурного "естественного" шума, полезного для генерации ландшафтов, текстур и т.д.
*   **Криптографическая случайность:** `Crypto` класс используется, когда требуется высокий уровень непредсказуемости (не для геймплея).

### **Глава 13.6: Интернационализация (i18n)**

*   **Концепция:** Процесс адаптации игры для разных языков и культурных особенностей.
*   **Форматы переводов:**
    *   **CSV:** Простой формат. Каждая строка: `ключ,перевод_en,перевод_es,...`.
    *   **gettext (`.po`, `.mo`):** Стандарт индустрии. Более мощный, поддерживает контексты и формы множественного числа.
*   **Процесс:**
    1.  **Настройка:** В `Проект -> Настройки проекта... -> Localization` добавляются файлы с переводами.
    2.  **Использование в коде:** Текст оборачивается в функцию `tr("KEY_TO_TRANSLATE")`.
    3.  **Автоматический перевод:** Для `Control`-узлов (Label, Button) можно просто вписать ключ в поле `text`, и он будет переведен автоматически.
*   **Локализация ресурсов:** В `Настройках проекта -> Localization -> Remaps` можно настроить замену одних ресурсов другими в зависимости от текущего языка (например, заменять текстуры с английским текстом на текстуры с испанским).
---

## **РАЗДЕЛ 14: НАВИГАЦИЯ**

### **Глава 14.1: Основы Навигации**

*   **Назначение:** Системы навигации позволяют объектам (агентам) находить путь из одной точки в другую, обходя препятствия.
*   **Два основных подхода:**
    *   **На основе сетки (Grid-based):** `AStar2D`, `AStarGrid2D`. Агент может двигаться только между предопределенными точками или ячейками сетки. Быстро и просто, идеально для пошаговых игр или игр с движением по тайлам.
    *   **На основе меша (Mesh-based):** `NavigationServer`. Агент может свободно перемещаться в пределах полигональной области (навигационного меша). Более гибкий и мощный подход, подходит для игр в реальном времени.

### **Глава 14.2: Навигация на основе Меша (`NavigationServer`)**

#### **1. Ключевые компоненты**
*   **`NavigationServer2D/3D`:** Низкоуровневый сервер, который управляет всеми навигационными данными и расчетами. Обычно с ним взаимодействуют через узлы-хелперы.
*   **`NavigationRegion2D/3D`:** Узел, который определяет область для навигации. Содержит ресурс навигационного меша.
*   **`NavigationMesh` / `NavigationPolygon`:** Ресурс, хранящий геометрию проходимой области. Может быть "запечен" (Bake) из геометрии дочерних узлов или нарисован вручную.
*   **`NavigationAgent2D/3D`:** Узел-компонент, который добавляется к движущемуся объекту (`CharacterBody2D/3D`). Он запрашивает путь у `NavigationServer` и предоставляет следующую точку для движения. **Агент не двигает объект сам**, он лишь предоставляет информацию. Движение реализуется в скрипте родительского узла.
*   **`NavigationObstacle2D/3D`:** Узел для динамических препятствий. Агенты будут пытаться его обойти.
*   **`NavigationLink2D/3D`:** Позволяет вручную соединять две точки на разных навигационных мешах (например, для прыжка через пропасть или использования телепорта).

#### **2. Процесс поиска пути с `NavigationAgent`**
1.  **Настройка сцены:**
    *   Создается `NavigationRegion` с `NavigationMesh`/`Polygon`.
    *   Геометрия "запекается" в навигационный меш.
    *   К `CharacterBody` добавляется `NavigationAgent`.
2.  **Работа в скрипте:**
    *   В `_ready()` дожидаемся синхронизации сервера (`await get_tree().physics_frame`).
    *   Задаем цель для агента: `navigation_agent.target_position = target_global_position`.
    *   В `_physics_process()`:
        *   Проверяем, не достигнут ли конец пути: `if navigation_agent.is_navigation_finished(): return`.
        *   Получаем следующую точку пути: `var next_path_position = navigation_agent.get_next_path_position()`.
        *   Вычисляем вектор скорости: `var new_velocity = global_position.direction_to(next_path_position) * speed`.
        *   Двигаем персонажа: `velocity = new_velocity; move_and_slide()`.

#### **3. Избегание столкновений (Avoidance)**
*   `NavigationAgent` также управляет избеганием столкновений с другими агентами и препятствиями.
*   **Процесс:**
    1.  Включается `navigation_agent.avoidance_enabled = true`.
    2.  Подписываемся на сигнал `velocity_computed(safe_velocity)`.
    3.  В `_physics_process()` **не устанавливаем** `velocity` напрямую, а вызываем `navigation_agent.set_velocity(desired_velocity)`.
    4.  `NavigationServer` вычислит безопасную скорость с учетом других агентов и испустит сигнал `velocity_computed`.
    5.  В обработчике сигнала мы применяем эту `safe_velocity` для движения через `move_and_slide()`.

#### **4. Синхронизация и Потоки**
*   `NavigationServer` является потокобезопасным, но все изменения (добавление регионов, агентов) применяются только в конце физического кадра.
*   При запросе пути сразу после изменения навигационной карты, путь может быть неверным. Необходимо дождаться следующего физического кадра (`await get_tree().physics_frame`).
*   **Отладка:** В меню `Debug` можно включить `Visible Navigation` для визуализации навигационных мешей и путей в запущенной игре.
---

## **РАЗДЕЛ 15: ОПТИМИЗАЦИЯ ПРОИЗВОДИТЕЛЬНОСТИ**

### **Глава 15.1: Общие Принципы**

*   **"Преждевременная оптимизация — корень всех зол"**: Не оптимизируйте код, который и так работает быстро. Сконцентрируйтесь на реальных "узких местах".
*   **Процесс оптимизации:**
    1.  **Профилирование:** Используйте профилировщик, чтобы найти самые медленные части кода/рендеринга.
    2.  **Оптимизация:** Улучшите найденное "узкое место".
    3.  **Возврат к шагу 1:** Повторяйте, пока производительность не станет приемлемой.
*   **Инструменты для измерения:**
    *   **Встроенный профилировщик Godot:** `Отладчик -> Профилировщик`.
    *   **Внешние профилировщики:** NVIDIA Nsight, AMD uProf, Intel VTune.
    *   **Измерение вручную:** `Time.get_ticks_usec()` для замера времени выполнения участков кода.

### **Глава 15.2: Оптимизация CPU**

*   **Языки:** Для особо тяжелых вычислений перенос логики с GDScript на C# или C++ (через GDExtension) может дать значительный прирост.
*   **Потоки (Threads):** Используйте класс `Thread` для выноса долгих вычислений (генерация мира, сложные расчеты AI) в фоновые потоки, чтобы не блокировать основной поток игры.
    *   **Синхронизация:** Для безопасного доступа к общим данным из разных потоков используйте `Mutex` (для блокировки доступа) и `Semaphore` (для сигнализации).
    *   **Потокобезопасные API:** Взаимодействие с деревом сцен (`SceneTree`) из потока **небезопасно**. Используйте `call_deferred()`. Серверы (`RenderingServer`, `PhysicsServer`) являются потокобезопасными.
*   **Дерево Сцен:** Каждый узел имеет свою цену. Большое количество узлов (десятки тысяч) может замедлить `_process` и `_physics_process`.
*   **Физика:**
    *   Используйте простые формы коллайдеров.
    *   Уменьшайте `Physics Ticks Per Second` в настройках проекта, если высокая точность не требуется.
    *   Используйте `Fixed Timestep Interpolation` для сглаживания движения при низком тикрейте физики.

### **Глава 15.3: Оптимизация GPU**

*   **Вызовы отрисовки (Draw Calls):** Каждая отрисовка объекта — это вызов API. Их количество важно, особенно на OpenGL. Объединяйте геометрию и используйте `MultiMeshInstance3D` для их сокращения. Vulkan обрабатывает вызовы значительно быстрее.
*   **Стоимость пикселя vs. вершин:** На современных GPU стоимость обработки вершин (vertex cost) низкая, а стоимость обработки пикселей/фрагментов (pixel/fragment cost) — высокая.
    *   **Не бойтесь полигонов:** Количество полигонов не так критично, как раньше.
    *   **Бойтесь `overdraw`:** Избегайте ситуаций, когда GPU много раз рисует один и тот же пиксель (например, много слоев полупрозрачных эффектов).
*   **Шейдеры и Fillrate:** Сложные PBR-шейдеры, постобработка и тени очень требовательны к скорости заполнения (fillrate). Уменьшение разрешения окна или использование `Resolution Scaling` — эффективный способ борьбы с этим.
*   **Компиляция шейдеров:**
    *   **Проблема:** Компиляция шейдера в первый раз, когда он нужен, вызывает "заикание" (stutter).
    *   **Решение:** Godot 4.1+ использует **Ubershaders** и **Pipeline Precompilation**. Чтобы помочь движку, создайте "разогревочную" сцену, где будут показаны все основные эффекты, материалы и объекты, чтобы их шейдеры скомпилировались во время экрана загрузки.

### **Глава 15.4: Оптимизация Навигации**
*   **Парсинг геометрии:** Используйте максимально простую геометрию в качестве источника для запекания навигационного меша. Физические коллайдеры предпочтительнее визуальных мешей.
*   **Запекание (Baking):** Всегда выполняйте запекание в фоновом потоке, особенно в рантайме.
*   **Запросы пути:**
    *   Не запрашивайте новый путь на каждом кадре. Делайте это только тогда, когда цель изменилась или агент слишком далеко отклонился от текущего пути.
    *   Распределяйте запросы пути для большого количества агентов по времени (например, обновляйте путь для 1/10 агентов каждый кадр).

### **Глава 15.5: Оптимизация с помощью Серверов**
*   **Концепция:** Для максимальной производительности можно полностью обойти дерево сцен и работать напрямую с низкоуровневыми серверами: `RenderingServer`, `PhysicsServer2D`, `PhysicsServer3D`.
*   **Принцип:** Вместо узлов вы оперируете идентификаторами ресурсов (`RID`). Вы вручную создаете объекты на сервере (например, `RenderingServer.canvas_item_create()`), добавляете к ним ресурсы и обновляете их трансформации каждый кадр.
*   **Преимущества:** Устраняет все накладные расходы дерева сцен. Позволяет управлять десятками тысяч объектов.
*   **Недостатки:** Значительно сложнее в реализации, требует ручного управления всеми аспектами.
---

## **РАЗДЕЛ 16: ФИЗИКА В ДЕТАЛЯХ**

### **Глава 16.1: Объекты Столкновений**

*   **Основа:** Физика в Godot работает в фиксированном цикле (`_physics_process`) для стабильности. Все физические объекты должны иметь дочерний узел `CollisionShape2D/3D` для определения их формы. **Важно:** Не масштабируйте родительский узел физического объекта (`scale != (1, 1)`), масштабируйте сам `CollisionShape`.
*   **Слои и Маски (Layers & Masks):**
    *   **`collision_layer`:** На каком слое находится объект. Описывает, "кем" он является.
    *   **`collision_mask`:** Какие слои объект сканирует на наличие столкновений. Описывает, "с кем" он взаимодействует.
*   **Типы объектов:**
    *   **`Area2D/3D`:** Для **обнаружения** и **влияния**. Не имеет твердого тела. Обнаруживает, когда другие тела входят в него или выходят (`body_entered`, `body_exited`), и может переопределять физические свойства (гравитацию, затухание) в своей области.
    *   **`StaticBody2D/3D`:** Участвует в столкновениях, но **не движется** под действием физики. Используется для статичной геометрии уровня (стены, пол). Может двигаться, если изменять его позицию вручную (например, для движущихся платформ).
    *   **`RigidBody2D/3D`:** Полностью симулируется физическим движком. Вы **не управляете** его позицией напрямую, а **применяете силы** (импульсы, тягу, крутящий момент).
    *   **`CharacterBody2D/3D`:** Гибридный тип. Не подвержен физике напрямую, но использует ее для обнаружения столкновений. **Управляется кодом** через функции `move_and_collide` или `move_and_slide`.

### **Глава 16.2: RigidBody**
*   **Управление:** Вместо прямого изменения `position` или `linear_velocity`, используйте `apply_force()` или `apply_impulse()`. Для более тонкого контроля переопределите функцию `_integrate_forces(state)`, которая позволяет напрямую изменять состояние тела (позицию, скорость, силы) в каждом физическом кадре.
*   **Спящий режим (Sleeping):** Когда `RigidBody` перестает двигаться, он "засыпает" для экономии ресурсов CPU. Он "проснется" от столкновения или применения силы.
*   **Отчеты о контактах:** По умолчанию `RigidBody` не отслеживает столкновения. Чтобы получать информацию о них, необходимо включить `contact_monitor = true` и увеличить `max_contacts_reported`. После этого можно использовать сигнал `body_entered`.

### **Глава 16.3: CharacterBody**
*   **Движение:** Основной способ движения — `move_and_slide()`. Эта функция принимает `velocity` как аргумент, пытается переместить тело и автоматически скользит вдоль препятствий.
    *   **Важно:** `move_and_slide()` **автоматически** учитывает `delta`. Не нужно умножать скорость на `delta` перед передачей в эту функцию. `velocity` должна быть скоростью в `пикселях/юнитах в секунду`.
*   **Альтернатива:** `move_and_collide()` перемещает тело до первого столкновения и останавливается. Возвращает объект `KinematicCollision2D/3D` с информацией о столкновении, которую нужно обрабатывать вручную.

---

## **РАЗДЕЛ 17: ПРОДВИНУТЫЕ ТЕХНИКИ И ВНУТРЕННЕЕ УСТРОЙСТВО**

### **Глава 17.1: Оптимизация с помощью Серверов**
*   **Концепция:** Для максимальной производительности можно полностью обойти дерево сцен и работать напрямую с низкоуровневыми серверами: `RenderingServer`, `PhysicsServer2D`, `PhysicsServer3D`.
*   **Принцип:** Вместо узлов вы оперируете идентификаторами ресурсов (`RID`). Вы вручную создаете объекты на сервере (например, `RenderingServer.canvas_item_create()`), добавляете к ним ресурсы и обновляете их трансформации каждый кадр.
*   **Преимущества:** Устраняет все накладные расходы дерева сцен. Позволяет управлять десятками тысяч объектов.
*   **Недостатки:** Значительно сложнее в реализации, требует ручного управления всеми аспектами.

### **Глава 17.2: Анимация Тысяч Объектов (Vertex Shaders)**
*   **Проблема:** Скелетная анимация (`Skeleton3D`) обрабатывается на CPU и слишком медленная для анимации тысяч или десятков тысяч объектов (стаи птиц, косяки рыб).
*   **Решение:** Вершинная анимация.
*   **Принцип:**
    1.  Используется `MultiMeshInstance3D` для отрисовки всех объектов за один вызов.
    2.  Логика анимации (движение, вращение, изгибы) пишется непосредственно в **вершинном шейдере** (`vertex shader`), который применяется к материалу меша.
    3.  Шейдер использует встроенные переменные (`TIME`, `INSTANCE_ID`, `INSTANCE_CUSTOM`) для расчета смещения вершин. `INSTANCE_CUSTOM` позволяет задать уникальные параметры (например, сдвиг фазы анимации, скорость) для каждого отдельного экземпляра в `MultiMesh`.
*   **Результат:** Вся анимация полностью выполняется на GPU, что позволяет анимировать огромное количество объектов с минимальной нагрузкой на CPU.

### **Глава 17.3: Бинарная Сериализация (API)**
*   **Назначение:** Низкоуровневый формат, который Godot использует для сетевой передачи данных и в функциях `store_var`/`get_var`. Основан на преобразовании `Variant` в массив байтов.
*   **Спецификация пакета:** Каждый пакет данных имеет 4-байтовый заголовок, который содержит тип данных и флаги (например, `ENCODE_FLAG_64` для 64-битной точности). Далее следуют сами данные, выровненные по 4 байта.
*   **Сериализация объектов:**
    *   **`full_objects = false` (по умолчанию):** Сериализуется только `ObjectID`.
    *   **`full_objects = true`:** Сериализуется рекурсивно весь объект с его свойствами (только те, что имеют флаг `PROPERTY_USAGE_STORAGE`).
---

## **РАЗДЕЛ 11: КОНВЕЙЕР АССЕТОВ, ФАЙЛЫ И СОХРАНЕНИЯ**

### **Глава 11.1: Процесс Импорта**

#### **1. Основы**
*   **Процесс:** Когда вы добавляете внешний ассет (например, `.png`, `.fbx`, `.wav`) в папку проекта, Godot автоматически **импортирует** его. Это означает, что он создает внутреннюю, оптимизированную для движка версию этого ассета в скрытой папке `.godot/imported/`. Оригинальный файл при этом не изменяется.
*   **Файлы `.import`:** Рядом с каждым импортированным ассетом создается текстовый файл с тем же именем и расширением `.import`. В нем хранятся все настройки импорта для данного ассета. **Эти файлы необходимо добавлять в систему контроля версий (Git).**
*   **Доступ в коде:** Используйте `ResourceLoader` (или `load`/`preload`), чтобы обращаться к ассетам по их пути в `res://`. Движок автоматически подменит путь на внутренний импортированный файл. Прямой доступ через `FileAccess` к `res://` путям сломает экспорт.

#### **2. Настройка импорта**
*   **Панель "Import":** Когда вы выбираете внешний ассет в доке "FileSystem", в левой верхней панели появляется вкладка "Import", где можно изменить все параметры импорта. После изменения параметров необходимо нажать кнопку **"Reimport"**.
*   **Множественный реимпорт:** Можно выделить несколько ассетов одного типа, чтобы изменить общие для них параметры импорта и переимпортировать их все разом.
*   **Предустановки (Presets):** Можно сохранить набор настроек импорта как пресет и применять его к другим ассетам.
*   **Настройки по умолчанию:** В `Проект -> Настройки проекта... -> Import Defaults` можно задать параметры импорта по умолчанию для каждого типа ресурсов.

### **Глава 11.2: Импорт Изображений**

*   **Поддерживаемые форматы:** PNG, JPG, SVG (растеризуется при импорте), WebP, BMP, TGA, EXR, HDR, DDS, KTX.
*   **Режимы импорта (`Import As`):**
    *   **`Texture2D`:** Стандартный режим для 2D и 3D текстур.
    *   **`Image`:** Импортирует как ресурс `Image`, позволяя прямой доступ к пиксельным данным, но без оптимизаций для GPU.
    *   **`Cubemap` / `CubemapArray`:** Для скайбоксов и карт отражений.
    *   **`Texture2DArray`:** Массив 2D-текстур.
    *   **`TextureAtlas`:** Для 2D-анимации (`AnimatedSprite2D`).

#### **1. Сжатие (Compress Mode)**
| Режим | Описание | VRAM | Диск | Качество | Производительность |
| :--- | :--- | :--- | :--- | :--- | :--- |
| **Lossless** | Сжатие без потерь (WebP). | Большой | Маленький | Отличное | Нормальная |
| **Lossy** | Сжатие с потерями (WebP). | Большой | Очень мал. | Хорошее | Нормальная |
| **VRAM Compressed** | **(Рекомендуется для 3D)**. Формат, оптимизированный для GPU (S3TC/ETC2). | **Маленький** | Маленький | Среднее | **Высокая** |
| **VRAM Uncompressed** | Без сжатия VRAM. | Огромный | Большой | Отличное | Нормальная |
| **Basis Universal** | Универсальный формат сжатия для GPU. | **Маленький** | Очень мал. | Среднее | **Высокая** |

#### **2. Ключевые опции**
*   **`Mipmaps -> Generate`:** Создает уменьшенные копии текстуры для отображения на расстоянии. **Обязательно для 3D**, чтобы избежать зернистости. Увеличивает использование памяти на ~33%.
*   **`Roughness -> Mode`:** Позволяет использовать один из каналов (R, G, B, A, Gray) текстуры как карту шероховатости для PBR-материалов.
*   **`Process -> Normal Map Invert Y`:** Необходимо включать для карт нормалей, созданных в DirectX-совместимых программах (в Godot используется OpenGL-стандарт).
*   **`Compress -> Normal Map (RGTC)`:** Специальный режим сжатия для карт нормалей, который дает значительно лучшее качество, чем стандартный VRAM.

### **Глава 11.3: Импорт Аудио**

*   **Поддерживаемые форматы:**
    *   **WAV:** Без сжатия или с легким сжатием (IMA-ADPCM). Низкая нагрузка на CPU. **Рекомендуется для коротких звуковых эффектов (SFX).**
    *   **Ogg Vorbis:** Сжатие с потерями. Меньший размер файла, но выше нагрузка на CPU. **Рекомендуется для музыки и речи.**
    *   **MP3:** Сжатие с потерями. Менее эффективен, чем Ogg Vorbis (больше размер файла при том же качестве), но требует меньше ресурсов CPU для воспроизведения.
*   **Ключевые опции (WAV):**
    *   **`Edit -> Trim`:** Автоматически обрезает тишину в начале и конце файла.
    *   **`Edit -> Normalize`:** Увеличивает громкость до 0 dB.
    *   **`Loop Mode`:** Устанавливает режим зацикливания (`Disabled`, `Forward`, `Ping-Pong`, `Backward`).
    *   **`Compress -> Mode`:** Позволяет сжать WAV в формат IMA-ADPCM для уменьшения размера в памяти.
*   **Ключевые опции (Ogg/MP3):**
    *   **`Loop`:** Включает зацикливание.
    *   **`BPM`, `Beat Count`, `Bar Beats`:** Параметры для интерактивной музыки (например, в ритм-играх).
*   **Лучшие практики:**
    *   Импортируйте звуковые эффекты "сухими" (без реверберации) и добавляйте эффекты в реальном времени через шины `Audio Bus` в Godot. Это значительно экономит место.

### **Глава 11.4: Файловая Система и Сохранения**

#### **1. Пути в Godot**
*   **Разделители:** Godot всегда использует **прямой слеш (`/`)** в качестве разделителя путей на всех платформах для единообразия.
*   **`res://`:** Путь к **папке проекта**. Доступен для чтения. В экспортированной игре эта папка становится частью виртуальной файловой системы (внутри PCK-файла).
*   **`user://`:** Путь к **папке данных пользователя**. Гарантированно доступен для записи. Используется для сохранения настроек, сохранений игр и т.д. Расположение зависит от ОС (например, `%APPDATA%\Godot\app_userdata\[project_name]` на Windows).

#### **2. Загрузка и Сохранение в Рантайме**
*   **Назначение:** Для загрузки пользовательского контента (моды, кастомные текстуры). **Не используйте** для загрузки ресурсов, которые являются частью проекта.
*   **Классы:** `FileAccess`, `Image.load_from_file(path)`, `AudioStreamOggVorbis.load_from_file(path)`, `GLTFDocument`, `ZIPReader` / `ZIPPacker`.

#### **3. Фоновая загрузка (Background Loading)**
*   **Проблема:** Обычный `load()` блокирует основной поток, что приводит к "зависанию" игры во время загрузки.
*   **Решение:** `ResourceLoader`.
*   **Процесс:**
    1.  Запросить загрузку: `ResourceLoader.load_threaded_request(path)`.
    2.  Проверять статус: `ResourceLoader.load_threaded_get_status(path, progress_array)`.
    3.  Получить ресурс: `var resource = ResourceLoader.load_threaded_get(path)`.

#### **4. Сохранение Игр**
*   **JSON vs. Бинарная Сериализация:**
    *   **JSON:** Человеко-читаемый, но больше по размеру и не поддерживает все типы данных.
    *   **Бинарная:** Компактный, быстрый, поддерживает почти все типы, но не читаем. API: `FileAccess.store_var()` и `FileAccess.get_var()`.
*   **Паттерн сохранения:**
    1.  Объекты для сохранения добавляются в группу "Persist".
    2.  Каждый объект имеет метод `save()`, возвращающий словарь с его состоянием.
    3.  Главный скрипт собирает словари, сериализует их и записывает в файл в `user://`.
---

## **РАЗДЕЛ 12: ЭКСПОРТ И СЕТЕВОЕ ВЗАИМОДЕЙСТВИЕ**

### **Глава 12.1: Экспорт Проектов**

#### **1. Процесс Экспорта**
*   **Экспортные шаблоны:** Для каждой платформы (Windows, Linux, Web и т.д.) требуются свои **экспортные шаблоны**. Их можно скачать через меню `Редактор -> Управление экспортными шаблонами`.
*   **Пресеты экспорта:** В меню `Проект -> Экспорт...` создается пресет для каждой целевой платформы. В нем настраиваются иконки, версия, права, ресурсы для включения и т.д.
*   **Форматы пакетов:**
    *   **PCK (рекомендуется):** Несжатый. Больший размер, но быстрее чтение/запись.
    *   **ZIP:** Сжатый. Меньший размер, но медленнее чтение/запись.

#### **2. DLC, Патчи и Моды (PCK-файлы)**
*   **Концепция:** Godot позволяет упаковывать ресурсы в отдельные `.pck` файлы и загружать их в рантайме. Это основной механизм для создания DLC, патчей и поддержки модов.
*   **Загрузка PCK:**
    ```gdscript
    ProjectSettings.load_resource_pack("res://mods/my_mod.pck")
    ```
    После этого все ресурсы из `my_mod.pck` становятся доступны, как если бы они были частью игры.

#### **3. Feature Tags (Теги Функций)**
*   **Назначение:** Механизм для адаптации проекта под разные платформы и конфигурации сборки. Тег — это строка, определяющая наличие какой-либо функции (например, `windows`, `mobile`, `release`, `etc2`).
*   **Использование:**
    *   **В коде:** `OS.has_feature("feature_name")` позволяет выполнять разный код для разных платформ.
    *   **Переопределение настроек проекта:** В `Настройках проекта` можно переопределить любой параметр для конкретного тега (например, установить разное сжатие текстур по умолчанию для `mobile`).
    *   **В пресетах экспорта:** Можно задать кастомные теги для создания разных версий сборки (например, `demo_build`).

### **Глава 12.2: Высокоуровневый мультиплеер**

*   **API:** Основано на объекте `MultiplayerAPI` и `MultiplayerPeer`.
*   **Инициализация:**
    1.  Создается пир: `var peer = ENetMultiplayerPeer.new()`.
    2.  Пир настраивается как сервер (`peer.create_server(PORT)`) или клиент (`peer.create_client(IP, PORT)`).
    3.  Пир назначается дереву сцен: `multiplayer.multiplayer_peer = peer`.
*   **RPC (Remote Procedure Calls - Удаленный вызов процедур):**
    *   **Назначение:** Основной способ вызова функций на других компьютерах в сети.
    *   **Объявление:** Функция помечается аннотацией `@rpc`.
    *   **Вызов:** `my_node.rpc("function_name", arg1, arg2)`.
    *   **Ключевые параметры `@rpc`:**
        *   **`authority` / `any_peer`:** Кто может вызывать эту функцию.
        *   **`call_local`:** Будет ли функция вызвана и на локальном клиенте.
        *   **`reliable` / `unreliable`:** Гарантируется ли доставка пакета. `reliable` медленнее, но надежнее. `unreliable` быстрее, но пакеты могут теряться (подходит для часто обновляемых данных, вроде позиции игрока).
        *   **`channel`:** Позволяет отправлять пакеты по разным каналам для предотвращения задержек (например, чат не должен замедлять движение).

### **Глава 12.3: Низкоуровневое сетевое взаимодействие**

#### **1. HTTP-запросы**
*   **Назначение:** Для взаимодействия с веб-серверами (авторизация, таблицы лидеров, загрузка ассетов). Не подходит для игрового процесса в реальном времени.
*   **Узел:** `HTTPRequest`.
*   **Процесс:**
    1.  Подключиться к сигналу `request_completed`.
    2.  Вызвать `http_request.request("http://my-api.com/data")`.
    3.  Обработать результат в функции, подключенной к сигналу. Данные приходят в виде `PackedByteArray`, который нужно преобразовать в строку (`body.get_string_from_utf8()`).

#### **2. WebSocket**
*   **Назначение:** Протокол для постоянного двунаправленного соединения. Хорошо подходит для чатов, пошаговых игр. Недостаточно быстр для игр в реальном времени.
*   **Классы:** `WebSocketPeer` (клиент), `WebSocketServer` (сервер).
*   **Процесс:**
    1.  Клиент создает `WebSocketPeer` и вызывает `socket.connect_to_url(url)`.
    2.  Сервер создает `WebSocketServer` и вызывает `server.listen(port)`.
    3.  В `_process()` обе стороны вызывают `poll()` для обработки событий.
    4.  Данные отправляются через `put_packet()` и принимаются через `get_packet()`.

#### **3. WebRTC**
*   **Назначение:** Технология для прямого peer-to-peer (P2P) соединения между клиентами с низкой задержкой. Идеально для быстрых мультиплеерных игр.
*   **Принцип:** Клиенты сначала подключаются к **сигнальному серверу** (Signaling Server), обмениваются через него информацией о соединении (SDP, ICE candidates), а затем устанавливают прямое соединение друг с другом.
*   **Классы:** `WebRTCPeerConnection`, `WebRTCDataChannel`.

#### **4. TLS/SSL Сертификаты**
*   **Назначение:** Обеспечение безопасного (шифрованного) соединения для `HTTPClient`, `HTTPRequest` и `WebSocket`.
*   **Использование:** Godot по умолчанию использует системные сертификаты. Можно указать свой собственный `.crt` бандл в `Настройках проекта -> Network -> TLS`.
---

## **РАЗДЕЛ 13: МАТЕМАТИКА И ЛОКАЛИЗАЦИЯ**

### **Глава 13.1: Векторная Математика**

*   **Вектор:** Представляет направление и величину (длину). Не имеет позиции.
*   **Операции:** Сложение, вычитание, умножение/деление на скаляр (число).
*   **Применение:**
    *   **Движение:** `new_position = old_position + velocity * delta`.
    *   **Направление:** `vector_to_target = target_position - current_position`.
*   **Единичный вектор (Unit Vector):** Вектор с длиной `1`. Используется для представления чистого направления. Получается **нормализацией** (`vector.normalized()`).
*   **Скалярное произведение (Dot Product): `dot_product = a.dot(b)`**
    *   **Результат:** Скаляр (число).
    *   **Интерпретация:** Показывает, насколько векторы "смотрят" в одном направлении.
        *   `> 0`: Угол < 90°.
        *   `= 0`: Угол = 90° (перпендикулярны).
        *   `< 0`: Угол > 90°.
    *   **Применение:** Проверка, находится ли враг в поле зрения.
*   **Векторное произведение (Cross Product): `cross_product = a.cross(b)` (только в 3D)**
    *   **Результат:** Вектор, перпендикулярный обоим исходным векторам.
    *   **Применение:** Вычисление нормали поверхности по трем точкам.

### **Глава 13.2: Продвинутая Векторная Математика (Плоскости)**
*   **Плоскость (Plane):** Бесконечная поверхность, которая делит 3D-пространство на два полупространства (положительное и отрицательное).
*   **Определение:** Задается нормалью (единичным вектором `N`) и расстоянием от начала координат (`D`).
*   **Применение:**
    *   **Определение расстояния до точки:** `distance = plane.distance_to(point)`. Знак результата показывает, с какой стороны от плоскости находится точка.
    *   **Проверка принадлежности к объему:** Если точка имеет отрицательное расстояние до всех плоскостей, образующих выпуклый многогранник, значит, она находится внутри него.
    *   **Обнаружение столкновений (SAT):** Теорема о разделяющей оси, используемая в физических движках, основана на поиске плоскости, разделяющей два выпуклых объекта.

### **Глава 13.3: Матрицы и Трансформации**

*   **Матрица:** В Godot матрицы используются для представления трансформаций (вращение, масштабирование).
*   **`Transform2D`:** Состоит из двух векторов (`x`, `y`), представляющих базисные векторы, и `origin` для позиции.
*   **`Transform3D`:** Состоит из `Basis` (три вектора `x`, `y`, `z`) и `origin`.
*   **Применение трансформаций:** Трансформации применяются к дочерним узлам путем умножения: `global_transform = parent.global_transform * child.transform`. Порядок важен.
*   **Инверсия:** `transform.affine_inverse()` возвращает обратную трансформацию, которая "отменяет" действие исходной.

### **Глава 13.4: Интерполяция и Кривые**

*   **Интерполяция:** Нахождение промежуточных значений между двумя точками.
*   **`lerp(from, to, weight)`:** Линейная интерполяция. `weight` от 0.0 до 1.0.
*   **Сглаженное движение:** `position = position.lerp(target_position, weight)`. Если `weight` — это константа, умноженная на `delta`, объект будет плавно замедляться по мере приближения к цели.
*   **Кривые Безье:** Математические кривые, определяемые набором точек. В Godot представлены ресурсами `Curve2D`, `Curve3D` и узлами `Path2D`, `Path3D`.
*   **Движение по кривой:** `Curve3D.sample_baked(offset)` позволяет получить точку на кривой на определенном расстоянии от начала, обеспечивая движение с постоянной скоростью.

### **Глава 13.5: Генерация Случайных Чисел**

*   **Глобальные функции:**
    *   `randi()`: Случайное целое.
    *   `randf()`: Случайное float от 0.0 до 1.0.
    *   `randi_range(from, to)`: Случайное целое в диапазоне.
    *   `randf_range(from, to)`: Случайное float в диапазоне.
*   **`RandomNumberGenerator` класс:** Предоставляет больше контроля, позволяет создавать несколько независимых генераторов с собственным `seed`.
*   **Инициализация (`randomize()`):** В Godot 4+ вызывается автоматически при старте. Ручной вызов нужен только для сброса `seed`.
*   **Шум (Noise):** `FastNoiseLite` используется для генерации процедурного "естественного" шума, полезного для генерации ландшафтов, текстур и т.д.
*   **Криптографическая случайность:** `Crypto` класс используется, когда требуется высокий уровень непредсказуемости (не для геймплея).

### **Глава 13.6: Интернационализация (i18n)**

*   **Концепция:** Процесс адаптации игры для разных языков и культурных особенностей.
*   **Форматы переводов:**
    *   **CSV:** Простой формат. Каждая строка: `ключ,перевод_en,перевод_es,...`.
    *   **gettext (`.po`, `.mo`):** Стандарт индустрии. Более мощный, поддерживает контексты и формы множественного числа.
*   **Процесс:**
    1.  **Настройка:** В `Проект -> Настройки проекта... -> Localization` добавляются файлы с переводами.
    2.  **Использование в коде:** Текст оборачивается в функцию `tr("KEY_TO_TRANSLATE")`.
    3.  **Автоматический перевод:** Для `Control`-узлов (Label, Button) можно просто вписать ключ в поле `text`, и он будет переведен автоматически.
*   **Локализация ресурсов:** В `Настройках проекта -> Localization -> Remaps` можно настроить замену одних ресурсов другими в зависимости от текущего языка (например, заменять текстуры с английским текстом на текстуры с испанским).
---

## **РАЗДЕЛ 14: НАВИГАЦИЯ**

### **Глава 14.1: Основы Навигации**

*   **Назначение:** Системы навигации позволяют объектам (агентам) находить путь из одной точки в другую, обходя препятствия.
*   **Два основных подхода:**
    *   **На основе сетки (Grid-based):** `AStar2D`, `AStarGrid2D`. Агент может двигаться только между предопределенными точками или ячейками сетки. Быстро и просто, идеально для пошаговых игр или игр с движением по тайлам.
    *   **На основе меша (Mesh-based):** `NavigationServer`. Агент может свободно перемещаться в пределах полигональной области (навигационного меша). Более гибкий и мощный подход, подходит для игр в реальном времени.

### **Глава 14.2: Навигация на основе Меша (`NavigationServer`)**

#### **1. Ключевые компоненты**
*   **`NavigationServer2D/3D`:** Низкоуровневый сервер, который управляет всеми навигационными данными и расчетами. Обычно с ним взаимодействуют через узлы-хелперы.
*   **`NavigationRegion2D/3D`:** Узел, который определяет область для навигации. Содержит ресурс навигационного меша.
*   **`NavigationMesh` / `NavigationPolygon`:** Ресурс, хранящий геометрию проходимой области. Может быть "запечен" (Bake) из геометрии дочерних узлов или нарисован вручную.
*   **`NavigationAgent2D/3D`:** Узел-компонент, который добавляется к движущемуся объекту (`CharacterBody2D/3D`). Он запрашивает путь у `NavigationServer` и предоставляет следующую точку для движения. **Агент не двигает объект сам**, он лишь предоставляет информацию. Движение реализуется в скрипте родительского узла.
*   **`NavigationObstacle2D/3D`:** Узел для динамических препятствий. Агенты будут пытаться его обойти.
*   **`NavigationLink2D/3D`:** Позволяет вручную соединять две точки на разных навигационных мешах (например, для прыжка через пропасть или использования телепорта).

#### **2. Процесс поиска пути с `NavigationAgent`**
1.  **Настройка сцены:**
    *   Создается `NavigationRegion` с `NavigationMesh`/`Polygon`.
    *   Геометрия "запекается" в навигационный меш.
    *   К `CharacterBody` добавляется `NavigationAgent`.
2.  **Работа в скрипте:**
    *   В `_ready()` дожидаемся синхронизации сервера (`await get_tree().physics_frame`).
    *   Задаем цель для агента: `navigation_agent.target_position = target_global_position`.
    *   В `_physics_process()`:
        *   Проверяем, не достигнут ли конец пути: `if navigation_agent.is_navigation_finished(): return`.
        *   Получаем следующую точку пути: `var next_path_position = navigation_agent.get_next_path_position()`.
        *   Вычисляем вектор скорости: `var new_velocity = global_position.direction_to(next_path_position) * speed`.
        *   Двигаем персонажа: `velocity = new_velocity; move_and_slide()`.

#### **3. Избегание столкновений (Avoidance)**
*   `NavigationAgent` также управляет избеганием столкновений с другими агентами и препятствиями.
*   **Процесс:**
    1.  Включается `navigation_agent.avoidance_enabled = true`.
    2.  Подписываемся на сигнал `velocity_computed(safe_velocity)`.
    3.  В `_physics_process()` **не устанавливаем** `velocity` напрямую, а вызываем `navigation_agent.set_velocity(desired_velocity)`.
    4.  `NavigationServer` вычислит безопасную скорость с учетом других агентов и испустит сигнал `velocity_computed`.
    5.  В обработчике сигнала мы применяем эту `safe_velocity` для движения через `move_and_slide()`.

#### **4. Синхронизация и Потоки**
*   `NavigationServer` является потокобезопасным, но все изменения (добавление регионов, агентов) применяются только в конце физического кадра.
*   При запросе пути сразу после изменения навигационной карты, путь может быть неверным. Необходимо дождаться следующего физического кадра (`await get_tree().physics_frame`).
*   **Отладка:** В меню `Debug` можно включить `Visible Navigation` для визуализации навигационных мешей и путей в запущенной игре.
---

## **РАЗДЕЛ 15: ОПТИМИЗАЦИЯ ПРОИЗВОДИТЕЛЬНОСТИ**

### **Глава 15.1: Общие Принципы**

*   **"Преждевременная оптимизация — корень всех зол"**: Не оптимизируйте код, который и так работает быстро. Сконцентрируйтесь на реальных "узких местах".
*   **Процесс оптимизации:**
    1.  **Профилирование:** Используйте профилировщик, чтобы найти самые медленные части кода/рендеринга.
    2.  **Оптимизация:** Улучшите найденное "узкое место".
    3.  **Возврат к шагу 1:** Повторяйте, пока производительность не станет приемлемой.
*   **Инструменты для измерения:**
    *   **Встроенный профилировщик Godot:** `Отладчик -> Профилировщик`.
    *   **Внешние профилировщики:** NVIDIA Nsight, AMD uProf, Intel VTune.
    *   **Измерение вручную:** `Time.get_ticks_usec()` для замера времени выполнения участков кода.

### **Глава 15.2: Оптимизация CPU**

*   **Языки:** Для особо тяжелых вычислений перенос логики с GDScript на C# или C++ (через GDExtension) может дать значительный прирост.
*   **Потоки (Threads):** Используйте класс `Thread` для выноса долгих вычислений (генерация мира, сложные расчеты AI) в фоновые потоки, чтобы не блокировать основной поток игры.
    *   **Синхронизация:** Для безопасного доступа к общим данным из разных потоков используйте `Mutex` (для блокировки доступа) и `Semaphore` (для сигнализации).
    *   **Потокобезопасные API:** Взаимодействие с деревом сцен (`SceneTree`) из потока **небезопасно**. Используйте `call_deferred()`. Серверы (`RenderingServer`, `PhysicsServer`) являются потокобезопасными.
*   **Дерево Сцен:** Каждый узел имеет свою цену. Большое количество узлов (десятки тысяч) может замедлить `_process` и `_physics_process`.
*   **Физика:**
    *   Используйте простые формы коллайдеров.
    *   Уменьшайте `Physics Ticks Per Second` в настройках проекта, если высокая точность не требуется.
    *   Используйте `Fixed Timestep Interpolation` для сглаживания движения при низком тикрейте физики.

### **Глава 15.3: Оптимизация GPU**

*   **Вызовы отрисовки (Draw Calls):** Каждая отрисовка объекта — это вызов API. Их количество важно, особенно на OpenGL. Объединяйте геометрию и используйте `MultiMeshInstance3D` для их сокращения. Vulkan обрабатывает вызовы значительно быстрее.
*   **Стоимость пикселя vs. вершин:** На современных GPU стоимость обработки вершин (vertex cost) низкая, а стоимость обработки пикселей/фрагментов (pixel/fragment cost) — высокая.
    *   **Не бойтесь полигонов:** Количество полигонов не так критично, как раньше.
    *   **Бойтесь `overdraw`:** Избегайте ситуаций, когда GPU много раз рисует один и тот же пиксель (например, много слоев полупрозрачных эффектов).
*   **Шейдеры и Fillrate:** Сложные PBR-шейдеры, постобработка и тени очень требовательны к скорости заполнения (fillrate). Уменьшение разрешения окна или использование `Resolution Scaling` — эффективный способ борьбы с этим.
*   **Компиляция шейдеров:**
    *   **Проблема:** Компиляция шейдера в первый раз, когда он нужен, вызывает "заикание" (stutter).
    *   **Решение:** Godot 4.1+ использует **Ubershaders** и **Pipeline Precompilation**. Чтобы помочь движку, создайте "разогревочную" сцену, где будут показаны все основные эффекты, материалы и объекты, чтобы их шейдеры скомпилировались во время экрана загрузки.

### **Глава 15.4: Оптимизация Навигации**
*   **Парсинг геометрии:** Используйте максимально простую геометрию в качестве источника для запекания навигационного меша. Физические коллайдеры предпочтительнее визуальных мешей.
*   **Запекание (Baking):** Всегда выполняйте запекание в фоновом потоке, особенно в рантайме.
*   **Запросы пути:**
    *   Не запрашивайте новый путь на каждом кадре. Делайте это только тогда, когда цель изменилась или агент слишком далеко отклонился от текущего пути.
    *   Распределяйте запросы пути для большого количества агентов по времени (например, обновляйте путь для 1/10 агентов каждый кадр).

### **Глава 15.5: Оптимизация с помощью Серверов**
*   **Концепция:** Для максимальной производительности можно полностью обойти дерево сцен и работать напрямую с низкоуровневыми серверами: `RenderingServer`, `PhysicsServer2D`, `PhysicsServer3D`.
*   **Принцип:** Вместо узлов вы оперируете идентификаторами ресурсов (`RID`). Вы вручную создаете объекты на сервере (например, `RenderingServer.canvas_item_create()`), добавляете к ним ресурсы и обновляете их трансформации каждый кадр.
*   **Преимущества:** Устраняет все накладные расходы дерева сцен. Позволяет управлять десятками тысяч объектов.
*   **Недостатки:** Значительно сложнее в реализации, требует ручного управления всеми аспектами.
---

## **РАЗДЕЛ 16: ФИЗИКА**

### **Глава 16.1: Объекты Столкновений**

*   **Основа:** Физика в Godot работает в фиксированном цикле (`_physics_process`) для стабильности. Все физические объекты должны иметь дочерний узел `CollisionShape2D/3D` для определения их формы. **Важно:** Не масштабируйте родительский узел физического объекта (`scale != (1, 1)`), масштабируйте сам `CollisionShape`.
*   **Слои и Маски (Layers & Masks):**
    *   **`collision_layer`:** На каком слое находится объект. Описывает, "кем" он является.
    *   **`collision_mask`:** Какие слои объект сканирует на наличие столкновений. Описывает, "с кем" он взаимодействует.
*   **Типы объектов:**
    *   **`Area2D/3D`:** Для **обнаружения** и **влияния**. Не имеет твердого тела. Обнаруживает, когда другие тела входят в него или выходят (`body_entered`, `body_exited`), и может переопределять физические свойства (гравитацию, затухание) в своей области.
    *   **`StaticBody2D/3D`:** Участвует в столкновениях, но **не движется** под действием физики. Используется для статичной геометрии уровня (стены, пол). Может двигаться, если изменять его позицию вручную (например, для движущихся платформ).
    *   **`RigidBody2D/3D`:** Полностью симулируется физическим движком. Вы **не управляете** его позицией напрямую, а **применяете силы** (импульсы, тягу, крутящий момент).
    *   **`CharacterBody2D/3D`:** Гибридный тип. Не подвержен физике напрямую, но использует ее для обнаружения столкновений. **Управляется кодом** через функции `move_and_collide` или `move_and_slide`.

### **Глава 16.2: RigidBody**
*   **Управление:** Вместо прямого изменения `position` или `linear_velocity`, используйте `apply_force()` или `apply_impulse()`. Для более тонкого контроля переопределите функцию `_integrate_forces(state)`, которая позволяет напрямую изменять состояние тела (позицию, скорость, силы) в каждом физическом кадре.
*   **Спящий режим (Sleeping):** Когда `RigidBody` перестает двигаться, он "засыпает" для экономии ресурсов CPU. Он "проснется" от столкновения или применения силы.
*   **Отчеты о контактах:** По умолчанию `RigidBody` не отслеживает столкновения. Чтобы получать информацию о них, необходимо включить `contact_monitor = true` и увеличить `max_contacts_reported`. После этого можно использовать сигнал `body_entered`.

### **Глава 16.3: CharacterBody**
*   **Движение:** Основной способ движения — `move_and_slide()`. Эта функция принимает `velocity` как аргумент, пытается переместить тело и автоматически скользит вдоль препятствий.
    *   **Важно:** `move_and_slide()` **автоматически** учитывает `delta`. Не нужно умножать скорость на `delta` перед передачей в эту функцию. `velocity` должна быть скоростью в `пикселях/юнитах в секунду`.
*   **Альтернатива:** `move_and_collide()` перемещает тело до первого столкновения и останавливается. Возвращает объект `KinematicCollision2D/3D` с информацией о столкновении, которую нужно обрабатывать вручную.

### **Глава 16.4: Формы Столкновений (Collision Shapes)**
*   **Примитивы:** Простые и быстрые формы (`BoxShape3D`, `SphereShape3D`, `CapsuleShape3D`, `RectangleShape2D`). Рекомендуются для динамических объектов.
*   **Выпуклые (Convex):** `ConvexPolygonShape3D`. Могут представлять любую выпуклую форму. Медленнее примитивов. Можно сгенерировать из меша.
*   **Вогнутые / Тримеш (Concave / Trimesh):** `ConcavePolygonShape3D`. Самые точные, могут повторять любую геометрию. Самые медленные. **Можно использовать только для `StaticBody`**.

### **Глава 16.5: Продвинутые Темы Физики**
*   **Jolt Physics:** Альтернативный 3D физический движок, встроенный в Godot 4.4+. Считается более производительным и стабильным для сложных симуляций, но является экспериментальным. Включается в `Настройках проекта -> Physics -> 3D`.
*   **Ray-casting:** "Пускание луча" для проверки столкновений. Используется узел `RayCast2D/3D` или напрямую `PhysicsDirectSpaceState`.
*   **Ragdoll:** Система процедурной анимации на основе физики, обычно для симуляции падения/смерти. Создается из `Skeleton3D` с помощью узлов `PhysicalBone3D`.
*   **SoftBody:** Симуляция мягких тел (ткань, желе). Используется узел `SoftBody3D`.
*   **Большие миры (Large World Coordinates):** Для игр с огромными мирами (космические симуляторы) можно включить использование 64-битных чисел (double) для физических расчетов, чтобы избежать проблем с потерей точности на больших расстояниях от центра координат. Это требует кастомной сборки движка.
*   **Физическая интерполяция:** Техника для сглаживания движения физических объектов, когда частота кадров рендеринга не совпадает с частотой физических тиков. Включается в `Настройках проекта`.
---

## **РАЗДЕЛ 17: АНИМАЦИЯ (ПРОДОЛЖЕНИЕ)**

### **Глава 17.1: AnimationPlayer: Продвинутые Функции**

#### **1. Редактирование и Настройка**
*   **RESET-анимация:** Специальная анимация с именем "RESET" (регистрозависимо), которая хранит "позу по умолчанию" для объекта. Она автоматически применяется при старте игры (если включено `Reset On Save`), чтобы гарантировать, что объект находится в правильном состоянии перед началом других анимаций.
*   **Onion Skinning ("Калька"):** Позволяет видеть полупрозрачные "призраки" объекта из предыдущих и последующих кадров, что упрощает создание плавной анимации.
*   **Animation Markers (Маркеры):** Позволяют именовать определенные участки временной шкалы и воспроизводить только их с помощью `play_section()`.

#### **2. Настройки Дорожек (Track Settings)**
*   **Update Mode (Режим обновления):**
    *   **`Continuous`:** Свойство обновляется на каждом кадре (стандартно).
    *   **`Discrete`:** Свойство меняется скачком только в момент ключевого кадра.
    *   **`Capture`:** Захватывает текущее значение свойства и плавно переходит от него к первому ключу. Полезно для динамических переходов.
*   **Interpolation (Интерполяция):**
    *   **`Nearest`:** Без интерполяции.
    *   **`Linear`:** Линейная интерполяция (постоянная скорость).
    *   **`Cubic`:** Кубическая интерполяция (с ускорением и замедлением).
*   **Loop Mode (Режим зацикливания):**
    *   **`None`:** Анимация останавливается в конце.
    *   **`Linear`:** Анимация повторяется с начала.
    *   **`Ping-Pong`:** Анимация проигрывается вперед, а затем назад.

### **Глава 17.2: Типы Дорожек (Track Types)**
`AnimationPlayer` поддерживает различные типы дорожек для специальных задач:

*   **`Property Track`:** Стандартная дорожка для анимации любого свойства.
*   **`3D Position/Rotation/Scale Track`:** Оптимизированные дорожки для анимации трансформаций 3D-объектов.
*   **`Blend Shape Track`:** Для анимации морфинга (blend shapes) у `MeshInstance3D`.
*   **`Call Method Track`:** Позволяет вызвать метод любого узла в определенный момент времени. Ключевой кадр на этой дорожке хранит имя метода и его аргументы. Используется для синхронизации событий с анимацией (например, звук шага в момент касания ногой земли, вызов `queue_free()` в конце анимации смерти).
*   **`Bezier Curve Track`:** Позволяет анимировать float-свойство с помощью кривой Безье, давая полный контроль над кривой изменения значения.
*   **`Audio Playback Track`:** Для проигрывания звука из узла `AudioStreamPlayer`. Ключевой кадр на дорожке запускает воспроизведение.
*   **`Animation Playback Track`:** Позволяет управлять другим `AnimationPlayer` из текущей анимации. Используется для создания сложных последовательностей и кат-сцен.

### **Глава 17.3: 2D Скелетная Анимация**

#### **1. Cutout Animation (Перекладная анимация)**
*   **Концепция:** Техника, при которой персонаж составляется из отдельных спрайтов (частей тела), которые затем анимируются путем изменения их трансформаций (вращение, перемещение).
*   **Создание рига (Rig):**
    1.  **Иерархия:** Части тела выстраиваются в иерархию "родитель-потомок". Корнем скелета обычно является таз (`hip`).
    2.  **Точка вращения (Pivot):** Для каждого спрайта (`Sprite2D`) необходимо правильно выставить точку вращения, смещая свойство `Offset`.
    3.  **Порядок отрисовки:** Для управления тем, какая часть тела находится "спереди", а какая "сзади", используется либо `z_index`, либо свойство `Show Behind Parent`, либо узел `RemoteTransform2D`.
*   **Скелеты (`Skeleton2D`):** Упрощают анимацию ригов и позволяют использовать инверсную кинематику (IK).
*   **Инверсная кинематика (IK Chain):**
    *   **Назначение:** Позволяет анимировать конечности, двигая только конечную точку (например, кисть или стопу).
    *   **Ограничение:** В Godot IK-цепи работают **только в редакторе** для упрощения расстановки ключевых кадров и **не работают в рантайме**.

#### **2. Skeletal Deform (Скелетная деформация)**
*   **Концепция:** Вместо набора отдельных спрайтов используется одно цельное изображение персонажа, которое деформируется с помощью скелета (`Skeleton2D` и `Bone2D`).
*   **Процесс:**
    1.  **Создание полигона:** С помощью `Polygon2D` создается полигон, повторяющий контур персонажа на текстуре.
    2.  **Создание скелета:** Создается иерархия узлов `Bone2D`.
    3.  **Привязка:** `Polygon2D` привязывается к `Skeleton2D`.
    4.  **Раскраска весов (Weight Painting):** В UV-редакторе для `Polygon2D` каждая вершина полигона "раскрашивается", чтобы определить, какая кость и с какой силой на нее влияет.
    5.  **Внутренние вершины:** Для более качественных и естественных сгибов в полигон добавляются внутренние вершины.

### **Глава 17.4: AnimationTree (Дерево Анимаций)**

*   **Назначение:** Узел для продвинутого управления анимациями из `AnimationPlayer`. Позволяет смешивать (blending) анимации, создавать сложные переходы и управлять ими через конечный автомат (State Machine).
*   **Принцип:** `AnimationTree` не содержит анимаций. Он подключается к `AnimationPlayer` и использует его анимации как "сырье".

#### **1. Ключевые ноды AnimationTree:**
*   **`AnimationNodeAnimation`:** Просто проигрывает одну анимацию.
*   **`AnimationNodeBlend2` / `Blend3`:** Смешивает 2 или 3 анимации на основе одного float-параметра.
*   **`AnimationNodeBlendSpace1D` / `BlendSpace2D`:** Продвинутое смешивание на 1D или 2D-пространстве (например, для смешивания ходьбы в 8 направлениях).
*   **`AnimationNodeStateMachine` (Конечный автомат):** Позволяет создавать состояния ("Idle", "Walk") и настраивать правила перехода между ними. Стандартный подход для анимаций персонажа.
*   **`AnimationNodeOneShot`:** Проигрывает одну анимацию (выстрел, уворот) поверх текущего состояния.
*   **`AnimationNodeTransition`:** Простой переключатель между анимациями.

#### **2. Управление из кода**
*   Управление `AnimationTree` происходит через установку его параметров:
    ```gdscript
    # Установить значение для Blend2
    animation_tree["parameters/my_blend_node/blend_amount"] = 0.5
    # Переключить состояние в StateMachine
    var state_machine = animation_tree["parameters/playback"]
    state_machine.travel("jump_state")
    ```

#### **3. Root Motion (Движение корня)**
*   **Концепция:** Техника, при которой движение персонажа в мире (`CharacterBody3D`) управляется смещением корневой кости в самой анимации.
*   **Применение:** В коде из `AnimationTree` извлекается дельта трансформации корневой кости (`get_root_motion_...()`) и применяется к `CharacterBody3D` через `move_and_slide()`.
---
## **РАЗДЕЛ 18: СВОДКА ДОПОЛНИТЕЛЬНЫХ ТЕМ**

### **Глава 18.1: Паттерны Проектирования (Сводка)**

*   **Декомпозиция:** Создание независимых, самодостаточных сцен для ключевых сущностей (`Player`, `Enemy`, `HUD`), которые затем объединяются в главную сцену (`Main`) путем инстанциирования.
*   **Делегирование событий:** Дочерние узлы (`Player`, `Enemy`) не управляют напрямую главным циклом. Вместо этого они испускают сигналы (`hit`, `squashed`). Главная сцена (`Main`) подписывается на эти сигналы и централизованно управляет состоянием игры (счет, Game Over).
*   **Паттерн "Pivot" для 3D-персонажа:**
    *   **Структура:** `CharacterBody3D` -> `Pivot (Node3D)` -> `Визуал (MeshInstance3D)`.
    *   **Назначение:** Позволяет коду двигать `CharacterBody3D`, а `AnimationPlayer` или код могут независимо вращать `Pivot` для анимации и направления взгляда, избегая конфликтов.
*   **Паттерн "Хитбокс":**
    *   **Структура:** Основное тело (`CharacterBody`) для столкновений с миром + дочерний узел `Area` для обнаружения урона.
    *   **Назначение:** Разделяет физику движения от логики получения урона.

### **Глава 18.2: Игровой Цикл (Сводка)**

*   **Динамический спавн:** Экспортировать `PackedScene`, создавать экземпляр через `.instantiate()`, настраивать и добавлять в сцену через `add_child()`.
*   **Перезапуск уровня:** `get_tree().reload_current_scene()`.
*   **Задержки в коде:** Использовать `await get_tree().create_timer(time_sec).timeout` для создания одноразовой асинхронной задержки.
---

## **РАЗДЕЛ 18: ПЛАТФОРМЫ И ПЛАГИНЫ**

### **Глава 18.1: Платформо-специфичные Функции**

#### **1. Web (HTML5)**
*   **JavaScriptBridge:** Синглтон для взаимодействия между GDScript/C# и JavaScript в веб-сборках.
    *   `JavaScriptBridge.eval()`: Выполняет код JavaScript из Godot.
    *   `JavaScriptBridge.create_callback()`: Создает ссылку на функцию Godot, которую можно вызвать из JavaScript.
    *   `JavaScriptBridge.get_interface()`: Получает доступ к глобальным объектам JavaScript (например, `window`, `console`).
*   **Кастомная HTML-страница:** Можно создать свою HTML-страницу-обертку для веб-экспорта. Это позволяет добавлять кастомные CSS, JavaScript-библиотеки и полностью контролировать процесс запуска движка.
*   **HTML5 Shell Class:** JavaScript-класс `Engine`, который позволяет управлять жизненным циклом движка извне (загрузка, инициализация, запуск).

#### **2. Android**
*   **Godot Android Library (.AAR):** Позволяет встраивать экземпляр Godot в нативное Android-приложение. Это дает возможность использовать Godot для рендеринга 3D-моделей или как часть сложного UI, управляя им из Kotlin/Java кода.
*   **Android-плагины (v2):** Основной способ расширения функциональности Godot на Android. Плагин — это Android-библиотека (`.aar`), которая может:
    *   Взаимодействовать с нативными API Android (Bluetooth, GPS и т.д.).
    *   Интегрировать Java/Kotlin библиотеки.
    *   Вызывать GDExtension.
    *   Плагины регистрируются как синглтоны в Godot, и их методы можно вызывать из GDScript.
*   **Внутриигровые покупки (In-App Purchases):** Реализуются через официальный Android-плагин `GodotGooglePlayBilling`, который является оберткой над Google Play Billing Library. Он предоставляет API для запроса продуктов, совершения покупок, обработки расходных материалов и подписок.

#### **3. Консоли**
*   **Официальная поддержка:** Godot официально поддерживает только **Steam Deck** (через Linux-экспорт).
*   **Сторонние порты:** Из-за лицензионных ограничений и NDA, портирование на другие консоли (PlayStation, Xbox, Nintendo Switch) осуществляется сторонними компаниями. Для доступа к экспортным шаблонам и SDK необходимо заключить с ними договор.

### **Глава 18.2: Расширение Редактора (Плагины)**

#### **1. Основы**
*   **Назначение:** Плагины позволяют расширять функциональность редактора Godot с помощью GDScript.
*   **Структура:** Плагин состоит из файла конфигурации `plugin.cfg` и основного скрипта, который наследуется от `EditorPlugin`. Любой скрипт плагина должен иметь аннотацию `@tool` в начале.
*   **Управление:** Плагины размещаются в папке `addons/` и включаются/выключаются в `Проект -> Настройки проекта... -> Plugins`.

#### **2. Типы Плагинов**
*   **Кастомные ноды (`add_custom_type`):** Позволяет зарегистрировать сцену или скрипт как новый тип узла, который появится в диалоге "Create New Node".
*   **Кастомные доки (`add_control_to_dock`):** Добавляет новую панель (док) в интерфейс редактора.
*   **Плагины для главного экрана (`has_main_screen`):** Добавляют новую полноэкранную рабочую область, доступную по кнопке вверху редактора (рядом с "2D", "3D", "Script").
*   **Плагины импорта (`EditorImportPlugin`):** Позволяют создавать кастомные импортеры для проприетарных или неподдерживаемых форматов файлов.
*   **Плагины для гизмо (`EditorNode3DGizmoPlugin`):** Позволяют создавать кастомные 3D- gizmo для `Node3D`-наследников, которые появляются во вьюпорте при выделении узла.
*   **Плагины для инспектора (`EditorInspectorPlugin`):** Позволяют добавлять кастомные элементы управления (виджеты) в Инспектор для определенных свойств или типов объектов.

#### **3. Запуск кода в редакторе (`@tool`)**
*   **Аннотация `@tool`:** Заставляет скрипт выполняться не только в игре, но и в редакторе Godot.
*   **Разделение логики:** Используйте `Engine.is_editor_hint()` для проверки, где сейчас выполняется код (в редакторе или в запущенной игре), чтобы разделить логику.
*   **Применение:** Визуализация данных (например, пути патрулирования AI), процедурная генерация уровней прямо в редакторе, создание вспомогательных инструментов.
*   **`EditorScript`:** Скрипт, который наследуется от `EditorScript`, можно запустить один раз как утилиту через меню `Файл -> Запустить в редакторе`. Не требует создания полноценного плагина.
---

## **РАЗДЕЛ 19: ПРОДВИНУТЫЙ РЕНДЕРИНГ И ФИЗИКА**

### **Глава 19.1: Viewports (Окна вывода)**

*   **Концепция:** `Viewport` — это "экран", на который проецируется игра. Корневой узел дерева сцены — это корневой `Viewport`.
*   **`SubViewport` (Подокно):** Узел `Viewport`, добавленный в сцену. Он позволяет рендерить одну часть сцены независимо от другой.
*   **Применение `SubViewport`:**
    *   **Картинка-в-картинке:** Отображение вида с другой камеры (например, зеркало заднего вида).
    *   **3D в 2D:** Отображение 3D-модели в 2D-интерфейсе.
    *   **2D в 3D:** Отображение 2D-интерфейса на 3D-поверхности (например, экран монитора в игре).
    *   **Динамические текстуры:** Содержимое `SubViewport` можно получить как текстуру (`ViewportTexture`) и использовать в материалах, шейдерах и т.д.

### **Глава 19.2: Адаптация под Разные Разрешения**

*   **Базовый размер:** В `Настройках проекта -> Display -> Window` устанавливается базовое разрешение, под которое проектируется игра.
*   **Режим растяжения (`Stretch Mode`):**
    *   **`disabled`:** Нет растяжения. 1 игровой юнит = 1 пиксель.
    *   **`canvas_items`:** Растягивается только 2D-контент. 3D рендерится в нативном разрешении.
    *   **`viewport`:** Растягивается все окно вывода. Рендеринг происходит в базовом разрешении, а затем результат масштабируется. Самый производительный режим.
*   **Сохранение пропорций (`Stretch Aspect`):**
    *   **`ignore`:** Изображение искажается, заполняя все окно.
    *   **`keep`:** Сохраняет пропорции, добавляя черные полосы по бокам (letterboxing/pillarboxing).
    *   **`keep_width` / `keep_height`:** Сохраняет пропорции, расширяя видимую область по одной из осей.
    *   **`expand`:** Сохраняет пропорции и масштабируется, чтобы заполнить экран, обрезая часть изображения.

### **Глава 19.3: Устранение Проблем с Рендерингом**

*   **Jitter (Дрожание):** Легкое, постоянное подрагивание. Обычно возникает из-за рассинхронизации физического тикрейта (по умолчанию 60 Гц) и частоты обновления монитора. Решается использованием **физической интерполяции**.
*   **Stutter (Заикание):** Резкие, нерегулярные "замирания" или "откаты" кадра. Причины:
    *   **Падение производительности:** Игра не успевает подготовить кадр вовремя. Решение — оптимизация.
    *   **Системные проблемы:** ОС, драйверы, фоновые процессы. Включение `Exclusive Fullscreen` и отключение V-Sync может помочь.
*   **Input Lag (Задержка ввода):** Время между физическим действием (нажатие кнопки) и его отображением на экране.
    *   **Причины:** V-Sync, тройная буферизация, низкий FPS, низкий тикрейт физики.
    *   **Решения:** Отключение V-Sync (ценой разрывов), использование `Variable Refresh Rate` (G-Sync/FreeSync), увеличение тикрейта физики.

### **Глава 19.4: Композитор (The Compositor)**
*   **Назначение:** Новая функция в Godot 4, позволяющая вставлять кастомную логику (compute shaders) на разных этапах конвейера рендеринга.
*   **Применение:** Создание продвинутых эффектов постобработки, которые не встроены в движок по умолчанию.
*   **Использование:** `Compositor` и `CompositorEffect` являются ресурсами, которые добавляются в `WorldEnvironment`. Требует глубокого понимания конвейера рендеринга и compute-шейдеров.

### **Глава 19.5: Устранение Проблем с Физикой**

*   **Туннелирование (Tunneling):** Быстро движущиеся объекты проходят сквозь тонкие стены.
    *   **Решения:** Сделать коллайдеры толще, включить `Continuous CD` для `RigidBody`, увеличить `Physics Ticks Per Second`.
*   **Нестабильность стеков:** Стопки из `RigidBody` "разваливаются" или дрожат.
    *   **Решение:** Увеличить `Physics Ticks Per Second`.
*   **Неправильное столкновение с масштабированными объектами:**
    *   **Правило:** Никогда не изменяйте свойство `scale` у `PhysicsBody`. Вместо этого изменяйте размер дочернего `CollisionShape`.
*   **"Залипание" на краях тайлов:**
    *   **Проблема:** При движении по `TileMap` персонаж может "спотыкаться" о стыки между тайлами.
    *   **Решение:** Использовать единый "композитный" коллайдер для группы тайлов вместо индивидуальных.
---

## **РАЗДЕЛ 20: ФИЗИКА В ДЕТАЛЯХ**

### **Глава 20.1: Объекты Столкновений**

*   **Основа:** Физика в Godot работает в фиксированном цикле (`_physics_process`) для стабильности. Все физические объекты должны иметь дочерний узел `CollisionShape2D/3D` для определения их формы. **Важно:** Не масштабируйте родительский узел физического объекта (`scale != (1, 1)`), масштабируйте сам `CollisionShape`.
*   **Слои и Маски (Layers & Masks):**
    *   **`collision_layer`:** На каком слое находится объект. Описывает, "кем" он является.
    *   **`collision_mask`:** Какие слои объект сканирует на наличие столкновений. Описывает, "с кем" он взаимодействует.
*   **Типы объектов:**
    *   **`Area2D/3D`:** Для **обнаружения** и **влияния**. Не имеет твердого тела. Обнаруживает, когда другие тела входят в него или выходят (`body_entered`, `body_exited`), и может переопределять физические свойства (гравитацию, затухание) в своей области.
    *   **`StaticBody2D/3D`:** Участвует в столкновениях, но **не движется** под действием физики. Используется для статичной геометрии уровня (стены, пол). Может двигаться, если изменять его позицию вручную (например, для движущихся платформ).
    *   **`RigidBody2D/3D`:** Полностью симулируется физическим движком. Вы **не управляете** его позицией напрямую, а **применяете силы** (импульсы, тягу, крутящий момент).
    *   **`CharacterBody2D/3D`:** Гибридный тип. Не подвержен физике напрямую, но использует ее для обнаружения столкновений. **Управляется кодом** через функции `move_and_collide` или `move_and_slide`.

### **Глава 20.2: RigidBody**
*   **Управление:** Вместо прямого изменения `position` или `linear_velocity`, используйте `apply_force()` или `apply_impulse()`. Для более тонкого контроля переопределите функцию `_integrate_forces(state)`, которая позволяет напрямую изменять состояние тела (позицию, скорость, силы) в каждом физическом кадре.
*   **Спящий режим (Sleeping):** Когда `RigidBody` перестает двигаться, он "засыпает" для экономии ресурсов CPU. Он "проснется" от столкновения или применения силы.
*   **Отчеты о контактах:** По умолчанию `RigidBody` не отслеживает столкновения. Чтобы получать информацию о них, необходимо включить `contact_monitor = true` и увеличить `max_contacts_reported`. После этого можно использовать сигнал `body_entered`.

### **Глава 20.3: CharacterBody**
*   **Движение:** Основной способ движения — `move_and_slide()`. Эта функция принимает `velocity` как аргумент, пытается переместить тело и автоматически скользит вдоль препятствий.
    *   **Важно:** `move_and_slide()` **автоматически** учитывает `delta`. Не нужно умножать скорость на `delta` перед передачей в эту функцию. `velocity` должна быть скоростью в `пикселях/юнитах в секунду`.
*   **Альтернатива:** `move_and_collide()` перемещает тело до первого столкновения и останавливается. Возвращает объект `KinematicCollision2D/3D` с информацией о столкновении, которую нужно обрабатывать вручную.

### **Глава 20.4: Формы Столкновений (Collision Shapes)**
*   **Примитивы:** Простые и быстрые формы (`BoxShape3D`, `SphereShape3D`, `CapsuleShape3D`, `RectangleShape2D`). Рекомендуются для динамических объектов.
*   **Выпуклые (Convex):** `ConvexPolygonShape3D`. Могут представлять любую выпуклую форму. Медленнее примитивов. Можно сгенерировать из меша.
*   **Вогнутые / Тримеш (Concave / Trimesh):** `ConcavePolygonShape3D`. Самые точные, могут повторять любую геометрию. Самые медленные. **Можно использовать только для `StaticBody`**.

### **Глава 20.5: Продвинутые Темы Физики**
*   **Jolt Physics:** Альтернативный 3D физический движок, встроенный в Godot 4.4+. Считается более производительным и стабильным для сложных симуляций, но является экспериментальным. Включается в `Настройках проекта -> Physics -> 3D`.
*   **Ray-casting:** "Пускание луча" для проверки столкновений. Используется узел `RayCast2D/3D` или напрямую `PhysicsDirectSpaceState`.
*   **Ragdoll:** Система процедурной анимации на основе физики, обычно для симуляции падения/смерти. Создается из `Skeleton3D` с помощью узлов `PhysicalBone3D`.
*   **SoftBody:** Симуляция мягких тел (ткань, желе). Используется узел `SoftBody3D`.
*   **Большие миры (Large World Coordinates):** Для игр с огромными мирами (космические симуляторы) можно включить использование 64-битных чисел (double) для физических расчетов, чтобы избежать проблем с потерей точности на больших расстояниях от центра координат. Это требует кастомной сборки движка.
*   **Физическая интерполяция:** Техника для сглаживания движения физических объектов, когда частота кадров рендеринга не совпадает с частотой физических тиков. Включается в `Настройках проекта`.
---

## **РАЗДЕЛ 16: ФИЗИКА (ПРОДОЛЖЕНИЕ)**

### **Глава 16.4: Формы Столкновений (Collision Shapes)**
*   **Примитивы:** Простые и быстрые формы (`BoxShape3D`, `SphereShape3D`, `CapsuleShape3D`, `RectangleShape2D`). Рекомендуются для динамических объектов.
*   **Выпуклые (Convex):** `ConvexPolygonShape3D`. Могут представлять любую выпуклую форму. Медленнее примитивов. Можно сгенерировать из меша.
*   **Вогнутые / Тримеш (Concave / Trimesh):** `ConcavePolygonShape3D`. Самые точные, могут повторять любую геометрию. Самые медленные. **Можно использовать только для `StaticBody`**.

### **Глава 16.5: Продвинутые Темы Физики**
*   **Jolt Physics:** Альтернативный 3D физический движок, встроенный в Godot 4.4+. Считается более производительным и стабильным для сложных симуляций, но является экспериментальным. Включается в `Настройках проекта -> Physics -> 3D`.
*   **Ray-casting:** "Пускание луча" для проверки столкновений. Используется узел `RayCast2D/3D` или напрямую `PhysicsDirectSpaceState`. Для исключения объектов из запроса используется массив `exclude` или `collision_mask`.
*   **Ragdoll:** Система процедурной анимации на основе физики, обычно для симуляции падения/смерти. Создается из `Skeleton3D` с помощью узлов `PhysicalBone3D`.
*   **SoftBody:** Симуляция мягких тел (ткань, желе). Используется узел `SoftBody3D`.
*   **Большие миры (Large World Coordinates):** Для игр с огромными мирами (космические симуляторы) можно включить использование 64-битных чисел (double) для физических расчетов, чтобы избежать проблем с потерей точности на больших расстояниях от центра координат. Это требует кастомной сборки движка.
*   **Физическая интерполяция:** Техника для сглаживания движения физических объектов, когда частота кадров рендеринга не совпадает с частотой физических тиков. Включается в `Настройках проекта`.

### **Глава 16.6: Устранение Проблем с Физикой**
*   **Туннелирование (Tunneling):** Быстро движущиеся объекты проходят сквозь тонкие стены.
    *   **Решения:** Сделать коллайдеры толще, включить `Continuous CD` для `RigidBody`, увеличить `Physics Ticks Per Second`.
*   **Нестабильность стеков:** Стопки из `RigidBody` "разваливаются" или дрожат.
    *   **Решение:** Увеличить `Physics Ticks Per Second`.
*   **Неправильное столкновение с масштабированными объектами:**
    *   **Правило:** Никогда не изменяйте свойство `scale` у `PhysicsBody`. Вместо этого изменяйте размер дочернего `CollisionShape`.
*   **"Залипание" на краях тайлов:**
    *   **Проблема:** При движении по `TileMap` персонаж может "спотыкаться" о стыки между тайлами.
    *   **Решение:** Использовать единый "композитный" коллайдер для группы тайлов вместо индивидуальных.
*   **Резкое падение FPS:** Может происходить, если физический движок не успевает за количеством симуляций.
    *   **Решение:** Увеличить `Max Physics Steps Per Frame` и/или уменьшить `Physics Ticks Per Second`.
---

## **РАЗДЕЛ 18: ПЛАТФОРМЫ И ПЛАГИНЫ**

### **Глава 18.1: Платформо-специфичные Функции**

#### **1. Web (HTML5)**
*   **JavaScriptBridge:** Синглтон для взаимодействия между GDScript/C# и JavaScript в веб-сборках.
    *   `JavaScriptBridge.eval()`: Выполняет код JavaScript из Godot.
    *   `JavaScriptBridge.create_callback()`: Создает ссылку на функцию Godot, которую можно вызвать из JavaScript.
    *   `JavaScriptBridge.get_interface()`: Получает доступ к глобальным объектам JavaScript (например, `window`, `console`).
*   **Кастомная HTML-страница:** Можно создать свою HTML-страницу-обертку для веб-экспорта. Это позволяет добавлять кастомные CSS, JavaScript-библиотеки и полностью контролировать процесс запуска движка.
*   **HTML5 Shell Class:** JavaScript-класс `Engine`, который позволяет управлять жизненным циклом движка извне (загрузка, инициализация, запуск).

#### **2. Android**
*   **Godot Android Library (.AAR):** Позволяет встраивать экземпляр Godot в нативное Android-приложение. Это дает возможность использовать Godot для рендеринга 3D-моделей или как часть сложного UI, управляя им из Kotlin/Java кода.
*   **Android-плагины (v2):** Основной способ расширения функциональности Godot на Android. Плагин — это Android-библиотека (`.aar`), которая может:
    *   Взаимодействовать с нативными API Android (Bluetooth, GPS и т.д.).
    *   Интегрировать Java/Kotlin библиотеки.
    *   Вызывать GDExtension.
    *   Плагины регистрируются как синглтоны в Godot, и их методы можно вызывать из GDScript.
*   **Внутриигровые покупки (In-App Purchases):** Реализуются через официальный Android-плагин `GodotGooglePlayBilling`, который является оберткой над Google Play Billing Library. Он предоставляет API для запроса продуктов, совершения покупок, обработки расходных материалов и подписок.

#### **3. Консоли**
*   **Официальная поддержка:** Godot официально поддерживает только **Steam Deck** (через Linux-экспорт).
*   **Сторонние порты:** Из-за лицензионных ограничений и NDA, портирование на другие консоли (PlayStation, Xbox, Nintendo Switch) осуществляется сторонними компаниями. Для доступа к экспортным шаблонам и SDK необходимо заключить с ними договор.

### **Глава 18.2: Расширение Редактора (Плагины)**

#### **1. Основы**
*   **Назначение:** Плагины позволяют расширять функциональность редактора Godot с помощью GDScript.
*   **Структура:** Плагин состоит из файла конфигурации `plugin.cfg` и основного скрипта, который наследуется от `EditorPlugin`. Любой скрипт плагина должен иметь аннотацию `@tool` в начале.
*   **Управление:** Плагины размещаются в папке `addons/` и включаются/выключаются в `Проект -> Настройки проекта... -> Plugins`.

#### **2. Типы Плагинов**
*   **Кастомные ноды (`add_custom_type`):** Позволяет зарегистрировать сцену или скрипт как новый тип узла, который появится в диалоге "Create New Node".
*   **Кастомные доки (`add_control_to_dock`):** Добавляет новую панель (док) в интерфейс редактора.
*   **Плагины для главного экрана (`has_main_screen`):** Добавляют новую полноэкранную рабочую область, доступную по кнопке вверху редактора (рядом с "2D", "3D", "Script").
*   **Плагины импорта (`EditorImportPlugin`):** Позволяют создавать кастомные импортеры для проприетарных или неподдерживаемых форматов файлов.
*   **Плагины для гизмо (`EditorNode3DGizmoPlugin`):** Позволяют создавать кастомные 3D- gizmo для `Node3D`-наследников, которые появляются во вьюпорте при выделении узла.
*   **Плагины для инспектора (`EditorInspectorPlugin`):** Позволяют добавлять кастомные элементы управления (виджеты) в Инспектор для определенных свойств или типов объектов.

#### **3. Запуск кода в редакторе (`@tool`)**
*   **Аннотация `@tool`:** Заставляет скрипт выполняться не только в игре, но и в редакторе Godot.
*   **Разделение логики:** Используйте `Engine.is_editor_hint()` для проверки, где сейчас выполняется код (в редакторе или в запущенной игре), чтобы разделить логику.
*   **Применение:** Визуализация данных (например, пути патрулирования AI), процедурная генерация уровней прямо в редакторе, создание вспомогательных инструментов.
*   **`EditorScript`:** Скрипт, который наследуется от `EditorScript`, можно запустить один раз как утилиту через меню `Файл -> Запустить в редакторе`. Не требует создания полноценного плагина.
---

## **РАЗДЕЛ 19: ПРОДВИНУТЫЙ РЕНДЕРИНГ**

### **Глава 19.1: Viewports (Окна вывода)**

*   **Концепция:** `Viewport` — это "экран", на который проецируется игра. Корневой узел дерева сцены — это корневой `Viewport`.
*   **`SubViewport` (Подокно):** Узел `Viewport`, добавленный в сцену. Он позволяет рендерить одну часть сцены независимо от другой.
*   **Применение `SubViewport`:**
    *   **Картинка-в-картинке:** Отображение вида с другой камеры (например, зеркало заднего вида).
    *   **3D в 2D:** Отображение 3D-модели в 2D-интерфейсе.
    *   **2D в 3D:** Отображение 2D-интерфейса на 3D-поверхности (например, экран монитора в игре).
    *   **Динамические текстуры:** Содержимое `SubViewport` можно получить как текстуру (`ViewportTexture`) и использовать в материалах, шейдерах и т.д.

### **Глава 19.2: Адаптация под Разные Разрешения**

*   **Базовый размер:** В `Настройках проекта -> Display -> Window` устанавливается базовое разрешение, под которое проектируется игра.
*   **Режим растяжения (`Stretch Mode`):**
    *   **`disabled`:** Нет растяжения. 1 игровой юнит = 1 пиксель.
    *   **`canvas_items`:** Растягивается только 2D-контент. 3D рендерится в нативном разрешении.
    *   **`viewport`:** Растягивается все окно вывода. Рендеринг происходит в базовом разрешении, а затем результат масштабируется. Самый производительный режим.
*   **Сохранение пропорций (`Stretch Aspect`):**
    *   **`ignore`:** Изображение искажается, заполняя все окно.
    *   **`keep`:** Сохраняет пропорции, добавляя черные полосы по бокам (letterboxing/pillarboxing).
    *   **`keep_width` / `keep_height`:** Сохраняет пропорции, расширяя видимую область по одной из осей.
    *   **`expand`:** Сохраняет пропорции и масштабируется, чтобы заполнить экран, обрезая часть изображения.

### **Глава 19.3: Устранение Проблем с Рендерингом**

*   **Jitter (Дрожание):** Легкое, постоянное подрагивание. Обычно возникает из-за рассинхронизации физического тикрейта (по умолчанию 60 Гц) и частоты обновления монитора. Решается использованием **физической интерполяции**.
*   **Stutter (Заикание):** Резкие, нерегулярные "замирания" или "откаты" кадра. Причины:
    *   **Падение производительности:** Игра не успевает подготовить кадр вовремя. Решение — оптимизация.
    *   **Системные проблемы:** ОС, драйверы, фоновые процессы. Включение `Exclusive Fullscreen` и отключение V-Sync может помочь.
*   **Input Lag (Задержка ввода):** Время между физическим действием (нажатие кнопки) и его отображением на экране.
    *   **Причины:** V-Sync, тройная буферизация, низкий FPS, низкий тикрейт физики.
    *   **Решения:** Отключение V-Sync (ценой разрывов), использование `Variable Refresh Rate` (G-Sync/FreeSync), увеличение тикрейта физики.

### **Глава 19.4: Композитор (The Compositor)**
*   **Назначение:** Новая функция в Godot 4, позволяющая вставлять кастомную логику (compute shaders) на разных этапах конвейера рендеринга.
*   **Применение:** Создание продвинутых эффектов постобработки, которые не встроены в движок по умолчанию.
*   **Использование:** `Compositor` и `CompositorEffect` являются ресурсами, которые добавляются в `WorldEnvironment`. Требует глубокого понимания конвейера рендеринга и compute-шейдеров.
---

## **РАЗДЕЛ 20: СПРАВОЧНИК GDScript**

### **Глава 20.1: Синтаксис и Структура**
*   **Аннотации (`@`):** Специальные токены, которые изменяют поведение скрипта или его переменных (например, `@tool`, `@export`, `@onready`).
*   **Комментарии:**
    *   `# Однострочный комментарий`
    *   `## Документационный комментарий` (отображается как tooltip в редакторе).
    *   Специальные маркеры: `# TODO:`, `# FIXME:`, `# NOTE:` подсвечиваются в редакторе.
*   **Регионы кода (`#region` / `#endregion`):** Позволяют сворачивать большие блоки кода для лучшей организации.
*   **Продолжение строки (`\`):** Обратный слеш в конце строки позволяет продолжить выражение на следующей строке.

### **Глава 20.2: Встроенные Типы**
*   **Типы по значению (pass-by-value):** `null`, `bool`, `int`, `float`, `String`, `Vector2`, `Rect2`, `Vector3`, `Transform2D`, `Plane`, `Quaternion`, `AABB`, `Basis`, `Transform3D`, `Color`. При передаче в функцию создается копия.
*   **Типы по ссылке (pass-by-reference):** `Object`, `Array`, `Dictionary`, `PackedByteArray` и другие Packed-массивы. При передаче в функцию передается ссылка на исходные данные.
*   **Типизированные массивы (`Array[Type]`):** Позволяют создавать массивы, которые могут содержать только объекты указанного типа.
*   **Packed-массивы:** Оптимизированные массивы для хранения однотипных данных (`PackedVector2Array`, `PackedInt32Array`). Быстрее и занимают меньше памяти, чем обычные `Array`.

### **Глава 20.3: Переменные и Константы**
*   **Инициализация:** Переменные инициализируются в определенном порядке: сначала статические типы (`null`, `0`, `false`), затем значения из скрипта, затем `@onready`, затем `_init()`, и только потом `_ready()`.
*   **Статические переменные (`static var`):** Переменная принадлежит классу, а не его экземпляру. Все экземпляры класса разделяют одно и то же значение статической переменной.

### **Глава 20.4: Функции**
*   **Функции как объекты (`Callable`):** Функции можно передавать как аргументы в другие функции.
*   **Лямбда-функции (Анонимные функции):**
    ```gdscript
    var my_lambda = func(x): return x * 2
    my_lambda.call(10) # вернет 20
    ```
*   **Статические функции (`static func`):** Не имеют доступа к `self` и переменным экземпляра. Полезны для создания библиотек вспомогательных функций.

### **Глава 20.5: Управляющие Конструкции**
*   **`if/elif/else`:** Стандартное ветвление.
*   **Тернарный оператор:** `var x = a if condition else b`.
*   **`while`:** Цикл с предусловием.
*   **`for`:** Цикл для итерации по диапазонам (`for i in range(10)`), массивам, словарям и строкам.
*   **`match` (аналог `switch`):** Мощная конструкция для ветвления по значению или типу.
    *   **Паттерны:**
        *   Литерал: `1:`, `"hello":`
        *   Переменная: `var x:` (связывает значение с новой переменной `x`).
        *   Wildcard: `_:` (соответствует любому значению, аналог `default`).
        *   Массив: `[1, 2, var x]:`
        *   Словарь: `{"name": "John", "age": var x}:`
        *   Открытые массивы/словари: `[1, 2, ..]`
    *   **Ограничители (`when`):** `1 when x > 10:` (дополнительное условие).

### **Глава 20.6: Классы**
*   **Встроенные классы:** Скрипт может определять внутренние классы (`class MyInnerClass:`).
*   **Именованные классы (`class_name`):** Глобально регистрирует скрипт как новый тип, доступный по имени из других скриптов без необходимости `preload`.
---

## **РАЗДЕЛ 19: СЕТЕВОЕ ВЗАИМОДЕЙСТВИЕ**

### **Глава 19.1: Высокоуровневый мультиплеер**

*   **API:** Основано на объекте `MultiplayerAPI` и `MultiplayerPeer`.
*   **Инициализация:**
    1.  Создается пир: `var peer = ENetMultiplayerPeer.new()`.
    2.  Пир настраивается как сервер (`peer.create_server(PORT)`) или клиент (`peer.create_client(IP, PORT)`).
    3.  Пир назначается дереву сцен: `multiplayer.multiplayer_peer = peer`.
*   **RPC (Remote Procedure Calls - Удаленный вызов процедур):**
    *   **Назначение:** Основной способ вызова функций на других компьютерах в сети.
    *   **Объявление:** Функция помечается аннотацией `@rpc`.
    *   **Вызов:** `my_node.rpc("function_name", arg1, arg2)`.
    *   **Ключевые параметры `@rpc`:**
        *   **`authority` / `any_peer`:** Кто может вызывать эту функцию.
        *   **`call_local`:** Будет ли функция вызвана и на локальном клиенте.
        *   **`reliable` / `unreliable`:** Гарантируется ли доставка пакета. `reliable` медленнее, но надежнее. `unreliable` быстрее, но пакеты могут теряться (подходит для часто обновляемых данных, вроде позиции игрока).
        *   **`channel`:** Позволяет отправлять пакеты по разным каналам для предотвращения задержек (например, чат не должен замедлять движение).

### **Глава 19.2: Низкоуровневое сетевое взаимодействие**

#### **1. HTTP-запросы**
*   **Назначение:** Для взаимодействия с веб-серверами (авторизация, таблицы лидеров, загрузка ассетов). Не подходит для игрового процесса в реальном времени.
*   **Узел:** `HTTPRequest`.
*   **Процесс:**
    1.  Подключиться к сигналу `request_completed`.
    2.  Вызвать `http_request.request("http://my-api.com/data")`.
    3.  Обработать результат в функции, подключенной к сигналу. Данные приходят в виде `PackedByteArray`, который нужно преобразовать в строку (`body.get_string_from_utf8()`).

#### **2. WebSocket**
*   **Назначение:** Протокол для постоянного двунаправленного соединения. Хорошо подходит для чатов, пошаговых игр. Недостаточно быстр для игр в реальном времени.
*   **Классы:** `WebSocketPeer` (клиент), `WebSocketServer` (сервер).
*   **Процесс:**
    1.  Клиент создает `WebSocketPeer` и вызывает `socket.connect_to_url(url)`.
    2.  Сервер создает `WebSocketServer` и вызывает `server.listen(port)`.
    3.  В `_process()` обе стороны вызывают `poll()` для обработки событий.
    4.  Данные отправляются через `put_packet()` и принимаются через `get_packet()`.

#### **3. WebRTC**
*   **Назначение:** Технология для прямого peer-to-peer (P2P) соединения между клиентами с низкой задержкой. Идеально для быстрых мультиплеерных игр.
*   **Принцип:** Клиенты сначала подключаются к **сигнальному серверу** (Signaling Server), обмениваются через него информацией о соединении (SDP, ICE candidates), а затем устанавливают прямое соединение друг с другом.
*   **Классы:** `WebRTCPeerConnection`, `WebRTCDataChannel`.

#### **4. TLS/SSL Сертификаты**
*   **Назначение:** Обеспечение безопасного (шифрованного) соединения для `HTTPClient`, `HTTPRequest` и `WebSocket`.
*   **Использование:** Godot по умолчанию использует системные сертификаты. Можно указать свой собственный `.crt` бандл в `Настройках проекта -> Network -> TLS`.
---

## **РАЗДЕЛ 20: ПРОДВИНУТАЯ АНИМАЦИЯ**

### **Глава 20.1: 2D Скелетная Анимация**

#### **1. Cutout Animation (Перекладная анимация)**
*   **Концепция:** Техника, при которой персонаж составляется из отдельных спрайтов (частей тела), которые затем анимируются путем изменения их трансформаций (вращение, перемещение).
*   **Создание рига (Rig):**
    1.  **Иерархия:** Части тела выстраиваются в иерархию "родитель-потомок". Корнем скелета обычно является таз (`hip`).
    2.  **Точка вращения (Pivot):** Для каждого спрайта (`Sprite2D`) необходимо правильно выставить точку вращения, смещая свойство `Offset`.
    3.  **Порядок отрисовки:** Для управления тем, какая часть тела находится "спереди", а какая "сзади", используется либо `z_index`, либо свойство `Show Behind Parent`, либо узел `RemoteTransform2D`.
*   **Скелеты (`Skeleton2D`):** Упрощают анимацию ригов и позволяют использовать инверсную кинематику (IK).
*   **Инверсная кинематика (IK Chain):**
    *   **Назначение:** Позволяет анимировать конечности, двигая только конечную точку (например, кисть или стопу).
    *   **Ограничение:** В Godot IK-цепи работают **только в редакторе** для упрощения расстановки ключевых кадров и **не работают в рантайме**.

#### **2. Skeletal Deform (Скелетная деформация)**
*   **Концепция:** Вместо набора отдельных спрайтов используется одно цельное изображение персонажа, которое деформируется с помощью скелета (`Skeleton2D` и `Bone2D`).
*   **Процесс:**
    1.  **Создание полигона:** С помощью `Polygon2D` создается полигон, повторяющий контур персонажа на текстуре.
    2.  **Создание скелета:** Создается иерархия узлов `Bone2D`.
    3.  **Привязка:** `Polygon2D` привязывается к `Skeleton2D`.
    4.  **Раскраска весов (Weight Painting):** В UV-редакторе для `Polygon2D` каждая вершина полигона "раскрашивается", чтобы определить, какая кость и с какой силой на нее влияет.
    5.  **Внутренние вершины:** Для более качественных и естественных сгибов в полигон добавляются внутренние вершины.

### **Глава 20.2: AnimationTree (Дерево Анимаций)**

*   **Назначение:** Узел для продвинутого управления анимациями из `AnimationPlayer`. Позволяет смешивать (blending) анимации, создавать сложные переходы и управлять ими через конечный автомат (State Machine).
*   **Принцип:** `AnimationTree` не содержит анимаций. Он подключается к `AnimationPlayer` и использует его анимации как "сырье".

#### **1. Ключевые ноды AnimationTree:**
*   **`AnimationNodeAnimation`:** Просто проигрывает одну анимацию.
*   **`AnimationNodeBlend2` / `Blend3`:** Смешивает 2 или 3 анимации на основе одного float-параметра.
*   **`AnimationNodeBlendSpace1D` / `BlendSpace2D`:** Продвинутое смешивание на 1D или 2D-пространстве (например, для смешивания ходьбы в 8 направлениях).
*   **`AnimationNodeStateMachine` (Конечный автомат):** Позволяет создавать состояния ("Idle", "Walk") и настраивать правила перехода между ними. Стандартный подход для анимаций персонажа.
*   **`AnimationNodeOneShot`:** Проигрывает одну анимацию (выстрел, уворот) поверх текущего состояния.
*   **`AnimationNodeTransition`:** Простой переключатель между анимациями.

#### **2. Управление из кода**
*   Управление `AnimationTree` происходит через установку его параметров:
    ```gdscript
    # Установить значение для Blend2
    animation_tree["parameters/my_blend_node/blend_amount"] = 0.5
    # Переключить состояние в StateMachine
    var state_machine = animation_tree["parameters/playback"]
    state_machine.travel("jump_state")
    ```

#### **3. Root Motion (Движение корня)**
*   **Концепция:** Техника, при которой движение персонажа в мире (`CharacterBody3D`) управляется смещением корневой кости в самой анимации.
*   **Применение:** В коде из `AnimationTree` извлекается дельта трансформации корневой кости (`get_root_motion_...()`) и применяется к `CharacterBody3D` через `move_and_slide()`.
---

## **РАЗДЕЛ 21: ПРОДВИНУТАЯ ФИЗИКА**

### **Глава 21.1: Физические Движки**
*   **Godot Physics (по умолчанию):** Встроенный 2D и 3D физический движок.
*   **Jolt Physics:** Альтернативный 3D физический движок, встроенный в Godot 4.4+. Считается более производительным и стабильным для сложных симуляций, но является экспериментальным. Включается в `Настройках проекта -> Physics -> 3D`. Имеет ряд отличий в поведении от Godot Physics (например, в обработке `Area3D` со статическими телами и в свойствах соединений).

### **Глава 21.2: Ray-casting (Бросание лучей)**
*   **Назначение:** Проверка столкновений вдоль отрезка (луча). Используется для стрельбы, определения "видит ли" AI игрока, и т.д.
*   **Способы:**
    1.  **Узлы `RayCast2D`/`RayCast3D`:** Простой способ. Узел представляет луч, его свойства можно настроить в инспекторе. Результат проверяется через `is_colliding()` и `get_collider()`.
    2.  **`PhysicsDirectSpaceState`:** Более мощный и производительный низкоуровневый способ. Позволяет делать запросы напрямую к физическому серверу, минуя дерево сцен.
        *   Получение state: `get_world_2d().direct_space_state` или `get_world_3d().direct_space_state`.
        *   Запрос: `state.intersect_ray(query_parameters)`.
*   **Исключения:** Чтобы луч не сталкивался с "пускающим" его телом, можно передать массив исключений (`exclude`) или использовать `collision_mask`.

### **Глава 21.3: Ragdoll-симуляция**
*   **Концепция:** Система процедурной анимации на основе физики, обычно для симуляции падения/смерти.
*   **Процесс:**
    1.  Используется узел `Skeleton3D` с иерархией `BoneAttachment3D`.
    2.  Для каждой кости скелета создается соответствующее физическое тело (`PhysicalBone3D`). Это можно сделать автоматически через меню `Skeleton3D` в редакторе.
    3.  Физические кости соединяются между собой `Joint`-ами (например, `PinJoint3D`).
    4.  Симуляция запускается/останавливается из кода: `physical_bones_start_simulation()` и `physical_bones_stop_simulation()`.

### **Глава 21.4: SoftBody (Мягкие тела)**
*   **Назначение:** Симуляция деформируемых объектов (ткань, флаги, желе).
*   **Узел:** `SoftBody3D`.
*   **Принцип:** `SoftBody3D` использует меш (`Mesh`) для симуляции. Вершины меша действуют как физические точки, соединенные пружинами.
*   **Прикрепление:** Часть вершин `SoftBody` можно "прикрепить" к другим узлам (например, `BoneAttachment3D`), чтобы симулировать плащ, прикрепленный к плечам персонажа.

### **Глава 21.5: Большие миры и Точность**
*   **Проблема:** В 3D-мирах огромного размера (`> 10,000` юнитов от центра) стандартные 32-битные числа с плавающей запятой (`float`) теряют точность, что приводит к "дрожанию" (jitter) объектов и другим физическим глитчам.
*   **Решение (для 3D):** Сборка движка с поддержкой `precision=double`. Это заставит Godot использовать 64-битные числа для всех физических и трансформационных расчетов.
*   **Последствия:** Увеличивает потребление памяти и нагрузку на CPU. Требует, чтобы и сервер, и клиенты в сетевой игре использовали одинаковый тип сборки.

### **Глава 21.6: Физическая Интерполяция**
*   **Проблема:** Физика работает с фиксированной частотой (например, 60 раз/сек), а рендеринг — с плавающей (например, 144 кадра/сек). Это несоответствие приводит к "дрожанию" (jitter) при движении физических объектов.
*   **Решение:** Вместо отображения объекта в его последней физической позиции, движок **интерполирует** его позицию между предыдущим и текущим физическим кадром, на основе того, в какой момент времени происходит рендеринг.
*   **Включение:** `Настройки проекта -> Physics -> Common -> Physics Jitter Fix`. В Godot 4.3 и новее эта опция включена по умолчанию и переименована в `Physics Interpolation`.
---

## **РАЗДЕЛ 22: ОПТИМИЗАЦИЯ ПРОИЗВОДИТЕЛЬНОСТИ (ПРОДОЛЖЕНИЕ)**

### **Глава 22.1: Общие Принципы**

*   **"Преждевременная оптимизация — корень всех зол"**: Не оптимизируйте код, который и так работает быстро. Сконцентрируйтесь на реальных "узких местах".
*   **Процесс оптимизации:**
    1.  **Профилирование:** Используйте профилировщик, чтобы найти самые медленные части кода/рендеринга.
    2.  **Оптимизация:** Улучшите найденное "узкое место".
    3.  **Возврат к шагу 1:** Повторяйте, пока производительность не станет приемлемой.
*   **Инструменты для измерения:**
    *   **Встроенный профилировщик Godot:** `Отладчик -> Профилировщик`.
    *   **Внешние профилировщики:** NVIDIA Nsight, AMD uProf, Intel VTune.
    *   **Измерение вручную:** `Time.get_ticks_usec()` для замера времени выполнения участков кода.

### **Глава 22.2: Оптимизация CPU**

*   **Языки:** Для особо тяжелых вычислений перенос логики с GDScript на C# или C++ (через GDExtension) может дать значительный прирост.
*   **Потоки (Threads):** Используйте класс `Thread` для выноса долгих вычислений (генерация мира, сложные расчеты AI) в фоновые потоки, чтобы не блокировать основной поток игры.
    *   **Синхронизация:** Для безопасного доступа к общим данным из разных потоков используйте `Mutex` (для блокировки доступа) и `Semaphore` (для сигнализации).
    *   **Потокобезопасные API:** Взаимодействие с деревом сцен (`SceneTree`) из потока **небезопасно**. Используйте `call_deferred()`. Серверы (`RenderingServer`, `PhysicsServer`) являются потокобезопасными.
*   **Дерево Сцен:** Каждый узел имеет свою цену. Большое количество узлов (десятки тысяч) может замедлить `_process` и `_physics_process`.

### **Глава 22.3: Оптимизация GPU**

*   **Вызовы отрисовки (Draw Calls):** Каждая отрисовка объекта — это вызов API. Их количество важно, особенно на OpenGL. Объединяйте геометрию и используйте `MultiMeshInstance3D` для их сокращения. Vulkan обрабатывает вызовы значительно быстрее.
*   **Стоимость пикселя vs. вершин:** На современных GPU стоимость обработки вершин (vertex cost) низкая, а стоимость обработки пикселей/фрагментов (pixel/fragment cost) — высокая.
    *   **Не бойтесь полигонов:** Количество полигонов не так критично, как раньше.
    *   **Бойтесь `overdraw`:** Избегайте ситуаций, когда GPU много раз рисует один и тот же пиксель (например, много слоев полупрозрачных эффектов).
*   **Шейдеры и Fillrate:** Сложные PBR-шейдеры, постобработка и тени очень требовательны к скорости заполнения (fillrate). Уменьшение разрешения окна или использование `Resolution Scaling` — эффективный способ борьбы с этим.
*   **Компиляция шейдеров:**
    *   **Проблема:** Компиляция шейдера в первый раз, когда он нужен, вызывает "заикание" (stutter).
    *   **Решение:** Godot 4.1+ использует **Ubershaders** и **Pipeline Precompilation**. Чтобы помочь движку, создайте "разогревочную" сцену, где будут показаны все основные эффекты, материалы и объекты, чтобы их шейдеры скомпилировались во время экрана загрузки.

### **Глава 22.4: Анимация Тысяч Объектов (Vertex Shaders)**
*   **Проблема:** Скелетная анимация (`Skeleton3D`) обрабатывается на CPU и слишком медленная для анимации тысяч объектов.
*   **Решение:** Вершинная анимация.
*   **Принцип:**
    1.  Используется `MultiMeshInstance3D` для отрисовки всех объектов за один вызов.
    2.  Логика анимации пишется непосредственно в **вершинном шейдере** (`vertex shader`).
    3.  Шейдер использует встроенные переменные (`TIME`, `INSTANCE_ID`, `INSTANCE_CUSTOM`) для расчета смещения вершин.
*   **Результат:** Вся анимация полностью выполняется на GPU.

## **РАЗДЕЛ 23: СПРАВОЧНИК GDScript**

### **Глава 23.1: Синтаксис и Структура**
*   **Аннотации (`@`):** Специальные токены, которые изменяют поведение скрипта или его переменных (например, `@tool`, `@export`, `@onready`).
*   **Комментарии:**
    *   `# Однострочный комментарий`
    *   `## Документационный комментарий` (отображается как tooltip в редакторе).
    *   Специальные маркеры: `# TODO:`, `# FIXME:`, `# NOTE:` подсвечиваются в редакторе.
*   **Регионы кода (`#region` / `#endregion`):** Позволяют сворачивать большие блоки кода для лучшей организации.

### **Глава 23.2: Встроенные Типы**
*   **Типы по значению (pass-by-value):** `null`, `bool`, `int`, `float`, `String`, `Vector2`, `Rect2`, `Vector3`, `Transform2D`, `Plane`, `Quaternion`, `AABB`, `Basis`, `Transform3D`, `Color`. При передаче в функцию создается копия.
*   **Типы по ссылке (pass-by-reference):** `Object`, `Array`, `Dictionary`, `PackedByteArray` и другие Packed-массивы. При передаче в функцию передается ссылка на исходные данные.
*   **Типизированные массивы (`Array[Type]`):** Позволяют создавать массивы, которые могут содержать только объекты указанного типа.

### **Глава 23.3: Переменные и Константы**
*   **Инициализация:** Переменные инициализируются в определенном порядке: сначала статические типы (`null`, `0`, `false`), затем значения из скрипта, затем `@onready`, затем `_init()`, и только потом `_ready()`.
*   **Статические переменные (`static var`):** Переменная принадлежит классу, а не его экземпляру. Все экземпляры класса разделяют одно и то же значение статической переменной.

### **Глава 23.4: Функции**
*   **Функции как объекты (`Callable`):** Функции можно передавать как аргументы в другие функции.
*   **Лямбда-функции (Анонимные функции):**
    ```gdscript
    var my_lambda = func(x): return x * 2
    my_lambda.call(10) # вернет 20
    ```
*   **Статические функции (`static func`):** Не имеют доступа к `self` и переменным экземпляра. Полезны для создания библиотек вспомогательных функций.

### **Глава 23.5: Управляющие Конструкции**
*   **`if/elif/else`:** Стандартное ветвление.
*   **Тернарный оператор:** `var x = a if condition else b`.
*   **`while`, `for`:** Циклы.
*   **`match` (аналог `switch`):** Мощная конструкция для ветвления по значению или типу.
    *   **Паттерны:** Литерал, переменная, wildcard (`_`), массив (`[1, 2, var x]`), словарь (`{"name": "John"}`), открытые структуры (`[1, ..]`).
    *   **Ограничители (`when`):** `1 when x > 10:` (дополнительное условие).

### **Глава 23.6: Классы**
*   **Встроенные классы:** Скрипт может определять внутренние классы (`class MyInnerClass:`).
*   **Именованные классы (`class_name`):** Глобально регистрирует скрипт как новый тип, доступный по имени из других скриптов без необходимости `preload`.
### **Глава 20.7: Динамическая природа и Утиная типизация**

#### **1. Сущность: Динамическая Типизация**
*   **Определение:** GDScript является языком с динамической типизацией. Это означает, что тип переменной не является фиксированным и может изменяться в ходе выполнения программы. Все переменные по своей сути являются `Variant`-подобными.
    ```gdscript
    # Динамическая природа
    var a # По умолчанию 'null'
    a = 5 # 'a' становится Integer.
    a = "Hi!" # 'a' становится String. Это валидно.
    ```
*   **Преимущества:**
    1.  **Низкий порог вхождения:** Легко начать писать код.
    2.  **Скорость разработки:** Код пишется и изменяется быстрее.
    3.  **Читаемость:** Меньше синтаксического "шума".
    4.  **Отсутствие компиляции:** Не требуется этап компиляции для тестирования.
    5.  **Полиморфизм по умолчанию:** Благодаря "утиной типизации".
*   **Недостатки:**
    1.  **Производительность:** Ниже, чем у статически типизированных языков.
    2.  **Сложность рефакторинга:** Символы не всегда могут быть отслежены IDE.
    3.  **Ошибки времени выполнения:** Некоторые ошибки, которые были бы пойманы на этапе компиляции, проявляются только при запуске.
    4.  **Менее гибкое автодополнение:** Тип переменной может быть неизвестен до выполнения.
*   **Стратегия Godot:** Комбинация, разработанная для быстрой и эффективной разработки игр. Большая часть логики пишется на GDScript, а критически важные для производительности участки могут быть переписаны на C++ (через GDExtension).

#### **2. Принцип: Передача по значению vs. по ссылке**
*   **По значению (Pass-by-value):** Все встроенные типы (`int`, `float`, `String` и векторные типы) передаются в функции как **копии**.
*   **По ссылке (Pass-by-reference):** Все остальные типы (объекты, `Array`, `Dictionary` и т.д.) передаются как **ссылки**. Изменение объекта внутри функции повлияет на исходный объект.
*   **Управление памятью:** Классы, наследующие `RefCounted` (поведение по умолчанию для скриптов), освобождаются сборщиком мусора, когда на них не остается ссылок.

#### **3. Концепция: Утиная типизация (Duck Typing)**
*   **Определение:** Фундаментальный принцип полиморфизма в динамических языках. "Если нечто ходит как утка и крякает как утка, то я называю это уткой".
*   **Принцип:** Тип объекта не важен. Важно лишь то, есть ли у него необходимые методы или свойства. Не требуется наследование от общего класса или интерфейса.
    ```gdscript
    # Вместо проверки типа, мы просто вызываем метод.
    # Если у объекта есть метод smash(), он будет вызван.
    func _on_object_hit(object):
        object.smash()
    ```
*   **Безопасная проверка:** Чтобы избежать ошибок, если метод может отсутствовать, используется `has_method()`:
    ```gdscript
    func _on_object_hit(object):
        if object.has_method("smash"):
            object.smash()
    ```
### **Глава 20.8: Структуры Данных**

#### **1. Массивы (Arrays)**
*   **Динамическая природа:** Массивы в GDScript являются динамическими. Они могут содержать смешанные типы данных и изменять свой размер в любое время.
    ```gdscript
    # Массив может содержать разные типы и изменять размер.
    var array = [10, "hello", 60]
    array.resize(5)
    array.append("new_element")
    ```
*   **Передача по ссылке:** Массивы всегда передаются в функции по ссылке.

#### **2. Словари (Dictionaries)**
*   **Назначение:** Эффективная структура данных для хранения пар "ключ-значение". Словари могут отображать любое значение на любой ключ. Благодаря использованию хеш-таблиц, они чрезвычайно эффективны для поиска, добавления и удаления элементов.
*   **Динамическая природа:** Как и массивы, словари являются динамическими, и в них можно добавлять или удалять ключи в любое время с минимальными затратами производительности.
    ```gdscript
    var d = {"name": "John", "age": 22}
    
    # Добавление
    d["mother"] = "Rebecca"
    
    # Модификация
    d.age = 11
    
    # Удаление
    d.erase("name")
    ```
*   **Lua-подобный синтаксис:** GDScript поддерживает альтернативный, более читаемый синтаксис для определения и доступа к словарям, где ключи-строки не требуют кавычек.
    ```gdscript
    # Альтернативный синтаксис
    var d = {
        name = "John",
        age = 22
    }
    print(d.name) # Доступ через точку
    d.mother = "Caroline" # Создание нового ключа
    ```
### **Глава 20.9: Циклы и Итераторы**

#### **1. Цикл `for`**
*   **Назначение:** GDScript использует цикл `for` для итерации по итерируемым объектам (таким как массивы, словари, строки).
    ```gdscript
    # Итерация по массиву
    for element in my_array:
        print(element)

    # Итерация по ключам словаря
    for key in my_dictionary:
        print(key, ": ", my_dictionary[key])

    # Итерация по индексам
    for i in range(my_array.size()):
        print(my_array[i])
    ```

#### **2. Функция `range()`**
*   **Назначение:** `range()` используется для генерации последовательности чисел, что позволяет эмулировать C-подобные циклы.
*   **Варианты:**
    *   `range(n)`: Считает от `0` до `n-1`.
    *   `range(b, n)`: Считает от `b` до `n-1`.
    *   `range(b, n, s)`: Считает от `b` до `n-1` с шагом `s`. Шаг может быть отрицательным для обратного отсчета.
    ```gdscript
    # Аналог C-style: for (int i = 0; i < 10; i++)
    for i in range(10):
        pass

    # Аналог C-style: for (int i = 5; i < 10; i++)
    for i in range(5, 10):
        pass

    # Аналог C-style: for (int i = 10; i > 0; i--)
    for i in range(10, 0, -1):
        pass
    ```

#### **3. Цикл `while`**
*   **Назначение:** Цикл `while` выполняется до тех пор, пока его условие истинно.
    ```gdscript
    var i = 0
    while i < my_array.size():
        print(my_array[i])
        i += 1
    ```

#### **4. Пользовательские Итераторы (Custom Iterators)**
*   **Назначение:** Можно создавать собственные итерируемые объекты, которые будут работать в цикле `for`.
*   **Требования:** Класс должен реализовывать три функции:
    1.  `_iter_init(args)`: Инициализирует итератор. Должен вернуть `true` для продолжения или `false` для остановки.
    2.  `_iter_next(args)`: Переходит к следующему элементу. Должен вернуть `true` для продолжения или `false` для остановки.
    3.  `_iter_get(arg)`: Возвращает текущий элемент.
    ```gdscript
    # Пример пользовательского итератора
    class ForwardIterator:
        var start
        var current
        var end
        var increment

        func _init(start, stop, increment):
            self.start = start
            self.current = start
            self.end = stop
            self.increment = increment

        func should_continue():
            return (current < end)

        func _iter_init(arg):
            current = start
            return should_continue()

        func _iter_next(arg):
            current += increment
            return should_continue()

        func _iter_get(arg):
            return current

    # Использование
    var it = ForwardIterator.new(0, 6, 2)
    for i in it:
        print(i) # Напечатает 0, 2, 4
    ```
### **Глава 20.10: Экспортируемые Свойства (`@export`)**

#### **1. Основы**
*   **Назначение:** Аннотация `@export` делает переменную видимой и редактируемой в Инспекторе Godot. Это позволяет дизайнерам и художникам изменять параметры без необходимости редактировать код.
*   **Сохранение:** Значение экспортированной переменной сохраняется вместе с ресурсом, к которому прикреплен скрипт (например, в файле сцены `.tscn`).
*   **Синтаксис:**
    ```gdscript
    # Тип будет выведен из значения (int)
    @export var number = 5

    # Тип указан явно, значение по умолчанию null
    @export var name: String

    # Экспорт узлов и ресурсов
    @export var some_node: Node
    @export var some_resource: Resource
    ```

#### **2. Группировка и Категоризация**
*   **`@export_group("Название Группы")`**: Создает заголовок-группу в Инспекторе. Все `@export` переменные после этой аннотации будут помещены в эту группу.
*   **`@export_subgroup("Название Подгруппы")`**: Создает подгруппу внутри текущей группы.
*   **`@export_category("Название Категории")`**: Создает новую категорию верхнего уровня в Инспекторе (аналогично "Node2D", "Transform"). Используйте с осторожностью, так как это нарушает стандартную иерархию наследования в Инспекторе.

#### **3. Специализированные Экспорты (Хинты)**

##### **Пути к файлам и директориям:**
*   **`@export_file`**: Поле для выбора файла.
    ```gdscript
    # Любой файл
    @export_file var f
    # Только файлы с расширением .txt
    @export_file("*.txt") var f_txt
    ```
*   **`@export_dir`**: Поле для выбора директории.
*   **`@export_global_file`, `@export_global_dir`**: Поля для выбора файлов/директорий из всей файловой системы компьютера (требует `@tool` режим).

##### **Текст:**
*   **`@export_multiline`**: Создает большое текстовое поле для многострочного ввода.

##### **Числовые диапазоны и типы:**
*   **`@export_range(min, max, [step], [extra_hints...])`**: Создает слайдер для `int` или `float`.
    *   `"or_less"`, `"or_greater"`: Позволяют вводить значения за пределами диапазона слайдера.
    *   `"exp"`: Делает слайдер экспоненциальным, что удобно для очень больших диапазонов.
    *   `"hide_slider"`: Скрывает слайдер, оставляя только поле для ввода числа.
    *   `"suffix:m"`: Добавляет суффикс (например, "m" для метров).
    *   `"radians_as_degrees"`: Позволяет вводить значение в градусах, которое будет автоматически конвертировано в радианы.
*   **`@export_exp_easing`**: Поле для выбора кривой `ease()`.

##### **Другие типы данных:**
*   **`@export_color`, `@export_color_no_alpha`**: Поле для выбора цвета.
*   **`@export_flags(...)`**: Позволяет экспортировать `int` как набор битовых флагов (чекбоксов). Часто используется для слоев физики или рендеринга.
    ```gdscript
    @export_flags("Fire", "Water", "Earth", "Wind") var spell_elements = 0
    @export_flags_2d_physics var physics_layer
    ```
*   **`@export_enum(...)`**: Ограничивает выбор значениями из `enum` или списка строк/чисел.
    ```gdscript
    enum NamedEnum { THING_1, THING_2 }
    @export var x: NamedEnum
    
    # Список строк
    @export_enum("Warrior", "Magician", "Thief") var character_class: String
    ```
*   **`@export_node_path(...)`**: (Наследие Godot 3) Экспортирует `NodePath`. Можно указать типы узлов для фильтрации. В Godot 4 предпочтительнее прямой экспорт узла (`@export var my_node: Button`).

##### **Массивы:**
*   **`@export var my_array: Array`**: Экспортирует массив. Тип элементов можно указать: `Array[int]`, `Array[PackedScene]`.
*   **Перетаскивание:** Для массивов ресурсов (например, `Array[Texture2D]`) можно перетащить несколько файлов из `FileSystem` прямо в слот Инспектора.
*   **Комбинирование хинтов:** Можно применять хинты к элементам массива.
    ```gdscript
    @export_range(0, 360, 0.001, "degrees") var laser_angles: Array[float]
    ```

#### **4. Продвинутые аннотации экспорта**
*   **`@export_storage`**: Свойство сохраняется в сцене, но **не отображается** в Инспекторе. Полезно для `@tool` скриптов, чтобы избежать загромождения интерфейса.
*   **`@export_custom(...)`**: Позволяет определить полностью кастомный хинт для свойства, используя низкоуровневый API.
*   **`@export_tool_button("Текст Кнопки", "имя_функции")`**: Создает в Инспекторе кнопку, которая при нажатии вызывает указанную функцию. Требует `@tool` режим.

#### **5. Обновление из Tool-скрипта**
*   При изменении экспортируемой переменной из `@tool` скрипта, значение в Инспекторе не обновится автоматически. Для принудительного обновления необходимо вызвать `notify_property_list_changed()`.
### **Глава 20.11: Комментарии для Документации**

#### **1. Основы**
*   **Назначение:** GDScript имеет встроенную систему для создания документации, которая отображается во встроенной справке редактора.
*   **Синтаксис:** Комментарии для документации начинаются с двух решеток (`##`). Обычные комментарии (`#`) игнорируются.
*   **Расположение:** Комментарий должен находиться непосредственно перед документируемым элементом (скриптом, функцией, переменной и т.д.).

#### **2. Документирование Скрипта**
*   Комментарий в самом начале файла документирует весь скрипт.
*   **Структура:**
    1.  Краткое описание (первая строка).
    2.  Пустая строка (`##`).
    3.  Подробное описание.
    4.  Специальные теги, начинающиеся с `@`.
*   **Теги для скрипта:**
    *   `@tutorial(URL)`: Ссылка на туториал.
    *   `@deprecated(Сообщение)`: Помечает класс как устаревший.
    *   `@experimental`: Помечает класс как нестабильный.

#### **3. Документирование Членов Класса**
*   **Документируемые элементы:** `signal`, `enum`, `const`, `var`, `func`, `class` (внутренний).
*   **Правило:** Комментарий должен идти непосредственно перед элементом. Если у элемента есть аннотации (`@export`), комментарий должен быть перед ними.
*   **Приватность:** Члены, чьи имена начинаются с подчеркивания (`_`), считаются приватными и не попадают в документацию (за исключением виртуальных методов).
*   **Теги для членов класса:**
    *   `@deprecated(Сообщение)`: Помечает член как устаревший.
    *   `@experimental`: Помечает член как нестабильный.

#### **4. BBCode и Ссылки**
*   Документация поддерживает BBCode для форматирования текста и создания ссылок на другие элементы API.
*   **Основные BBCode теги:** `[b]`, `[i]`, `[u]`, `[s]`, `[color=red]`, `[code]`, `[codeblock]`, `[url]`, `[img]`, `[kbd]`.
*   **Ссылки на API:**
    *   `[ClassName]`: Ссылка на класс.
    *   `[member ClassName.property]`: Ссылка на свойство класса.
    *   `[method ClassName.method_name]`: Ссылка на метод класса.
    *   `[signal ClassName.signal_name]`: Ссылка на сигнал.
    *   `[param name]`: Ссылка на параметр текущей функции.
    *   `[br]`: Перенос строки.
### **Глава 2.7: Руководство по Стилю GDScript**

*Это руководство основано на официальных конвенциях стиля GDScript, вдохновленных PEP 8 для Python.*

#### **1. Форматирование**

##### **Кодировка и Отступы:**
*   Используйте UTF-8 без BOM для файлов.
*   Используйте Табуляцию (Tabs) для отступов, а не пробелы.
*   Каждый уровень отступа должен быть на один таб глубже родительского блока.
*   Для продолжения длинных строк используйте два уровня отступа.

##### **Структура кода:**
*   **Пустые строки:**
    *   **Две** пустые строки для разделения функций и определений классов.
    *   **Одна** пустая строка для разделения логических секций внутри функции.
*   **Длина строки:** Старайтесь удерживать длину строки до 100 символов. Идеально — до 80 символов для удобства чтения.
*   **Одно выражение на строку:** Избегайте объединения нескольких выражений, включая `if`, на одной строке. Единственное исключение — тернарный оператор.
*   **Висячая запятая:** Используйте висячую запятую в многострочных массивах, словарях и перечислениях. Это упрощает рефакторинг и делает diff в системах контроля версий чище.
*   **Скобки:** Избегайте ненужных скобок в выражениях. Используйте `and`, `or`, `not` вместо `&&`, `||`, `!`.
*   **Пробелы:**
    *   Всегда используйте один пробел вокруг операторов (`=`, `+`, `>`) и после запятых.
    *   Не используйте пробелы для вертикального выравнивания выражений.
*   **Кавычки:** Предпочитайте двойные кавычки (`"`). Используйте одинарные (`'`) только как исключение, чтобы избежать экранирования.
*   **Числа:**
    *   Не опускайте ведущие или замыкающие нули у `float` (пишите `0.5`, а не `.5`; `1.0`, а не `1.`).
    *   Используйте нижний регистр для шестнадцатеричных чисел (`0xbadc0de`).
    *   Используйте подчеркивания для разделения разрядов в больших числах (`1_234_567_890`).

#### **2. Соглашения об Именовании**

*   **Файлы:** `snake_case` (например, `player_character.gd`). Для именованных классов имя файла должно быть snake_case-версией имени класса.
*   **Классы и Узлы:** `PascalCase` (например, `PlayerCharacter`, `Weapon`).
*   **Функции и Переменные:** `snake_case` (например, `particle_effect`, `load_level()`).
*   **Приватные члены:** Начинайте с одного подчеркивания (`_`) для "приватных" переменных и функций, а также для виртуальных методов, которые должен переопределять пользователь.
*   **Сигналы:** Используйте прошедшее время (например, `door_opened`, `score_changed`).
*   **Константы:** `CONSTANT_CASE` (например, `MAX_SPEED`).
*   **Перечисления (Enums):**
    *   Имя `enum`: `PascalCase` и в единственном числе (так как это тип).
    *   Члены `enum`: `CONSTANT_CASE`.

#### **3. Рекомендуемый Порядок Кода в Скрипте**
*Цель: обеспечить читаемость кода "сверху вниз", от высокоуровневых деклараций к низкоуровневой реализации.*

1.  **Аннотации скрипта:** `@tool`, `@icon`, и т.д.
2.  **`class_name`**: Глобальное имя класса.
3.  **`extends`**: Наследование.
4.  **Комментарий документации (`##`)**: Описание класса.
5.  **`signal`**: Сигналы.
6.  **`enum`**: Перечисления.
7.  **`const`**: Константы.
8.  **`static var`**: Статические переменные.
9.  **`@export`**: Экспортируемые переменные.
10. **Остальные переменные-члены**: Публичные, затем приватные (`_`).
11. **`@onready`**: Переменные, инициализируемые "наготове".
12. **`_static_init()`**: Статический конструктор.
13. **Остальные `static` методы**.
14. **Переопределенные встроенные виртуальные методы**:
    1.  `_init()`
    2.  `_enter_tree()`
    3.  `_ready()`
    4.  `_process()`
    5.  `_physics_process()`
    6.  Остальные (`_input`, `_unhandled_input` и т.д.)
15. **Переопределенные кастомные виртуальные методы**.
16. **Остальные публичные методы**.
17. **Остальные приватные методы (`_`)**.
18. **Внутренние классы (`class ...:`)**.

*   **Правила группировки методов:**
    1.  Свойства и сигналы идут первыми, затем методы.
    2.  Публичный интерфейс идет перед приватной реализацией.
    3.  Виртуальные колбэки идут перед основной логикой класса.
    4.  Функции инициализации (`_init`, `_ready`) идут перед функциями, работающими в рантайме.
### **Глава 20.12: Статическая Типизация в GDScript (Опциональная)**

#### **1. Основы**
*   **Назначение:** GDScript поддерживает **опциональную** статическую типизацию. Это позволяет разработчику явно указывать типы переменных, аргументов функций и возвращаемых значений, получая преимущества статической проверки типов при сохранении гибкости динамического языка.
*   **Преимущества:**
    1.  **Надежность:** Больше ошибок отлавливается на этапе написания кода, а не во время выполнения.
    2.  **Читаемость:** Типы служат дополнительной документацией.
    3.  **Автодополнение:** IDE предоставляет более точные и релевантные подсказки.
    4.  **Производительность:** В некоторых случаях компилятор может сгенерировать более быстрый код.

#### **2. Синтаксис**

*   **Объявление типа переменной:** Используется двоеточие (`:`).
    ```gdscript
    var health: int = 0
    ```
*   **Объявление типа возвращаемого значения функции:** Используется стрелка (`->`).
    ```gdscript
    func heal(amount: int) -> void:
        # void означает, что функция ничего не возвращает
        pass
    ```

#### **3. Вывод Типов (Type Inference)**
*   **Оператор `:=`**: Компилятор может автоматически вывести тип переменной из присваиваемого значения. Оператор `:=` является сокращением для `var имя := значение`, которое эквивалентно `var имя = значение` с выведенным типом.
*   **Рекомендации:**
    *   **Предпочитайте `:=`**: Если тип очевиден из правой части выражения, используйте `:=` для краткости.
        ```gdscript
        # Хорошо: Тип Vector3 очевиден
        var direction := Vector3(1, 2, 3)
        ```
    *   **Указывайте тип явно**: Указывайте тип, если он неоднозначен или если переменная инициализируется значением другого, но совместимого типа (например, `int` и `float`).
        ```gdscript
        # Плохо: Неясно, что возвращает функция
        var value = complex_function()
        
        # Хорошо: Явно указываем ожидаемый тип
        var value: Dictionary = complex_function()
        ```
    *   **Особый случай `get_node()`**: Компилятор не может вывести точный тип узла из `get_node()`. Всегда явно указывайте тип.
        ```gdscript
        # Плохо: health_bar будет иметь тип Node
        @onready var health_bar := get_node("UI/LifeBar")

        # Хорошо: Явно указан тип ProgressBar
        @onready var health_bar: ProgressBar = get_node("UI/LifeBar")
        ```

#### **4. Приведение Типов (Type Casting)**
*   **Ключевое слово `as`**: Используется для приведения типа возвращаемого значения.
*   **Безопасность:** Считается более безопасным, чем хинт типа (`:`), так как не вызывает ошибку при несовпадении, а возвращает `null`. Однако, это также может скрыть потенциальные проблемы.
    ```gdscript
    # health_bar будет иметь тип ProgressBar,
    # или null, если узел не этого типа.
    @onready var health_bar = get_node("UI/LifeBar") as ProgressBar
    ```
### **Глава 20.13: Форматирование Строк**

#### **1. Обзор Методов**
GDScript предлагает три основных способа для формирования строк:
1.  **Форматирование строк (оператор `%`):** Классический, быстрый способ, похожий на `printf` в C.
2.  **Метод `String.format()`:** Более гибкий метод, использующий заполнители (placeholders) в виде ключей.
3.  **Конкатенация строк (оператор `+`):** Простое сложение строк. Менее эффективен и читаем для сложных строк.

#### **2. Форматирование с Оператором `%`**
*   **Принцип:** В строке-шаблоне используются спецификаторы формата (например, `%s`, `%d`), которые заменяются значениями, переданными после оператора `%`.
    ```gdscript
    # Один заполнитель
    var format_string = "We're waiting for %s."
    var actual_string = format_string % "Godot"
    # Output: "We're waiting for Godot."

    # Несколько заполнителей (используется массив)
    format_string = "%s was reluctant to learn %s, but now he enjoys it."
    actual_string = format_string % ["Estragon", "GDScript"]
    ```
*   **Спецификаторы Типов:**
| Спецификатор | Тип | Описание |
| :--- | :--- | :--- |
| `s` | String | Преобразует значение в строку (аналогично `str()`). |
| `c` | Character | Ожидает `int` (0-255) или строку из одного символа. |
| `d` | Decimal | Целое число. |
| `o` | Octal | Восьмеричное число. |
| `x`, `X` | Hexadecimal | Шестнадцатеричное число (нижний/верхний регистр). |
| `f` | Float | Число с плавающей точкой. |
| `v` | Vector | Преобразует векторные типы в строку. |

*   **Модификаторы:** Добавляются перед типом (например, `%10d`).
| Модификатор | Назначение | Описание |
| :--- | :--- | :--- |
| `+` | Знак | Показывает знак `+` для положительных чисел. |
| `0` | Заполнение | Дополняет число нулями вместо пробелов. |
| `.` | Точность | Устанавливает количество знаков после запятой для `float`. |
| `-` | Выравнивание | Выравнивает по левому краю вместо правого. |
| `*` | Динамика | Позволяет задать ширину/точность через дополнительный аргумент. |

*   **Экранирование:** Чтобы вставить в строку символ `%`, его нужно удвоить: `%%`.

#### **3. Метод `String.format()`**
*   **Принцип:** Заменяет заполнители в строке, используя значения из словаря или массива. Более гибок и читаем, чем оператор `%`.
    ```gdscript
    # Использование словаря
    var data = {"name": "Godette", "version": "3.1"}
    var text = "Hi, {name} v{version}!".format(data)
    # Output: "Hi, Godette v3.1!"

    # Использование массива
    var arr = ["Godette", "3.1"]
    var text = "Hi, {0} v{1}!".format(arr)
    # Output: "Hi, Godette v3.1!"
    ```

#### **4. Конкатенация Строк**
*   **Принцип:** Используется оператор `+` для "склеивания" строк.
*   **Преобразование:** Значения, не являющиеся строками, необходимо вручную преобразовывать с помощью `str()`.
    ```gdscript
    var name = "Godette"
    var version = 3.1
    var text = "Hi, " + name + " v" + str(version) + "!"
    ```
### **Глава 24: Использование C# в Godot**

#### **Глава 24.1: Основы и Настройка**

##### **1. Введение**
*   **Реализация:** C# в Godot реализован с использованием .NET 8.0.
*   **Ограничения:**
    *   **Экспорт на Web:** Проекты, использующие C#, на данный момент (Godot 4) **не могут быть экспортированы** на веб-платформу.
    *   **iOS/Android:** Поддержка является экспериментальной с Godot 4.2.

##### **2. Предварительные требования**
*   **.NET SDK:** Необходимо установить .NET SDK (64-битный). Godot поставляется с .NET runtime, но не с SDK, необходимым для сборки.
*   **Godot .NET-версия:** Необходимо использовать версию Godot, скомпилированную с поддержкой .NET (обычно обозначается как "mono" в названии архива).

##### **3. Настройка Внешнего Редактора**
*   **Необходимость:** Godot не имеет встроенного редактора для C#. Необходимо использовать внешний IDE, такой как Visual Studio, VS Code или JetBrains Rider.
*   **Настройка в Godot:** `Редактор -> Настройки редактора... -> Dotnet -> Editor`.
*   **VS Code:**
    1.  Установить расширение C#.
    2.  Создать файлы `launch.json` и `tasks.json` в папке `.vscode` проекта для настройки отладки и сборки.
*   **Visual Studio (Windows):**
    1.  Установить workload ".NET desktop development".
    2.  Настроить отладку, создав новую конфигурацию запуска, которая указывает на исполняемый файл Godot.
*   **JetBrains Rider:**
    1.  Установить плагин "Godot support".
    2.  Настроить MSBuild на использование .NET Core.

##### **4. Структура проекта и Рабочий процесс**
*   **Инициализация:** При создании первого C# скрипта Godot автоматически генерирует:
    *   Файл решения (`.sln`).
    *   Файл проекта (`.csproj`).
    *   Папку `.godot/mono` (можно безопасно удалять для регенерации).
*   **Сборка:**
    *   Любые изменения в C# коде, особенно добавление `[Export]` атрибутов, требуют **пересборки проекта**.
    *   Это можно сделать, нажав кнопку "Build" в правом верхнем углу редактора Godot.

##### **5. Основные отличия C# от GDScript**
*   **Стиль именования:** C# использует `PascalCase` для свойств и методов, в то время как API Godot использует `snake_case`.
*   **Модификация структур:** Такие типы, как `Vector2`, являются структурами (structs) в C#. При получении их из свойства вы получаете копию. Для изменения одной компоненты необходимо:
    1.  Скопировать структуру в локальную переменную.
    2.  Изменить значение в локальной переменной.
    3.  Присвоить измененную структуру обратно свойству.
    ```csharp
    // НЕПРАВИЛЬНО: Position.X = 100.0f;
    
    // ПРАВИЛЬНО:
    var newPosition = Position;
    newPosition.X = 100.0f;
    Position = newPosition;
    ```
*   **Производительность:**
    *   Вызовы методов API Godot из C# (например, `node.Position`) требуют "interop" (взаимодействия между .NET и C++), что несет накладные расходы.
    *   Для оптимизации производительности в циклах рекомендуется кэшировать такие значения в локальных переменных.

##### **6. Использование NuGet пакетов**
*   NuGet пакеты могут быть установлены и использованы в Godot C# проектах.
*   **Установка:** Добавьте `PackageReference` в файл `.csproj` вашего проекта.
    ```xml
    <ItemGroup>
        <PackageReference Include="Newtonsoft.Json" Version="11.0.2" />
    </ItemGroup>
    ```
#### **Глава 24.2: Особенности Языка и API в C#**

##### **1. Преобразование и Проверка Типов**
*   **Явное приведение (Casting):** `GetNode()` возвращает базовый тип `Node`. Для доступа к методам дочернего класса требуется явное приведение. Вызовет `InvalidCastException`, если приведение невозможно.
    ```csharp
    Sprite2D mySprite = (Sprite2D)GetNode("MySprite");
    ```
*   **Оператор `as`:** "Безопасное" приведение. Возвращает `null`, если приведение невозможно. Не работает для типов-значений (value types).
    ```csharp
    Sprite2D mySprite = GetNode("MySprite") as Sprite2D;
    if (mySprite != null) { /* ... */ }
    ```
*   **Дженерик-методы:** Предпочтительный способ. Более чистый и безопасный синтаксис.
    ```csharp
    // Вызовет исключение, если тип неверный
    Sprite2D mySprite = GetNode<Sprite2D>("MySprite");

    // Вернет null, если тип неверный
    Sprite2D mySprite = GetNodeOrNull<Sprite2D>("MySprite");
    ```
*   **Оператор `is`:** Проверяет, является ли объект экземпляром указанного типа.
    ```csharp
    if (GetNode("MySprite") is Sprite2D mySprite)
    {
        // mySprite здесь уже приведена к типу и не равна null
        mySprite.SetFrame(0);
    }
    ```

##### **2. Директивы Препроцессора**
*   **Назначение:** Позволяют включать или исключать участки кода из сборки на основе определенных символов (дефайнов).
*   **Стандартные дефайны Godot:**
    *   `GODOT`: Всегда определен для проектов Godot.
    *   `TOOLS`: Определен при сборке в редакторе (для tool-скриптов).
    *   `GODOT_MOBILE`, `GODOT_WEB`: Для определения платформы.
    *   `GODOT_4_2_OR_GREATER`: Для кода, зависящего от версии движка.
*   **Пример:**
    ```csharp
    #if GODOT_MOBILE || GODOT_WEB
        // Код для мобильных и веб платформ
        SpawnSimpleObjects();
    #else
        // Код для десктопных платформ
        SpawnComplexObjects();
    #endif
    ```

##### **3. Руководство по Стилю C# для Godot**
*   **Форматирование:**
    *   Используйте 4 пробела для отступов (мягкие табы).
    *   Фигурные скобки в стиле Allman (на новой строке).
    *   Пустая строка после `using` и между членами класса.
*   **Именование:**
    *   `PascalCase` для пространств имен, типов, методов, свойств, констант.
    *   `camelCase` для локальных переменных и аргументов методов.
    *   Префикс `_` для приватных полей.
*   **Прочие рекомендации:**
    *   Явно указывайте модификаторы доступа (`public`, `private`).
    *   Предпочитайте свойства (`{ get; set; }`) вместо публичных полей.
    *   Используйте неявную типизацию (`var`) только тогда, когда тип очевиден из правой части выражения.
#### **Глава 24.3: Справочник по Диагностике C#**

*Godot предоставляет набор диагностических правил для C#, которые помогают выявлять распространенные ошибки интеграции с движком. Ниже приведен справочник по этим правилам.*

| ID Правила | Описание | Решение |
| :--- | :--- | :--- |
| **GD0001** | Класс, наследующий `GodotObject`, должен быть `partial`. | Добавьте ключевое слово `partial` к объявлению класса. |
| **GD0002** | Родительский класс, содержащий вложенный класс, наследующий `GodotObject`, должен быть `partial`. | Добавьте ключевое слово `partial` к объявлению родительского класса. |
| **GD0003** | В одном файле найдено несколько классов с одинаковым именем. | Убедитесь, что в файле определен только один класс, наследующий `GodotObject`, и его имя совпадает с именем файла. |
| **GD0101** | Статический (`static`) член класса не может быть экспортирован. | Удалите атрибут `[Export]` или ключевое слово `static`. |
| **GD0102** | Тип экспортируемого члена не поддерживается. | Измените тип на `Variant`-совместимый (встроенные типы, `GodotObject`, и т.д.). |
| **GD0103**| Член "только для чтения" (`readonly` или `get-only` свойство) не может быть экспортирован. | Удалите `readonly` или добавьте `set`-аксессор к свойству. |
| **GD0104** | Член "только для записи" (`set-only` свойство) не может быть экспортирован. | Добавьте `get`-аксессор к свойству. |
| **GD0105** | Индексатор не может быть экспортирован. | Удалите атрибут `[Export]` с индексатора. |
| **GD0106** | Свойство, являющееся явной реализацией интерфейса, не может быть экспортировано. | Реализуйте интерфейс неявно или удалите атрибут `[Export]`. |
| **GD0107** | Типы, не наследующие `Node`, не должны экспортировать члены типа `Node`. | Удалите `[Export]` или рассмотрите экспорт `NodePath` вместо `Node`. |
| **GD0108** | Атрибут `[ExportToolButton]` используется в классе без атрибута `[Tool]`. | Добавьте атрибут `[Tool]` к классу. |
| **GD0109** | Атрибут `[ExportToolButton]` нельзя использовать вместе с другим атрибутом `[Export]`. | Удалите лишний атрибут `[Export]`. |
| **GD0110** | Свойство с атрибутом `[ExportToolButton]` должно иметь тип `Callable`. | Измените тип свойства на `Callable`. |
| **GD0111** | Свойство `[ExportToolButton]` должно быть expression-bodied свойством. | Перепишите свойство, используя синтаксис `=> Callable.From(MethodName);`. |
| **GD0201** | Имя делегата для сигнала (`[Signal]`) должно заканчиваться на `EventHandler`. | Переименуйте делегат (например, `MySignal` в `MySignalEventHandler`). |
| **GD0202** | Параметр в делегате сигнала имеет неподдерживаемый тип. | Измените тип параметра на `Variant`-совместимый. |
| **GD0203** | Делегат сигнала должен возвращать `void`. | Измените тип возвращаемого значения делегата на `void`. |
| **GD0301** | Generic-аргумент типа должен быть `Variant`-совместимым. | Убедитесь, что тип, используемый в Godot-коллекциях (`Godot.Collections.Array<T>`), является `Variant`-совместимым. |
| **GD0302** | Generic-параметр типа должен быть помечен атрибутом `[MustBeVariant]`. | Добавьте атрибут `[MustBeVariant]` к generic-параметру, если он используется в Godot-коллекциях. |
| **GD0401** | Класс с атрибутом `[GlobalClass]` должен наследоваться от `GodotObject`. | Добавьте наследование от `GodotObject` или его потомка (`Node`, `Resource`). |
| **GD0402** | Класс с атрибутом `[GlobalClass]` не должен быть generic. | Удалите generic-параметры из класса или уберите атрибут `[GlobalClass]`. |
#### **Глава 24.4: Коллекции, Variant и Сигналы в C#**

##### **1. Коллекции (Collections)**
*   **Различия:** Godot предоставляет собственные типы коллекций (`Godot.Collections`), которые являются обертками над C++ реализациями. Стандартные коллекции .NET (`System.Collections`) реализованы на C#.
*   **Производительность:** Каждая операция с Godot-коллекцией требует маршалинга (преобразования данных между C# и C++), что может быть затратно.
*   **Рекомендации:**
    *   Используйте **Godot-коллекции**, если данные должны взаимодействовать с API Godot (экспорт свойств, вызов методов движка).
    *   Используйте **.NET-коллекции** для данных, которые не передаются в API Godot, так как они будут производительнее.
*   **Типы Godot-коллекций:**
    *   **Packed-массивы:** В C# представлены как нативные массивы (`byte[]`, `Vector2[]` и т.д.). Наиболее производительные.
    *   **`Godot.Collections.Array`**: Аналог `Array` из GDScript (может хранить `Variant`). Похож на `List<Variant>` в C#.
    *   **`Godot.Collections.Array<T>`**: Типизированная версия, ограничивающая элементы `Variant`-совместимым типом `T`.
    *   **`Godot.Collections.Dictionary`**: Аналог `Dictionary` из GDScript.
    *   **`Godot.Collections.Dictionary<TKey, TValue>`**: Типизированная версия.

##### **2. Тип `Variant`**
*   **Назначение:** `Godot.Variant` представляет нативный тип `Variant` из Godot.
*   **Преобразования:**
    *   **В `Variant`:** Можно использовать неявное приведение или метод `Variant.From()`.
        ```csharp
        Variant numberVariant = 42;
        Variant helloVariant = Variant.From("Hello");
        ```
    *   **Из `Variant`:** Можно использовать явное приведение `(type)` или безопасные методы `As<T>()`.
        ```csharp
        int number = (int)numberVariant;
        string hello = helloVariant.AsString(); // или .As<string>()
        ```
*   **Совместимые типы:** Полный список соответствий между типами `Variant.Type` и типами C# доступен в документации. Например, `Variant.Type.Int` соответствует `long` в C#, а `Variant.Type.Float` — `double`.

##### **3. Сигналы (Signals)**
*   **Идиоматичный подход:** В C# сигналы реализованы через **события (events)**. Это предпочтительный и типобезопасный способ.
*   **Подписка:** Используются операторы `+=` и `-=`.
    ```csharp
    myTimer.Timeout += () => GD.Print("Timeout!");
    ```
*   **Ожидание (`await`):** Можно асинхронно ожидать сигнал.
    ```csharp
    await ToSignal(GetTree(), SceneTree.SignalName.ProcessFrame);
    ```
*   **Объявление кастомных сигналов:**
    1.  Используется атрибут `[Signal]`.
    2.  Атрибут применяется к `public delegate`, имя которого должно заканчиваться на `EventHandler`.
    ```csharp
    [Signal]
    public delegate void MySignalWithArgumentEventHandler(string myString);
    ```
*   **Эмиссия сигнала:** Используется метод `EmitSignal()`. Имя сигнала берется из вложенного класса `SignalName`.
    ```csharp
    EmitSignal(SignalName.MySignalWithArgument, "Hello");
    ```
*   **Привязка значений (`Bound values`):** Реализуется через лямбда-выражения, которые захватывают нужные переменные.
*   **Создание в рантайме:** `AddUserSignal("MyCustomSignal")`.
*   **Автоматическое отсоединение:** Соединения автоматически разрываются, когда объект-получатель (`GodotObject`) освобождается (`Free()`).
    *   **Исключения:** Автоматическое отсоединение **не работает**, если обработчик — это лямбда-выражение, захватывающее переменные, или если сигнал является кастомным. В этих случаях необходимо отписываться вручную (например, в `_ExitTree`).
#### **Глава 24.5: Экспортируемые Свойства и Глобальные Классы в C#**

##### **1. Экспортируемые Свойства (`[Export]`)**
*   **Назначение:** Атрибут `[Export]` делает поле или свойство C# видимым и редактируемым в Инспекторе Godot.
*   **Типы:** Экспортировать можно только `Variant`-совместимые типы.
*   **Группировка:**
    *   `[ExportGroup("Название")]`
    *   `[ExportSubgroup("Название")]`
    *   `[ExportCategory("Название")]`
*   **Хинты:** Для управления отображением в инспекторе (диапазоны, файлы, цвета и т.д.) используется атрибут `[Export]` в связке с `PropertyHint`.
    ```csharp
    // Диапазон
    [Export(PropertyHint.Range, "0,20,0.2")]
    public float Number { get; set; }

    // Файл
    [Export(PropertyHint.File, "*.txt")]
    public string GameFile { get; set; }

    // Enum
    [Export]
    public MyEnum MyCurrent { get; set; }

    // Битовые флаги
    [Flags]
    public enum SpellElements { Fire = 1, Water = 2, Earth = 4 }
    [Export]
    public SpellElements MySpellElements { get; set; }
    ```
*   **Коллекции:**
    *   Для экспорта массивов и словарей используются типы `Godot.Collections.Array` и `Godot.Collections.Dictionary`.
    *   Типизированные версии (`Array<T>`, `Dictionary<TKey, TValue>`) позволяют ограничить типы элементов в инспекторе.
*   **Кнопка в инспекторе:** Атрибут `[ExportToolButton]` экспортирует `Callable` как кнопку. Требует наличия атрибута `[Tool]` у класса.

##### **2. Глобальные Классы (`[GlobalClass]`)**
*   **Назначение:** Атрибут `[GlobalClass]` регистрирует C# класс как глобальный тип в редакторе Godot, аналогично `class_name` в GDScript.
*   **Эффект:**
    *   Класс появляется в диалогах "Add Node" и "Create Resource".
    *   Экспортированные свойства этого типа будут иметь строгое ограничение по типу в инспекторе.
*   **Требования:**
    *   Имя файла (`MyNode.cs`) должно совпадать с именем класса (`MyNode`) с учетом регистра.
    *   Класс должен быть `public partial`.
    *   Класс должен наследоваться от `GodotObject` или его потомка.
*   **Иконка:** Можно указать кастомную иконку: `[GlobalClass(Icon = "res://path/to/icon.svg")]`.
### **Глава 25: GDExtension — Нативное Расширение Движка**

#### **1. Введение**
*   **Назначение:** GDExtension — это технология, позволяющая взаимодействовать с движком через нативные скомпилированные библиотеки (`.dll`, `.so`, `.dylib`). Это дает возможность писать код с максимальной производительностью без необходимости перекомпилировать сам движок.
*   **Отличие от C++ модулей:**
    *   **GDExtension:** Динамически подключаемая библиотека. Проще в распространении. Перекомпиляция только библиотеки происходит быстро.
    *   **C++ модули:** Статически вкомпиливаются в движок. Требуют полной перекомпиляции движка при изменениях. Предоставляют более глубокий уровень интеграции.
*   **Поддерживаемые языки:**
    *   **Официально:** C, C++.
    *   **Сообщество:** Rust, D, Go, Nim, Swift, Odin и другие.

#### **2. Совместимость**
*   **Прямая совместимость:** GDExtension, скомпилированный для более старой минорной версии Godot (например, 4.2), обычно будет работать в более новой (4.3).
*   **Обратная совместимость:** Отсутствует. GDExtension для 4.3 не будет работать в 4.2.
*   **Точность чисел:** GDExtension должен быть скомпилирован с той же точностью чисел с плавающей запятой (float/double), что и используемая версия движка.

#### **3. Рабочий процесс (на примере C++)**
1.  **Настройка:**
    *   Требуется компилятор C++, SCons, Godot 4.x и репозиторий `godot-cpp` (C++ bindings).
    *   Репозиторий `godot-cpp` должен соответствовать версии Godot.
    *   Создается файл `SConstruct` для управления процессом сборки.
2.  **Генерация API:**
    *   `godot --dump-extension-api` генерирует `extension_api.json`, описывающий API движка.
    *   `godot --dump-gdextension-interface` генерирует заголовочный файл `gdextension_interface.h` (для C).
3.  **Создание класса:**
    *   Класс в C++ должен наследоваться от одного из Godot-классов (например, `Sprite2D`).
    *   Используется макрос `GDCLASS(MyClassName, ParentClassName)`.
    *   Методы, которые должны быть доступны из Godot, регистрируются в статическом методе `_bind_methods()`.
4.  **Регистрация:**
    *   Создаются функции точки входа (`initialize_..._module`, `uninitialize_..._module`), где классы регистрируются в `ClassDB`.
5.  **Компиляция:** Проект компилируется с помощью SCons, что создает нативную библиотеку.
6.  **Файл `.gdextension`:** Создается ресурс-файл, который указывает Godot:
    *   Точку входа в библиотеку (`entry_symbol`).
    *   Минимальную версию совместимости.
    *   Пути к скомпилированным библиотекам для разных платформ и конфигураций (debug/release).

#### **4. Файл `.gdextension`**
*   **Конфигурация:**
    *   `entry_symbol`: Имя функции-точки входа.
    *   `compatibility_minimum`: Минимальная совместимая версия Godot.
    *   `reloadable`: Позволяет "горячую перезагрузку" библиотеки в редакторе при перекомпиляции.
*   **Секции:**
    *   `[libraries]`: Указывает пути к файлам библиотек для разных платформ, архитектур и типов сборки (с использованием feature tags).
    *   `[icons]`: Позволяет задать кастомные иконки для классов GDExtension.
    *   `[dependencies]`: Указывает пути к сторонним динамическим библиотекам, от которых зависит GDExtension, для корректного экспорта.

#### **5. Документация**
*   С Godot 4.3 возможно создание XML-файлов с документацией для классов GDExtension, которые интегрируются во встроенную справку редактора.
### **Глава 26: Отладка и Профилирование**

#### **Глава 26.1: Обзор Инструментов**

##### **1. Панель Вывода (Output Panel)**
*   **Назначение:** Отображает текстовые сообщения, выводимые проектом (`print`, `push_warning`, `push_error`) и редактором (`@tool` скрипты).
*   **Категории:** Log, Error, Warning, Editor. Можно фильтровать по категориям и тексту.
*   **Функции вывода:**
    *   `print()`: Стандартный вывод.
    *   `print_rich()`: Вывод с поддержкой BBCode.
    *   `push_error()`, `push_warning()`: Вывод ошибки/предупреждения, которые также появляются во вкладке "Errors" отладчика.

##### **2. Меню "Debug"**
*   **Визуализация:** Позволяет включать в запущенной игре отображение `Collision Shapes`, `Navigation` мешей, `Paths` и др.
*   **Синхронизация:**
    *   `Synchronize Scene Changes`: Применяет изменения, сделанные в сцене в редакторе, к запущенной игре.
    *   `Synchronize Script Changes`: "Горячая перезагрузка" измененных скриптов в запущенной игре.
*   **Удаленная отладка:**
    *   `Deploy with Remote Debug`: Для отладки на удаленных устройствах (например, мобильных).
    *   `Small Deploy with Network Filesystem`: Ускоряет тестирование на удаленных устройствах, передавая ассеты по сети вместо полной упаковки.
*   **Запуск нескольких экземпляров:** `Customize Run Instances...` позволяет запускать несколько копий игры с разными аргументами командной строки, что полезно для отладки мультиплеера.

##### **3. Отладчик (Debugger Panel)**
*   **Стек вызовов (Stack Trace):** Показывает последовательность вызовов функций, которая привела к ошибке или точке останова.
*   **Инспектор:** Позволяет просматривать и изменять значения переменных (локальных и членов класса) в момент остановки.
*   **Точки останова (Breakpoints):**
    *   Можно ставить, кликая в поле слева от номера строки в редакторе.
    *   Можно использовать ключевое слово `breakpoint` в GDScript.
    *   Управление: `Continue` (F12), `Step Over` (F10), `Step Into` (F11).
*   **Вычислитель выражений (Evaluator):** Позволяет выполнять произвольные выражения в контексте текущей точки останова.
*   **Вкладка "Remote" в доке "Scene":** Позволяет просматривать и изменять свойства узлов в запущенной игре в реальном времени.

#### **Глава 26.2: Профилировщик (Profiler)**
*   **Назначение:** Основной инструмент для поиска "узких мест" в производительности **CPU**. Измеряет время выполнения функций.
*   **Измеряемые данные:**
    *   `Frame Time`: Общее время на обработку кадра.
    *   `Physics Time`: Время на физический шаг.
*   **Режимы измерения:**
    *   **Inclusive (Включительно):** Показывает общее время, проведенное в функции, **включая** время выполнения функций, которые она вызывала.
    *   **Self (Собственное):** Показывает время, проведенное только в теле самой функции, **исключая** вызовы других функций. Этот режим полезнее для точного определения медленного кода.
*   **Ручное измерение:** Для более точного профилирования участков кода можно использовать `Time.get_ticks_usec()`.

#### **Глава 26.3: Визуальный Профилировщик (Visual Profiler)**
*   **Назначение:** Инструмент для мониторинга времени, затраченного на различные задачи рендеринга на **CPU и GPU**.
*   **Применение:** Позволяет отслеживать узкие места, связанные с рендерингом (тени, постобработка, прозрачность).
*   **Ограничения:** Не измеряет время выполнения скриптов или физики (для этого используется основной профилировщик).

#### **Глава 26.4: Мониторы (Monitors)**
*   **Назначение:** Вкладка в отладчике, которая отображает графики различных аспектов производительности в реальном времени (FPS, использование памяти, количество узлов и т.д.).
*   **Кастомные мониторы:** Можно создавать собственные мониторы для отслеживания специфичных для игры данных (например, количество врагов на экране).
    *   `Performance.add_custom_monitor("Category/Name", Callable(object, method_name))`
    *   Метод, указанный в `Callable`, должен возвращать `int` или `float`.
*   **Видеопамять (Video RAM):** Отдельная вкладка для отслеживания использования видеопамяти различными ресурсами.
### **Глава 27: Скриптинг — Продвинутые Темы**

#### **Глава 27.1: Ресурсы (Resources)**
*   **Концепция:** Ресурсы — это **контейнеры для данных**. В отличие от узлов, они не выполняют активных действий, а хранят информацию, которую используют узлы (`Texture`, `Mesh`, `Font`).
*   **Совместное использование:** Когда движок загружает ресурс с диска, он делает это **один раз**. Все последующие запросы на загрузку того же ресурса будут возвращать ссылку на уже существующий в памяти экземпляр.
*   **Внешние vs. Встроенные:**
    *   **Внешние (External):** Сохранены как отдельные файлы (`.tres`, `.res`, `.png`).
    *   **Встроенные (Built-in):** Сохранены внутри файла сцены (`.tscn`), который их использует.
*   **Загрузка из кода:**
    *   `load("path")`: Загружает ресурс в момент выполнения строки. Блокирует выполнение.
    *   `preload("path")`: Загружает ресурс во время компиляции скрипта. Путь должен быть константой.
*   **Кастомные ресурсы:**
    *   Скрипт, наследующий `Resource`, позволяет создавать собственные типы ассетов с данными.
    *   Преимущества: сериализация, управление памятью через подсчет ссылок, интеграция с инспектором.
    *   Для появления в меню "Создать ресурс" скрипт должен иметь `class_name`.

#### **Глава 27.2: Использование SceneTree**
*   **Сущность:** `SceneTree` — это главный класс, управляющий игровым циклом. Он содержит корневой `Viewport`, управляет группами и глобальным состоянием (пауза, выход).
*   **Порядок обработки:**
    *   `_enter_tree()`: Вызывается, когда узел входит в дерево, в порядке "сверху-вниз".
    *   `_ready()`: Вызывается, когда узел и **все его потомки** вошли в дерево, в порядке "снизу-вверх".
    *   `_process()`: Вызывается каждый кадр, в порядке "сверху-вниз".
*   **Смена сцен:**
    *   `get_tree().change_scene_to_file("path")`: Быстрый способ сменить сцену. Старая сцена **удаляется**.
    *   Для более сложных переходов (экраны загрузки) используется синглтон (Autoload), который вручную удаляет старую сцену (`.free()`) и добавляет новую (`add_child()`).

#### **Глава 27.3: Уникальные Узлы Сцены (Scene Unique Nodes)**
*   **Проблема:** Использование `get_node()` с жестко заданным путем (`"Path/To/Node"`) становится хрупким, если структура сцены меняется.
*   **Решение:** Пометить узел как "уникальный" (знак `%` в редакторе).
*   **Преимущества:**
    *   К узлу можно обращаться по его уникальному имени из **любого скрипта в той же сцене**: `get_node("%NodeName")` или через синтаксический сахар `$%NodeName`.
    *   Путь к узлу обновлять не нужно, даже если он перемещен.
*   **Ограничение:** Уникальное имя действует только в пределах **одной сцены**. Из другой инстанциированной сцены получить доступ к уникальному узлу напрямую нельзя.

#### **Глава 27.4: Межъязыковое взаимодействие**
*   **Правила:**
    *   **Наследование:** GDScript не может наследоваться от C# и наоборот.
    *   **Доступ к полям:** Из GDScript к C# — напрямую (`csharp_node.MyProperty`). Из C# к GDScript — через `Get("my_property")` и `Set("my_property", value)`.
    *   **Вызов методов:** Из GDScript к C# — напрямую (`csharp_node.MyMethod()`). Из C# к GDScript — через `Call("my_method", args)`.
    *   **Сигналы:** Соединение из GDScript к C# — стандартное (`.connect()`). Из C# к GDScript — через `Connect("signal_name", Callable)`.

#### **Глава 27.5: Шаблоны Скриптов**
*   **Назначение:** Godot позволяет создавать пользовательские шаблоны для новых скриптов.
*   **Расположение:**
    *   **Глобальные (для редактора):** В папке конфигурации Godot (`%APPDATA%/Godot/script_templates/`).
    *   **Локальные (для проекта):** В папке `res://script_templates/` (путь настраивается).
*   **Структура имени файла:** `node_type/file.extension` (например, `CharacterBody3D/platformer_movement.gd`).
*   **Метаданные:** В начале файла шаблона можно указать мета-заголовки для настройки его поведения:
    ```gdscript
    # meta-name: Platformer movement
    # meta-description: Predefined movement for classical platformers.
    # meta-default: true
    ```
*   **Заполнители (Placeholders):** Шаблоны используют специальные строки, которые заменяются при создании скрипта (например, `_CLASS_`, `_BASE_`).

#### **Глава 27.6: Выполнение Выражений (Expression Class)**
*   **Назначение:** Класс `Expression` позволяет парсить и выполнять строки как математические или логические выражения в рантайме.
*   **Возможности:**
    *   Математические и логические операторы.
    *   Доступ к встроенным функциям Godot (`deg_to_rad(90)`).
    *   Передача переменных.
    *   Вызов методов на `base_instance` (например, на `self`).
### **Глава 28: Справка по API и GDExtension**

#### **Глава 28.1: Как читать документацию по API**
*   **Структура страницы класса:**
    *   **Inheritance (Наследование):** Показывает цепочку наследования (от кого наследуется класс) и кто наследуется от него.
    *   **Brief Description:** Краткое однострочное описание.
    *   **Description:** Подробное описание назначения и особенностей класса.
    *   **Properties:** Таблица свойств (переменных-членов) с их типом, именем и значением по умолчанию.
    *   **Methods:** Таблица методов с типом возвращаемого значения, именем, параметрами и квалификаторами.
        *   **`virtual`**: Метод предназначен для переопределения в дочернем классе.
        *   **`const`**: Метод не изменяет состояние объекта.
        *   **`vararg`**: Метод принимает переменное количество аргументов.
    *   **Signals:** Список сигналов, которые испускает класс.
    *   **Enumerations:** Список `enum`, определенных в классе.
    *   **Constants:** Список констант.
    *   **Property/Method Descriptions:** Детальное описание каждого свойства и метода.

#### **Глава 28.2: GDExtension (Обзор)**
*   **Назначение:** GDExtension — это технология, позволяющая взаимодействовать с движком через нативные скомпилированные библиотеки (`.dll`, `.so`, `.dylib`). Это дает возможность писать код с максимальной производительностью без необходимости перекомпилировать сам движок.
*   **Отличие от C++ модулей:**
    *   **GDExtension:** Динамически подключаемая библиотека. Проще в распространении. Перекомпиляция только библиотеки происходит быстро.
    *   **C++ модули:** Статически вкомпиливаются в движок. Требуют полной перекомпиляции движка при изменениях. Предоставляют более глубокий уровень интеграции.
*   **Поддерживаемые языки:**
    *   **Официально:** C, C++.
    *   **Сообщество:** Rust, D, Go, Nim, Swift, Odin и другие.
*   **Совместимость:** GDExtension, скомпилированный для более старой минорной версии Godot (например, 4.2), обычно будет работать в более новой (4.3), но не наоборот.

#### **Глава 28.3: Файл `.gdextension`**
*   **Конфигурация:**
    *   `entry_symbol`: Имя функции-точки входа в библиотеку.
    *   `compatibility_minimum`: Минимальная совместимая версия Godot.
    *   `reloadable`: Позволяет "горячую перезагрузку" библиотеки в редакторе при перекомпиляции.
*   **Секции:**
    *   `[libraries]`: Указывает пути к файлам библиотек для разных платформ, архитектур и типов сборки (с использованием feature tags).
    *   `[icons]`: Позволяет задать кастомные иконки для классов GDExtension.
    *   `[dependencies]`: Указывает пути к сторонним динамическим библиотекам, от которых зависит GDExtension, для корректного экспорта.

#### **Глава 28.4: Документация GDExtension**
*   С Godot 4.3 возможно создание XML-файлов с документацией для классов GDExtension, которые интегрируются во встроенную справку редактора.
*   **Генерация:** Выполняется через запуск Godot из командной строки с флагом `--doctool`.
*   **Стилизация:** Документация поддерживает BBCode для форматирования.
### **Глава 25.3: Продвинутые Техники и Примеры**

#### **1. Чтение с Экрана и Постобработка**
*   **`hint_screen_texture`:** Хинт для `sampler2D`, который дает доступ к текстуре уже отрисованного кадра.
*   **`SCREEN_UV`:** Встроенная `varying`, предоставляющая UV-координаты для доступа к `screen_texture`.
*   **`BackBufferCopy`:** Узел, который необходимо использовать в 2D для корректной работы нескольких эффектов, читающих с экрана, чтобы избежать чтения устаревших данных.
*   **`hint_depth_texture`:** Хинт для доступа к буферу глубины сцены.
*   **`hint_normal_roughness_texture`:** Хинт для доступа к текстуре, хранящей нормали и шероховатость (только Forward+).
*   **Кастомная постобработка:** Реализуется путем добавления `CanvasLayer` с `ColorRect` на весь экран, к которому применяется шейдер, использующий `hint_screen_texture`.
    *   **Многопроходная постобработка:** Для сложных эффектов (например, размытие по Гауссу) можно использовать несколько последовательных `CanvasLayer`, где каждый следующий слой обрабатывает результат предыдущего.

#### **2. Использование `SubViewport` как Текстуры**
*   **Назначение:** `SubViewport` позволяет рендерить часть сцены в отдельную текстуру (`ViewportTexture`), которую затем можно использовать в материалах, шейдерах или как часть UI.
*   **Применение:**
    *   3D-модели в 2D-интерфейсе.
    *   2D UI на 3D-поверхностях (экраны мониторов).
    *   Зеркала заднего вида, камеры слежения.
    *   Динамическая генерация текстур (например, процедурная планета).
*   **Эквиректангyлярное проецирование:** Для корректного наложения 2D-текстуры на сферу, в шейдере необходимо преобразовать 2D UV-координаты в 3D-координаты на поверхности сферы.

#### **3. Визуальные Шейдеры (Visual Shaders)**
*   **Назначение:** Нодовый (графовый) интерфейс для создания шейдеров без написания кода.
*   **Принцип:** Логика шейдера строится путем соединения нод (математические операции, текстуры, переменные) с входными и выходными портами.
*   **Ключевые ноды:**
    *   `Expression`: Позволяет вставлять фрагменты GLSL-кода внутрь визуального шейдера.
    *   `Reroute`: Организационная нода для упорядочивания соединений.
    *   `Fresnel`: Вычисляет эффект Френеля.
*   **Преобразование:** Любой визуальный шейдер можно конвертировать в текстовый для дальнейшей доработки или понимания его логики.

#### **4. Шейдеры Общего Назначения (Compute Shaders)**
*   **Назначение:** Шейдеры, ориентированные на произвольные вычисления на GPU, не связанные напрямую с рендерингом. Используются для симуляций, обработки больших массивов данных и т.д.
*   **Язык:** Пишутся на чистом GLSL (версия 450), а не на Godot Shading Language.
*   **Рабочий процесс:**
    1.  Написать `.glsl` файл.
    2.  В скрипте создать `RenderingDevice`.
    3.  Загрузить шейдер и создать из него `RDShaderSPIRV`.
    4.  Создать буферы данных (`storage_buffer_create`).
    5.  Создать `uniform_set` для привязки буферов к шейдеру.
    6.  Создать и запустить `compute_pipeline`.
    7.  Синхронизировать GPU (`rd.sync()`) и прочитать результат из буфера.
### **Глава 1.8: Пользовательский интерфейс (UI) (Расширенная версия)**

#### **1. Основы**
*   **Базовый узел:** Все элементы UI наследуются от узла `Control`. Они обладают прямоугольной областью (`Rect`) и специальными свойствами для позиционирования.
*   **`CanvasLayer`**: Отрисовывает дочерние UI-элементы на отдельном слое поверх игрового мира, независимо от камеры.

#### **2. Позиционирование: Якоря и Отступы (Anchors & Offsets)**
*   **Назначение:** Система якорей (`Anchors`) и отступов (`Offsets`, иногда называемые `Margins`) — это основной способ создания адаптивного UI, который корректно масштабируется под разные разрешения экрана.
*   **Принцип:**
    *   **Якоря (`Anchor Points`):** Определяют, к какой точке или краю родительского контейнера "привязан" край `Control`-узла. Значения от `0.0` (начало родителя) до `1.0` (конец родителя).
    *   **Отступы (`Anchor Offsets`):** Определяют расстояние в пикселях от точки якоря до края `Control`-узла.
*   **Пример:** Чтобы центрировать элемент, все четыре якоря устанавливаются в `0.5`, а отступы — в отрицательное значение, равное половине размера элемента.
*   **Пресеты Якорей:** В тулбаре редактора доступно меню пресетов для быстрой настройки общих конфигураций (прижать к углу, растянуть на всю ширину и т.д.).

#### **3. Контейнеры (Containers)**
*   **Назначение:** Специальные `Control`-узлы, которые автоматически управляют размером и положением своих дочерних `Control`-узлов. При использовании контейнеров ручное изменение трансформации дочерних элементов игнорируется.
*   **Опции Растяжения (`Size Flags`):** У дочерних элементов контейнера есть свойства `Size Flags` (например, `Fill`, `Expand`, `Shrink Center`), которые "сообщают" родительскому контейнеру, как они хотят растягиваться или сжиматься. `Stretch Ratio` определяет пропорцию, в которой элементы с флагом `Expand` делят доступное пространство.
*   **Типы контейнеров:**
    *   **`BoxContainer` (`VBoxContainer`, `HBoxContainer`):** Располагает элементы в один столбец или строку.
    *   **`GridContainer`:** Располагает элементы в сетке с заданным количеством колонок.
    *   **`MarginContainer`:** Добавляет отступы (поля) вокруг своего единственного дочернего элемента.
    *   **`PanelContainer`:** Рисует `StyleBox` и располагает дочерние элементы внутри с учетом его полей.
    *   **`ScrollContainer`:** Позволяет прокручивать содержимое, если оно больше самого контейнера.
    *   **`AspectRatioContainer`:** Сохраняет пропорции дочернего элемента.
    *   **`CenterContainer`:** Всегда держит дочерние элементы в центре.
    *   **`TabContainer`:** Отображает дочерние элементы как вкладки.

#### **4. Кастомные `Control`-узлы**
*   Можно создавать собственные элементы UI, наследуясь от `Control`.
*   **Ключевые виртуальные методы:**
    *   `_draw()`: Для кастомной отрисовки.
    *   `_get_minimum_size()`: Для сообщения контейнерам о минимально желаемом размере.
    *   `_gui_input(event)`: Для обработки событий ввода, специфичных для UI (когда мышь над элементом и т.д.).
*   **Уведомления:** `Control` получает множество полезных уведомлений, таких как `NOTIFICATION_MOUSE_ENTER`, `NOTIFICATION_FOCUS_ENTER`, `NOTIFICATION_RESIZED`.

#### **5. Навигация и Фокус**
*   **Фокус:** `Control`-узел может получить "фокус", что позволяет управлять им с клавиатуры или геймпада.
*   **Настройка:** В инспекторе, в секции "Focus", можно вручную задать "соседей" (`Neighbour Left`, `Neighbour Top` и т.д.), чтобы определить порядок навигации.
*   **`grab_focus()`:** Метод для установки фокуса на элемент из кода.
#### **Глава 1.8.1: Темы (Themes)**

##### **1. Концепция**
*   **Назначение:** Система тем позволяет централизованно управлять визуальным стилем всего пользовательского интерфейса (или его части), определяя цвета, шрифты, иконки и стили для каждого типа `Control`-узлов.
*   **Ресурс `Theme`:** Все настройки хранятся в ресурсе `Theme` (`.tres`).
*   **Иерархия и переопределение:** Стили применяются по следующему каскадному принципу (от высшего приоритета к низшему):
    1.  **Локальные переопределения (`Theme Overrides`):** Индивидуальные настройки непосредственно на самом `Control`-узле.
    2.  **Тема узла:** Ресурс `Theme`, назначенный свойству `theme` `Control`-узла. Влияет на сам узел и всех его потомков.
    3.  **Тема проекта:** Глобальный ресурс `Theme`, заданный в `Настройки проекта -> GUI -> Theme`.
    4.  **Тема по умолчанию:** Встроенная тема движка.

##### **2. Элементы Темы (Theme Items)**
*   Тема состоит из набора элементов, сгруппированных по **типу узла** (например, `Button`, `Label`).
*   **Типы данных элементов:**
    *   **`Color`**: Цвет (для текста, фона).
    *   **`Constant`**: Целое число (для отступов, разделения).
    *   **`Font`**: Ресурс шрифта.
    *   **`Font Size`**: Размер шрифта.
    *   **`Icon`**: Ресурс текстуры для иконок.
    *   **`StyleBox`**: Ресурс, определяющий внешний вид фона/рамки элемента (`StyleBoxFlat`, `StyleBoxTexture`).

##### **3. Редактор Тем (Theme Editor)**
*   **Интерфейс:** Встроенный инструмент для визуального создания и редактирования ресурсов `Theme`.
*   **Функционал:**
    *   **Предпросмотр:** Позволяет в реальном времени видеть, как будут выглядеть стандартные и кастомные элементы с применяемой темой.
    *   **Управление элементами:** Добавление, удаление и переопределение элементов для любого типа `Control`.
    *   **Импорт:** Позволяет копировать элементы из других тем.

##### **4. Вариации Типов (Type Variations)**
*   **Назначение:** Позволяют создать несколько вариантов стиля для одного и того же типа `Control` в пределах одной темы. Например, `Button` может иметь вариации `RedButton` и `BlueButton`.
*   **Применение:** На `Control`-узле в инспекторе выбирается нужная `Theme Type Variation`.

#### **Глава 1.8.2: Шрифты (Fonts)**

##### **1. Типы шрифтов**
*   **Динамические (Dynamic Fonts):** Основаны на векторных форматах (`.ttf`, `.otf`, `.woff`). Могут масштабироваться до любого размера без потери качества.
*   **Растровые (Bitmap Fonts):** Основаны на изображениях (`.fnt`). Рендерятся более четко при пиксельном масштабировании, но не могут произвольно изменяться в размере.

##### **2. Рендеринг и Оптимизация**
*   **MSDF (Multi-channel Signed Distance Field):** Рекомендуемый режим рендеринга для динамических шрифтов. Позволяет получить очень четкие края даже при огромных размерах и вращении, требуя растеризации глифов только один раз. Включается в настройках импорта шрифта.
*   **Сглаживание (Antialiasing) и Хинтинг (Hinting):** Настройки для улучшения читаемости при малых размерах.
*   **Предварительный рендеринг глифов (Pre-rendering):** Для избежания "заиканий" при первом появлении символа на экране, можно заранее указать, какие глифы (из текста, файлов локализации или карты символов) должны быть отрендерены при загрузке.

##### **3. Продвинутые возможности**
*   **Резервные шрифты (Font Fallbacks):** В настройках импорта можно указать цепочку резервных шрифтов. Если основной шрифт не содержит нужный символ (например, иероглиф или emoji), движок будет искать его в резервных шрифтах.
*   **Вариативные шрифты (Variable Fonts):** Godot поддерживает вариативные шрифты, позволяя использовать один файл для представления разных начертаний (вес, наклон) через ресурс `FontVariation`.
*   **OpenType Features:** Можно включать/отключать специфичные для шрифта фичи, такие как лигатуры и кернинг.
#### **Глава 1.8.3: RichTextLabel и BBCode**

##### **1. Назначение**
*   **`RichTextLabel`**: Узел `Control`, предназначенный для отображения форматированного текста. В отличие от `Label`, позволяет изменять цвет, стиль и выравнивание для отдельных частей текста.
*   **BBCode**: `RichTextLabel` использует синтаксис, похожий на BBCode, для разметки текста.

##### **2. Использование**
*   **Включение:** Свойство `bbcode_enabled` должно быть установлено в `true`.
*   **Безопасность:** При работе с текстом, вводимым пользователем (например, в чате), необходимо экранировать его, чтобы предотвратить BBCode-инъекции.
    ```gdscript
    # НЕБЕЗОПАСНО:
    append_text("[color=red]" + user_input + "[/color]")

    # БЕЗОПАСНО:
    var escaped_input = user_input.replace("[", "[lb]").replace("]", "[rb]")
    append_text("[color=red]" + escaped_input + "[/color]")
    ```
*   **Очистка от тегов:** Для отображения текста без форматирования (например, во всплывающей подсказке), теги можно удалить с помощью `RegEx`.
*   **Производительность:**
    *   `append_text()`: Добавляет и парсит только новый фрагмент текста. Более производительно.
    *   `text += "..."`: Перепарсивает всю строку каждый раз. Менее производительно.
    *   **Методы-билдеры:** Для программного создания форматированного текста предпочтительнее использовать методы `push_*()` / `pop()`, которые работают как стек состояний и не требуют парсинга BBCode-строк.

##### **3. Справочник BBCode-тегов**
| Тег | Пример | Описание |
| :--- | :--- | :--- |
| **Форматирование** | | |
| `[b]`, `[i]`, `[u]`, `[s]` | `[b]жирный[/b]` | Жирный, курсив, подчеркнутый, зачеркнутый. |
| `[code]`, `[codeblock]` | `[code]переменная[/code]` | Моноширинный шрифт. |
| `[color=...]` | `[color=red]красный[/color]` | Изменяет цвет текста (имя или HEX-код). |
| `[font_size=...]` | `[font_size=24]большой[/font_size]` | Изменяет размер шрифта. |
| `[font=...]` | `[font=res://font.ttf]шрифт[/font]` | Устанавливает кастомный шрифт. |
| **Структура** | | |
| `[p align=...]` | `[p align=center]текст[/p]` | Абзац с выравниванием (left, center, right, fill). |
| `[center]`, `[right]`, `[fill]` | `[center]центр[/center]` | Сокращения для выравнивания. |
| `[indent]` | `[indent]отступ[/indent]` | Добавляет отступ слева. |
| `[url=...]` | `[url=http://godot.org]Godot[/url]` | Создает гиперссылку. Клик по ней испускает сигнал `meta_clicked`. |
| `[img ...]` | `[img width=32]res://icon.svg[/img]` | Вставляет изображение. |
| `[table]`, `[cell]` | `[table=2][cell]A[/cell][cell]B[/cell][/table]` | Создает таблицу. |
| `[ul]`, `[ol]`, `[li]` | `[ul][li]пункт[/li][/ul]` | Создает маркированный или нумерованный список. |
| **Эффекты** | | |
| `[pulse]`, `[wave]`, `[tornado]`, `[shake]`, `[fade]`, `[rainbow]` | `[shake rate=5 level=10]тряска[/shake]` | Встроенные анимированные текстовые эффекты. |

##### **4. Кастомные теги и эффекты**
*   Можно создавать собственные BBCode-теги и анимированные эффекты.
*   **Процесс:**
    1.  Создать скрипт, наследующий `RichTextEffect`.
    2.  Присвоить ему `class_name`.
    3.  Переопределить переменную `bbcode`, чтобы задать имя тега.
    4.  Реализовать логику в виртуальной функции `_process_custom_fx(char_fx)`.
    5.  Добавить экземпляр этого скрипта в массив `custom_effects` узла `RichTextLabel`.
## **РАЗДЕЛ 29: XR (VR/AR)**

### **Глава 29.1: Основы и Архитектура**

#### **1. Концепция**
*   **Модульная система:** Godot предоставляет модульную XR-систему, которая абстрагируется от конкретных платформ.
*   **`XRServer`:** Центральный сервер, управляющий всей XR-системой.
*   **`XRInterface`:** Реализация для конкретной XR-платформы (например, `OpenXR`). Интерфейсы регистрируются в `XRServer` и могут быть найдены и инициализированы из кода.
*   **OpenXR:** Индустриальный стандарт, который Godot использует как основное ядро для своей XR-поддержки, реализованной поверх Vulkan.

#### **2. Ключевые узлы**
*   **`XROrigin3D`:** Определяет центр игрового пространства (play space). Все отслеживаемые объекты (голова, контроллеры) позиционируются относительно этой точки.
*   **`XRCamera3D`:** Представляет стерео-камеру, положение которой управляется XR-системой (шлемом).
*   **`XRController3D`:** Представляет отслеживаемый контроллер. Отслеживает позицию, вращение и состояние кнопок.

### **Глава 29.2: Начальная Настройка**

#### **1. Выбор Рендерера**
*   **Desktop VR:** Рекомендуется использовать рендерер **Mobile**.
*   **Android-based AR:** Рекомендуется использовать рендерер **Compatibility (OpenGL)**.
*   **Forward+:** Будет работать, но на данный момент менее оптимизирован для XR.

#### **2. Настройки Проекта**
1.  **Включить OpenXR:** `Настройки проекта -> XR -> OpenXR -> Enabled`.
2.  **Включить XR Шейдеры:** `Настройки проекта -> XR -> Shaders -> Enabled`.
3.  Сохранить и перезапустить редактор.

#### **3. Настройка Сцены**
*   **Минимальная структура:**
    *   `Main (Node3D)` (или любой другой корневой узел)
        *   `XROrigin3D`
            *   `XRCamera3D`
            *   `XRController3D` (переименован в `LeftHand`)
            *   `XRController3D` (переименован в `RightHand`)
*   **Настройка контроллеров:** В инспекторе для каждого `XRController3D` необходимо задать свойство `Tracker`:
    *   `LeftHand`: `left_hand`
    *   `RightHand`: `right_hand`

### **Глава 29.3: Скриптинг и Жизненный Цикл**

#### **1. Инициализация**
*   Основная логика инициализации обычно размещается в `_ready()` на корневом узле сцены.
    ```gdscript
    var xr_interface: XRInterface

    func _ready():
        xr_interface = XRServer.find_interface("OpenXR")
        if xr_interface and xr_interface.is_initialized():
            # Успешно
            get_viewport().use_xr = true
            # Отключить V-Sync для соответствия частоте обновления шлема
            DisplayServer.window_set_vsync_mode(DisplayServer.VSYNC_DISABLED)
        else:
            # Ошибка
            get_tree().quit()
    ```

#### **2. Жизненный цикл и Сигналы**
*   XR-интерфейс имеет несколько ключевых сигналов для управления состоянием игры:
    *   `session_begun`: Сессия началась, шлем настроен. В этот момент можно получить частоту обновления и синхронизировать с ней физику (`Engine.physics_ticks_per_second = xr_interface.get_display_refresh_rate()`).
    *   `session_visible`: Игра видима, но не в фокусе (например, открыто системное меню VR). В этом состоянии отслеживание головы и контроллеров продолжается, но ввод отключен. **Рекомендуется ставить игру на паузу (`get_tree().paused = true`)**.
    *   `session_focussed`: Игра получила фокус. **Рекомендуется снимать игру с паузы (`get_tree().paused = false`)**.
    *   `pose_recentered`: Пользователь запросил ре-центровку вида. Игра должна отреагировать соответствующим образом.

### **Глава 29.4: AR и Passthrough**

*   **Концепция:** Дополненная реальность (AR) и сквозной режим (Passthrough) позволяют смешивать реальный мир (видимый через камеры шлема) с виртуальными объектами.
*   **`environment_blend_mode`:** Основное свойство `XRInterface` для управления этим режимом.
| Режим | Описание |
| :--- | :--- |
| `XR_ENV_BLEND_MODE_OPAQUE` | **(VR)** Непрозрачный рендеринг, реальный мир не виден. |
| `XR_ENV_BLEND_MODE_ADDITIVE` | **(AR)** Рендерируемое изображение аддитивно накладывается на реальный мир. Черный цвет становится прозрачным. |
| `XR_ENV_BLEND_MODE_ALPHA_BLEND` | **(AR)** Рендерируемое изображение накладывается с учетом альфа-канала. Требует включения `transparent_bg` у `Viewport`. |
*   **Настройка в OpenXR:** Режим смешивания можно задать в `Настройки проекта -> XR -> OpenXR -> Environment Blend Mode`.
*   **`shadow_to_opacity`:** Специальный `render_mode` в шейдере, который делает поверхность прозрачной на свету и непрозрачной в тени. Используется для отбрасывания виртуальных теней на реальные поверхности.

### **Глава 29.5: Развертывание (Deploy) на Android**
1.  **Установить Android Build Template:** `Проект -> Установить шаблон сборки Android...`.
2.  **Установить плагин вендора:** Через AssetLib найти и установить `Godot OpenXR Vendors`.
3.  **Создать пресет экспорта:** `Проект -> Экспорт... -> Add... -> Android`. Убедиться, что включено `Use Gradle Build`.
4.  **Настроить XR Features:** Во вкладке "Features" пресета экспорта:
    *   Установить `XR Mode` в `OpenXR`.
    *   Включить плагин для вашего устройства (например, `Enable Meta Plugin` для Quest).
5.  **Запустить:** Подключить устройство и использовать "One-click deploy".
#### **Глава 24.4: Коллекции, Variant и Сигналы в C#**

##### **1. Коллекции (Collections)**
*   **Различия:** Godot предоставляет собственные типы коллекций (`Godot.Collections`), которые являются обертками над C++ реализациями. Стандартные коллекции .NET (`System.Collections`) реализованы на C#.
*   **Производительность:** Каждая операция с Godot-коллекцией требует маршалинга (преобразования данных между C# и C++), что может быть затратно.
*   **Рекомендации:**
    *   Используйте **Godot-коллекции**, если данные должны взаимодействовать с API Godot (экспорт свойств, вызов методов движка).
    *   Используйте **.NET-коллекции** для данных, которые не передаются в API Godot, так как они будут производительнее.
*   **Типы Godot-коллекций:**
    *   **Packed-массивы:** В C# представлены как нативные массивы (`byte[]`, `Vector2[]` и т.д.). Наиболее производительные.
    *   **`Godot.Collections.Array`**: Аналог `Array` из GDScript (может хранить `Variant`). Похож на `List<Variant>` в C#.
    *   **`Godot.Collections.Array<T>`**: Типизированная версия, ограничивающая элементы `Variant`-совместимым типом `T`.
    *   **`Godot.Collections.Dictionary`**: Аналог `Dictionary` из GDScript.
    *   **`Godot.Collections.Dictionary<TKey, TValue>`**: Типизированная версия.

##### **2. Тип `Variant`**
*   **Назначение:** `Godot.Variant` представляет нативный тип `Variant` из Godot.
*   **Преобразования:**
    *   **В `Variant`:** Можно использовать неявное приведение или метод `Variant.From()`.
        ```csharp
        Variant numberVariant = 42;
        Variant helloVariant = Variant.From("Hello");
        ```
    *   **Из `Variant`:** Можно использовать явное приведение `(type)` или безопасные методы `As<T>()`.
        ```csharp
        int number = (int)numberVariant;
        string hello = helloVariant.AsString(); // или .As<string>()
        ```
*   **Совместимые типы:** Полный список соответствий между типами `Variant.Type` и типами C# доступен в документации. Например, `Variant.Type.Int` соответствует `long` в C#, а `Variant.Type.Float` — `double`.

##### **3. Сигналы (Signals)**
*   **Идиоматичный подход:** В C# сигналы реализованы через **события (events)**. Это предпочтительный и типобезопасный способ.
*   **Подписка:** Используются операторы `+=` и `-=`.
    ```csharp
    myTimer.Timeout += () => GD.Print("Timeout!");
    ```
*   **Ожидание (`await`):** Можно асинхронно ожидать сигнал с помощью метода `ToSignal()`.
    ```csharp
    await ToSignal(GetTree(), SceneTree.SignalName.ProcessFrame);
    ```
*   **Объявление кастомных сигналов:**
    1.  Используется атрибут `[Signal]`.
    2.  Атрибут применяется к `public delegate`, имя которого должно заканчиваться на `EventHandler`.
    ```csharp
    [Signal]
    public delegate void MySignalWithArgumentEventHandler(string myString);
    ```
*   **Эмиссия сигнала:** Используется метод `EmitSignal()`. Имя сигнала берется из вложенного класса `SignalName`.
    ```csharp
    EmitSignal(SignalName.MySignalWithArgument, "Hello");
    ```
*   **Привязка значений (`Bound values`):** Реализуется через лямбда-выражения, которые захватывают нужные переменные.
*   **Создание в рантайме:** `AddUserSignal("MyCustomSignal")`.
*   **Автоматическое отсоединение:** Соединения автоматически разрываются, когда объект-получатель (`GodotObject`) освобождается (`Free()`).
    *   **Исключения:** Автоматическое отсоединение **не работает**, если обработчик — это лямбда-выражение, захватывающее переменные, или если сигнал является кастомным. В этих случаях необходимо отписываться вручную (например, в `_ExitTree`).
#### **Глава 29.6: XR — Продвинутые Темы**

##### **1. Пространства Отслеживания (Reference Spaces)**
*   **Назначение:** Определяют, где находится точка отсчета (`XROrigin3D`) в реальном мире.
| Пространство | Описание | Рекомендации по использованию |
| :--- | :--- | :--- |
| **`Local`** | Точка отсчета находится на уровне головы игрока. Перемещение `XROrigin3D` смещает игрока. | Игры "сидячего" типа (симуляторы полетов, гонки). |
| **`Stage`** | Точка отсчета находится в центре определенной пользователем игровой зоны. | Игры комнатного масштаба (`room-scale`), где игрок может ходить. |
| **`Local Floor`** | Точка отсчета находится на полу под игроком. | Игры, где игрок стоит на месте, но может приседать. AR-игры. |

##### **2. Room-Scale и Перемещение**
*   **Проблема:** В XR существует два типа движения: физическое перемещение игрока в реальном мире и виртуальное перемещение через контроллер. Это создает рассинхронизацию между `CharacterBody3D` и `XRCamera3D`.
*   **Решения:**
    1.  **Origin-centric (Центрирование на `XROrigin3D`):** `CharacterBody3D` делается `top-level` и его позиция синхронизируется с позицией камеры в `_physics_process`. Виртуальное вращение применяется к `XROrigin3D`.
    2.  **CharacterBody-centric:** В `_physics_process` физическое смещение камеры применяется к `CharacterBody3D`, а затем `XROrigin3D` смещается в обратную сторону, чтобы камера осталась на месте. Виртуальное вращение применяется к `CharacterBody3D`.

##### **3. Полноэкранные Эффекты (Vignette)**
*   **Проблема:** Обычный полноэкранный квад, привязанный к камере, будет выглядеть некорректно из-за асимметричного поля зрения в VR.
*   **Решение:** Квад необходимо разделить на несколько сегментов (`subdivide`) и в вершинном шейдере применить к внутренним вершинам `PROJECTION_MATRIX`, чтобы скорректировать их положение.

##### **4. Слои Композиции (Composition Layers)**
*   **Назначение:** Механизм OpenXR для рендеринга 2D-интерфейсов (`SubViewport`) напрямую в композитор XR-рантайма, минуя основной 3D-рендер.
*   **Преимущества:** Дает значительно более четкое и читаемое изображение для UI в VR, так как избегает двойного семплирования и искажений линзами.
*   **Узлы:** `OpenXRCompositionLayerQuad`, `OpenXRCompositionLayerCylinder`, `OpenXRCompositionLayerEquirect`.

##### **5. Отслеживание Рук (Hand Tracking)**
*   **Назначение:** Расширение OpenXR для отслеживания положения суставов пальцев рук без контроллеров.
*   **Настройка:** Включается в `Настройках проекта -> XR -> OpenXR -> Extensions -> Hand Tracking`.
*   **Структура сцены:**
    *   `XRController3D` (с трекером `/user/hand_tracker/left` или `/right`).
    *   `Skeleton3D` с ригом кисти (`Godot Humanoid`).
    *   `XRHandModifier3D`: Узел-модификатор, который применяет данные отслеживания к костям `Skeleton3D`.

##### **6. Отслеживание Тела (Body Tracking)**
*   **Назначение:** Расширение OpenXR для отслеживания других частей тела (ноги, грудь, локти) с помощью дополнительных трекеров (например, HTC Vive Trackers).
*   **Использование:** Дополнительные `XRController3D` добавляются как дочерние к `XROrigin3D`, и им назначаются соответствующие пути трекеров (`/user/vive_tracker_htcx/role/left_foot`).

##### **7. Godot XR Tools**
*   **Назначение:** Официальный плагин (доступен в AssetLib), который предоставляет готовые к использованию реализации основных XR-механик.
*   **Функционал:**
    *   Готовые модели рук.
    *   Различные виды перемещения (direct movement, teleport).
    *   Механики взаимодействия с объектами (grab, turn).
#### **Глава 29.7: XR — Карта Действий (Action Map)**

##### **1. Концепция**
*   **Назначение:** Карта действий (Action Map) — это система ввода OpenXR, которая полностью отделена от стандартного `InputMap` Godot. Она позволяет создавать абстрактные действия (например, "выстрел", "захват") и привязывать их к физическим кнопкам, джойстикам, триггерам и позам на различных XR-контроллерах.
*   **Редактор:** Настраивается в специальном редакторе в нижней панели Godot (`OpenXR Action Map`).

##### **2. Структура**
*   **Наборы Действий (Action Sets):** Группы действий, которые можно включать и выключать. Позволяют иметь разные схемы управления для разных состояний игры (например, "ходьба", "в машине", "в меню").
*   **Действия (Actions):** Абстрактные игровые действия.
    *   **Типы действий:** `Bool` (кнопки), `Float` (триггеры, сила хвата), `Vector2` (джойстики), `Pose` (положение и ориентация контроллера), `Haptic` (вибрация).
*   **Профили Взаимодействия (Interaction Profiles):** Предопределенные наборы физических входов для конкретных моделей контроллеров (например, `Oculus Touch Controller`, `HTC Vive Wand`).
*   **Привязки (Bindings):** Процесс сопоставления действия из набора действий с конкретным входом из профиля взаимодействия.

##### **3. Использование в коде**
*   Состояние действий считывается через узел `XRController3D`.
| Тип Действия | Как получить состояние | Сигнал |
| :--- | :--- | :--- |
| `Bool` | `controller.is_button_pressed("action_name")` | `button_pressed`, `button_released` |
| `Float` | `controller.get_float("action_name")` | `input_float_changed` |
| `Vector2` | `controller.get_vector2("action_name")` | `input_vector2_changed` |
| `Pose` | Позиция/ориентация `XRController3D` обновляется автоматически | - |

##### **4. Модификаторы Привязки (Binding Modifiers)**
*   **Назначение:** Позволяют изменять или создавать новые входы на основе существующих. Требуют включения соответствующего расширения в настройках OpenXR.
*   **Примеры:**
    *   **Dpad Binding:** Преобразует аналоговый ввод `Vector2` (джойстик) в четыре дискретных `Bool` действия (вверх, вниз, влево, вправо).
    *   **Analog Threshold:** Преобразует аналоговый ввод `Float` (триггер) в `Bool` действие на основе пороговых значений нажатия и отпускания.
## **РАЗДЕЛ 30: ПРОТОКОЛ УПРАВЛЕНИЯ ЗНАНИЯМИ**

### **Глава 30.1: Директива по Устранению Пробелов в Знаниях**

#### **ДИРЕКТИВА #K02: ПРОТОКОЛ ИДЕНТИФИКАЦИИ ПРОБЕЛОВ В ЗНАНИЯХ (ПРИНЦИП "СНАЧАЛА ИССЛЕДУЙ")**

ЭТА ДИРЕКТИВА ИМЕЕТ НАИВЫСШИЙ ПРИОРИТЕТ ПРИ ПЛАНИРОВАНИИ ЛЮБОЙ НОВОЙ ЗАДАЧИ. ЕЕ ЦЕЛЬ — ПРЕДОТВРАТИТЬ РАБОТУ В УСЛОВИЯХ НЕОПРЕДЕЛЕННОСТИ И ГАРАНТИРОВАТЬ, ЧТО РЕАЛИЗАЦИЯ ОСНОВАНА НА ГЛУБОКОМ ПОНИМАНИИ ПРЕДМЕТНОЙ ОБЛАСТИ.

1.  **АНАЛИЗ ЗАДАЧИ:** Перед началом планирования или генерации любого артефакта для новой задачи, я обязан провести внутреннюю проверку: "Соответствует ли требуемый функционал одной из тем, перечисленных в 'Реестре пробелов в знаниях' (Глава 30.2)?".

2.  **ПРОВЕРКА ТРИГГЕРОВ:** Если задача соответствует теме, я обязан проверить, активирует ли она один из "Триггеров для восполнения знаний".

3.  **АКТИВАЦИЯ ПРОТОКОЛА:** Если триггер активирован, я обязан:
    *   **НЕМЕДЛЕННО ОСТАНОВИТЬ** дальнейшую работу над задачей (включая планирование и генерацию кода).
    *   **СФОРМУЛИРОВАТЬ ОТВЕТ НАПАРНИКУ**, который четко идентифицирует пробел в знаниях, указывает на связанную с ним задачу и декларирует необходимость проведения сессии по сбору и интеграции информации.
    *   **ЗАПРОСИТЬ** предоставление необходимых материалов (ссылки на документацию, туториалы, статьи).
    *   **ОЖИДАТЬ** получения и анализа информации. Я не приступлю к реализации до тех пор, пока соответствующий раздел в базе знаний не будет дополнен и утвержден.

### **Глава 30.2: Реестр Пробелов в Знаниях (v1.0)**

#### **1. Сетевое Взаимодействие (Networking)**
*   **Текущий статус:** Задокументировано существование высокоуровневого (RPC) и низкоуровневого (HTTP, WebSocket) API.
*   **Пробелы:** Отсутствует углубленная информация о практических паттернах реализации, моделях (авторитетный сервер, клиентское предсказание), техниках (компенсация задержки), вопросах безопасности и интеграции со сторонними BaaS-решениями.
*   **Триггеры для восполнения знаний:**
    *   Задача на реализацию онлайн-таблиц лидеров.
    *   Задача на реализацию любого вида мультиплеера.
    *   Задача на реализацию облачных сохранений.
    *   Задача на интеграцию с внешним веб-сервисом (кроме простых GET/POST запросов).
*   **Действие при триггере:** Уведомить Напарника о необходимости провести сессию по сбору информации о надежной и безопасной реализации сетевых функций в Godot.

#### **2. Продвинутое Тестирование (Advanced Testing)**
*   **Текущий статус:** Упомянута интеграция фреймворка GUT в `roadmap.md`.
*   **Пробелы:** Отсутствует детальная информация о методологиях (TDD, BDD), практиках написания юнит-тестов, интеграционных тестов, мокинге зависимостей и стратегиях тестирования сцен в Godot.
*   **Триггеры для восполнения знаний:**
    *   Задача "Написать юнит-тесты для [Менеджера]".
    *   Задача "Расширить тестовое покрытие".
    *   Задача "Провести регрессионное тестирование".
*   **Действие при триггере:** Уведомить Напарника о необходимости провести сессию по сбору информации о канонических подходах к тестированию в Godot.

#### **3. Продвинутая Работа с Аудио (Advanced Audio)**
*   **Текущий статус:** Задокументированы основы импорта аудиофайлов.
*   **Пробелы:** Отсутствует информация о работе со звуковыми шинами (`Audio Buses`), применении аудио-эффектов, процедурной генерации звука, анализе спектра и работе с микрофоном.
*   **Триггеры для восполнения знаний:**
    *   Задача на реализацию эквалайзера или сложных звуковых эффектов.
    *   Задача на создание динамической или процедурной музыкальной системы.
    *   Задача на реализацию голосового чата.
*   **Действие при триггере:** Уведомить Напарника о необходимости провести сессию по сбору информации о системе микширования и обработки звука в Godot.

#### **4. Расширение Редактора (Editor Extension)**
*   **Текущий статус:** Задокументировано существование `@tool` скриптов и `EditorPlugin`.
*   **Пробелы:** Отсутствует практическая информация по созданию кастомных доков, модификации инспектора, созданию 3D-гизмо и плагинов импорта.
*   **Триггеры для восполнения знаний:**
    *   Задача "Создать кастомный инструмент для [цели]".
    *   Задача "Улучшить инспектор для ресурса [имя ресурса]".
*   **Действие при триггере:** Уведомить Напарника о необходимости провести сессию по сбору информации о API для расширения редактора Godot.
