{
  "version": "1.1",
  "modifications": [
    {
      "action": "MODIFY_FILE",
      "path": "_ark_system/_tools/synchronizer.py",
      "expected_checksum_before": "13a57b143d92e0e5d52d721c8f66f509c1ce6fae7cc697576b3b4acc1c464e68",
      "content": "#!/usr/bin/env python3\n\"\"\"\nsynchronizer.py\nSynchronize local monorepo -> central repo and per-project \"vitrine\" repos.\n\nUsage:\n  python synchronizer.py --config _ark_system/sync_config.json [--dry-run] [--allow-dirty] [--force]\n\nRequirements:\n  - git in PATH\n  - network auth configured for git pushes (ssh keys or credential helper)\n\"\"\"\nfrom __future__ import annotations\nimport argparse\nimport json\nimport os\nimport subprocess\nimport sys\nimport time\nfrom datetime import datetime, timedelta\n\nLOCK_FILE = os.path.join(os.getcwd(), \".synchronizer.lock\")\nDEFAULT_LOCK_TIMEOUT = 2 * 60 * 60  # seconds (2 hours)\n\ndef run_cmd(cmd, cwd=None, capture=False, check=True, dry_run=False):\n    print(f\"> {' '.join(cmd)} (cwd={cwd or os.getcwd()})\")\n    if dry_run:\n        return 0, \"\"\n    if capture:\n        proc = subprocess.run(cmd, cwd=cwd, stdout=subprocess.PIPE, stderr=subprocess.STDOUT, text=True, encoding='utf-8')\n        if check and proc.returncode != 0:\n            raise subprocess.CalledProcessError(proc.returncode, cmd, output=proc.stdout)\n        return proc.returncode, proc.stdout\n    else:\n        proc = subprocess.run(cmd, cwd=cwd)\n        if check and proc.returncode != 0:\n            raise subprocess.CalledProcessError(proc.returncode, cmd)\n        return proc.returncode, None\n\ndef ensure_repo_root():\n    try:\n        rc, out = run_cmd([\"git\", \"rev-parse\", \"--show-toplevel\"], capture=True)\n        return out.strip()\n    except Exception:\n        print(\"Error: current directory is not inside a git repository or git is missing.\", file=sys.stderr)\n        raise\n\ndef load_config(path):\n    with open(path, \"r\", encoding=\"utf-8\") as f:\n        return json.load(f)\n\ndef write_lock(timeout_seconds):\n    if os.path.exists(LOCK_FILE):\n        age = time.time() - os.path.getmtime(LOCK_FILE)\n        if age < timeout_seconds:\n            raise RuntimeError(f\"Lock file exists and is recent (age {age:.0f}s). Abort.\")\n        else:\n            print(\"Stale lock found: removing.\")\n            os.remove(LOCK_FILE)\n    with open(LOCK_FILE, \"w\", encoding=\"utf-8\") as lf:\n        lf.write(f\"{os.getpid()}\\n{datetime.utcnow().isoformat()}\\n\")\n\ndef remove_lock():\n    try:\n        if os.path.exists(LOCK_FILE):\n            os.remove(LOCK_FILE)\n    except Exception as e:\n        print(f\"Warning: failed to remove lock file: {e}\")\n\ndef ensure_clean_worktree(allow_dirty):\n    rc, stdout = run_cmd([\"git\", \"status\", \"--porcelain\"], capture=True)\n    if stdout.strip():\n        if allow_dirty:\n            print(\"Warning: working tree is dirty but --allow-dirty specified; continuing.\")\n        else:\n            raise RuntimeError(\"Working tree has uncommitted changes. Commit or pass --allow-dirty.\")\n\ndef ensure_remote_exists(remote_name, remote_url, dry_run):\n    rc, out = run_cmd([\"git\", \"remote\", \"get-url\", remote_name], capture=True, check=False, dry_run=dry_run)\n    if rc == 0 and out.strip() == remote_url:\n        return remote_name, False\n    temp_name = f\"temp_remote_{int(time.time())}\"\n    run_cmd([\"git\", \"remote\", \"add\", temp_name, remote_url], dry_run=dry_run)\n    return temp_name, True\n\ndef remove_remote_if_temp(remote_name, was_temp, dry_run):\n    if was_temp:\n        run_cmd([\"git\", \"remote\", \"remove\", remote_name], dry_run=dry_run)\n\ndef push_central(central_remote, central_branch, dry_run, force):\n    ref = central_branch or \"HEAD\"\n    args = [\"git\", \"push\", central_remote, f\"HEAD:{ref}\"]\n    if force:\n        args.insert(2, \"--force\")\n    run_cmd(args, dry_run=dry_run)\n\ndef subtree_push(prefix, remote_name, remote_branch, dry_run, force):\n    try:\n        args = [\"git\", \"subtree\", \"push\", \"--prefix\", prefix, remote_name, remote_branch]\n        run_cmd(args, dry_run=dry_run)\n        return\n    except subprocess.CalledProcessError as e:\n        print(f\"git subtree push failed or not available: {e}. Using fallback (subtree split).\")\n    temp_branch = f\"subtree-split-{int(time.time())}\"\n    run_cmd([\"git\", \"subtree\", \"split\", \"--prefix\", prefix, \"-b\", temp_branch], dry_run=dry_run)\n    push_args = [\"git\", \"push\", remote_name, f\"{temp_branch}:{remote_branch}\"]\n    if force:\n        push_args.insert(2, \"--force\")\n    run_cmd(push_args, dry_run=dry_run)\n    run_cmd([\"git\", \"branch\", \"-D\", temp_branch], dry_run=dry_run)\n\ndef main():\n    parser = argparse.ArgumentParser(description=\"Synchronize monorepo to central and project remotes.\")\n    parser.add_argument(\"--config\", \"-c\", default=\"_ark_system/sync_config.json\", help=\"Path to sync config JSON\")\n    parser.add_argument(\"--dry-run\", action=\"store_true\", help=\"Show commands but don't execute\")\n    parser.add_argument(\"--allow-dirty\", action=\"store_true\", help=\"Allow uncommitted changes\")\n    parser.add_argument(\"--force\", action=\"store_true\", help=\"Force pushes to remote (use with care)\")\n    parser.add_argument(\"--lock-timeout\", type=int, default=DEFAULT_LOCK_TIMEOUT, help=\"Lock timeout seconds before stale\")\n    args = parser.parse_args()\n\n    try:\n        repo_root = ensure_repo_root()\n    except Exception as e:\n        print(e, file=sys.stderr)\n        sys.exit(1)\n    os.chdir(repo_root)\n\n    try:\n        cfg = load_config(args.config)\n    except Exception as e:\n        print(f\"Failed to load config {args.config}: {e}\", file=sys.stderr)\n        sys.exit(1)\n\n    central = cfg.get(\"central\", {})\n    central_remote = central.get(\"remote\", \"origin\")\n    central_branch = central.get(\"branch\", \"main\")\n    projects = cfg.get(\"projects\", [])\n\n    try:\n        write_lock(args.lock_timeout)\n    except Exception as e:\n        print(e, file=sys.stderr)\n        sys.exit(1)\n\n    try:\n        ensure_clean_worktree(args.allow-dirty)\n        print(f\"\\n==> Pushing central repo to '{central_remote}/{central_branch}'\")\n        push_central(central_remote, central_branch, args.dry_run, args.force)\n\n        for p in projects:\n            prefix = p[\"prefix\"]\n            repo_url = p[\"repo_url\"]\n            branch = p.get(\"branch\", \"main\")\n            print(f\"\\n==> Project '{p.get('name', prefix)}' -> prefix '{prefix}' -> {repo_url}:{branch}\")\n\n            remote_name_to_use = p.get(\"remote_name\", f\"temp_sync_{p.get('name', 'proj')}\")\n            temp_remote_name, was_temp = ensure_remote_exists(remote_name_to_use, repo_url, args.dry_run)\n\n            try:\n                subtree_push(prefix, temp_remote_name, branch, args.dry_run, args.force)\n            finally:\n                if was_temp:\n                    remove_remote_if_temp(temp_remote_name, was_temp, args.dry_run)\n\n        print(\"\\nAll operations completed successfully.\")\n    except Exception as e:\n        print(f\"\\nERROR: {e}\", file=sys.stderr)\n        remove_lock()\n        sys.exit(2)\n    finally:\n        remove_lock()\n\nif __name__ == \"__main__\":\n    main()\n"
    }
  ]
}